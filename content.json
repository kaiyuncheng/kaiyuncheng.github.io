{"pages":[],"posts":[{"title":"Before starting","text":"為何會開始學code今年，也是Covid-19疫情大爆發的一年。我在國外打滾了好幾年，待了幾個國家，圓了一個年輕時的潛水夢想回到台灣，一方面是短期可能不能再出國了，一方面是對未來有別的規劃，因此決定轉換跑道，所以趟上了學習前端這個無底洞道路。 選擇前端是因為大學時期念工業設計，先前做設計師時的工作上有接觸過一些網站視覺設計和app的UI設計，更早期還是國中生時，曾經迷上一陣子網站設計，當時雖然是用Dreamweaver和frontpage的年代，但也製作出電子報和個人網站，印象中還用了FTP上傳到免費空間，不知道這樣是不是不小心透露了年紀了 XD。加上高中時期數學蠻好的，讓我認為學寫程式可能蠻適合我的。 學習的道路上今年5月開始在線上找尋學習資源，線上課程、教學網站、技術文章、別人的分享等等，Medium是我很常去看文章的平台，再加上好幾位大大的blog、Youtube。從中學習到非常多，越學越會發現還有更多要學的呢，學習過程中覺得寫扣很有趣，尤其是辛苦寫完畫面功能成功後的成就感，一切都值得。之後會在我的blog-CodeNotes上再分享有哪些推薦的網站。 CodeNotes的第一天最近看了許多大大用hexo創建自己的blog，覺得很有趣從中又可以學到code的用法，於是就也照本宣科創建了CodeNotes，還有許多功能在摸索，另外也會開始慢慢post最近學習不專業筆記。還請各位觀眾多多指教。","link":"/2020/10/27/beforeStarting/"},{"title":"[JS 60 Days] Day 1 to Day 10 - JS變數","text":"Introduction這個挑戰練習是由hexschool建立的，這邊會紀錄Day1-20的練習 Day 1 - JS 環境與變數環境 Day 2 - 變數命名 Day 3 - 變數型別判斷與弱型別轉型 Day 4 - 比較運算子 Day 5 - 變數實作情境題 Day 6 - 邏輯運算子情境題 Day 7 - if - 認真的小杰竟被客訴 Day 8 - if 與指派運算子 - 幫幫小杰的金魚腦 Day 9 - 觀念總整理 - 幫小杰學會 Function 之呼吸 Day 10 - 函式參數設計 Day1JS 環境與變數環境第 1 題123456// 1.產生 console.log 從上到下的值為？// 2.出現幾個變數、型別、記憶體物件?var a ;a = 1;a = &quot;hello&quot;;console.log(a) hello 1 2 3 第 2 題1234567// 1.產生 console.log 從上到下的值為？// 2.出現幾個變數、型別、記憶體物件?var b = 3 ;var c = 4;console.log(d)var d = b+c;console.log(d) undefined 7 3 1 6 第 3 題12345678// 1.產生 console.log 從上到下的值為？// 2.出現幾個變數、型別、記憶體物件?console.log(e)var e;e = 5;e = &quot;hello&quot;e = true;console.log(e) undefined true 1 3 4 Day2變數命名請依照以下房型資訊，去定義各個變數名稱，變數務必要命名比較語意化且好懂。 carbon Day3變數型別判斷與弱型別轉型請依序告知以下 console.log 會顯示什麼值。 第一題12345678910111213var a = 1;console.log(typeof(a)); //Numbervar b = &quot;hello&quot;;console.log(typeof(b)); //Stringvar c = 1+&quot;hello&quot;;console.log(typeof(c)); //Stringvar d = 1+&quot;11&quot;;console.log(d) //111console.log(typeof(d)) //String 第二題1234567var a;a = a+&quot;hello&quot;console.log(a); //undefinedhelloconsole.log(typeof(a)) //Stringvar b = 3;console.log(b*&quot;hello&quot;); //NaN 第三題1234567var a = 9;console.log(a+9); //18console.log(a+'9'); //99var b = &quot;9&quot;;console.log(b*b) //81console.log(typeof(b*b)) //Number Day4比較運算子請依序告知以下 console.log 會顯示什麼值。 第一題1234567891011121314var a = 2;var b = 1;console.log(a&gt;0); //trueconsole.log((a+b)&gt;1); //truevar c = 4;var d = 3;console.log(c == d); //falsevar e = 8;var f = 5;console.log(f &gt;= e) //falseconsole.log(f != e); //true console.log(f == e); //false 第二題 搭配型別自動轉型123456789var a=3; var b=&quot;3&quot;;console.log(a==1); //falseconsole.log(a==b); //truevar c = 2;var d = &quot;5&quot;;// 請解釋為什麼console.log((c*d)&gt;=5) //true 字串5轉型別為數字 2*5=10 大於等於5 第三題 嚴謹模式123456var a = 1;var b = &quot;1&quot;;console.log(a==1); //trueconsole.log(a==b); //trueconsole.log(a===b); //falseconsole.log(a!==b); //true Day5變數實作情境題你現在是美式餐廳的櫃檯收銀員，但老闆因為預算有限，所以沒有買收銀機，所以你只能透過 JavaScript 來幫顧客結帳。 以下變數都不可變更： 第一題：顧客 Bob 向店員詢價顧客 Bob：「請問我要買 4 個漢堡，30 份薯條，總共多少？」 123456789101112// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var bobTotal;// 請將 Code 寫在這,運算內容賦予到 bobTotal,// 並要利用到 hamburgerPrice、friesPrice// 算出 Bob 的提問。bobTotal = hamburgerPrice * 4 + friesPrice * 30;console.log( &quot;Bob 您好,您詢問的金額總計為&quot;+bobTotal+&quot;元&quot;); 第二題：錢包剩下多少錢mark 錢包裡有 200 元，買了一個漢堡，三個薯條，他還剩下多少錢？ 12345678910111213// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var markWallet = 200;var markTotal;// 請將 Code 寫在這，運算内容賦予到 markTotal,// 並要利用到 markWallet、hamburgerPrice、friesPrice// 算出 mark 購買後剩餘的金額。markTotal = markWallet - ( hamburgerPrice * 1 + friesPrice * 3 );console.log('馬克買完東西後,錢包剩下'+markTotal +'元') 第三題：顧客 Mary 提供折扣券顧客 Mary 身上有 5000 元，想要買 10 份漢堡、10 份薯條，因為他有會員卡，所以可以打九折優惠，請問他還剩下多少錢？ 1234567891011121314// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var sale = 0.9;var maryWallet = 5000var maryTotal;// 請將 Code寫在這，運算內容賦予到 maryTotal ,// 並要利用到hamburgerPrice、friesPrice、sale、maryWallet// 算出 maryTotal 剩下的錢。maryTotal = maryWallet - sale * ( hamburgerPrice * 10 + friesPrice * 10 );console.log( 'Mary 買完東西後,錢包剩下'+ maryTotal +'元') Day6邏輯運算子情境題題目一：布林與比較運算子練習成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Bob 買了 2 個漢堡，2 個 薯條，是否有滿足條件？ 123456789101112var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;var isVIP;// 請透過比較運算子，將比較結果寫在isVip 上// 請利用 VIPTotal、hamburgerPrice、friesPrice 的變數進行比較// isVIP 的型別必須為布林值(true or false)isVIP = (( 2 * hamburgerPrice ) + ( 2 * friesPrice )) &gt;= VIPTotal ? true : false;console.log(&quot;Bob的 VIP 條件為&quot;+isVIP) 題目二：三心二意的老闆希望用邏輯運算子 &amp;&amp;老闆發現大家都只買薯條衝 VIP 資格，導致大家都不買漢堡，老闆好生氣，他認為他的美味蟹堡是全美最好吃的，小杰也不知道他的自信從哪裡來的。 所以他跟小杰說，從今天起，VIP 條件必須同時符合以下兩點，才能成為 VIP 資格。 一次消費滿 200 元 一定要買 1 個漢堡 這時又來了兩位顧客，Mary 與 Mark，來看看他們有沒有符合條件吧！ 1234567891011121314151617181920212223242526272829// 此變數不可更改var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;var markHamburgerNum = 2;var markFriesNum = 4;var markIsVIP;// 如上面新增的變數，馬克買了 2 個漢堡，與 4 個薯條// 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上// markIsVIP 的型別必須為布林值 (true or false)markIsVIP = (( markHamburgerNum * hamburgerPrice ) + ( markFriesNum * friesPrice )) &gt;= VIPTotal &amp;&amp; markHamburgerNum &gt;= 1 ? true : false;console.log(&quot;mark 的 VIP 條件為&quot;+ markIsVIP)var maryHamburgerNum = 0;var maryFriesNum = 10;var maryIsVIP;// 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條// 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上// maryIsVIP 的型別必須為布林值 (true or false)maryIsVIP = (( maryHamburgerNum * hamburgerPrice ) + ( maryFriesNum * friesPrice )) &gt;= VIPTotal &amp;&amp; maryHamburgerNum &gt;= 1 ? true : false;console.log(&quot;mary 的 VIP 條件為&quot;+ maryIsVIP) 題目三：Mary 很生氣，他覺得現在的 VIP 資格吃人夠夠，希望用 || 邏輯運算子Mary 說：「老闆我好歹是忠實老客戶欸，我買了你八年的薯條，而且遠遠超過 200 元，竟然還不算我是 VIP，你有沒有搞錯！」老闆怕了，他很擔心會上台灣的老天鵝娛樂被當作笑柄，所以他立馬將 VIP 條件改成，只要符合以下任一點消費條件，就能成為 VIP 資格。 一次消費滿 200 元 一定要買 1 個漢堡 我們再看看 Mary 有沒有符合條件吧！ 123456789101112131415var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;var maryHamburgerNum = 0;var maryFriesNum = 10;var maryIsVIP;// 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條// 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上// maryIsVIP 的型別必須為布林值 (true or false)maryIsVIP = (( maryHamburgerNum * hamburgerPrice ) + ( maryFriesNum * friesPrice )) &gt;= VIPTotal || maryHamburgerNum &gt;= 1 ? true : false;console.log(&quot;mary 的 VIP 條件為&quot;+ maryIsVIP) Day7if - 認真的小杰竟被客訴題目一：if 的練習老闆說現在要來驗收 if 成果，成為 VIP 會員的條件，只要購買滿 200 元，現在 會員 A 購買了 350 元，請用 if 判斷是否要給他 VIP 卡。 123456789var VIPTotal = 200;var memberPrice = 350;// 請透過 if 來設計回覆，如果對方滿足門檻// 就回覆 console.log(&quot;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上&quot;)if( memberPrice &gt;= VIPTotal){ console.log(&quot;您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上)&quot;)}; 題目二：if else 的練習又有人來申請 VIP 活動了！成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Mark 買了 2 個漢堡，2 個 薯條，是否有滿足條件？這次要記得用 if，以及注意你的語氣啊~ (小杰覺得人生好難 123456789101112131415161718var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;// 請透過 if else 來去設計對方是否有達到條件，有或沒有都需要回覆對方// 如果有，請顯示 console.log(&quot;尊敬的客戶您好，您有達到 VIP 條件&quot;)// 如果沒有達到條件，便用 else 顯示 console.log(&quot;尊敬的客戶您好，您還差 xx 元，才有符合 VIP 條件哦~&quot;)let markTotal = hamburgerPrice * 2 + friesPrice * 2;let shortageif ( markTotal &gt;= VIPTotal){ console.log(&quot;尊敬的客戶您好，您有達到 VIP 條件&quot;);} else{ shortage = VIPTotal - markTotal console.log(`尊敬的客戶您好，您還差 ${shortage} 元，才有符合 VIP 條件哦~`);}; 題目三： if、else if、else 練習工作一整天，小杰累到懷疑人生，累歸累，但還是得吃東西，小杰吃東西有自己的 SOP，來幫幫小杰看看他該吃什麼食物。 小杰都用飢餓度 1~100 來計算，100 就是代表最飢餓，數值皆為整數，不會有小數點 小杰飢餓度 0~20 時，都吃飯糰 小杰飢餓度在 21~40 時，都吃肉燥飯+貢丸湯 小杰飢餓度在 41~60 時，都吃麥當勞 小杰飢餓度在 61~100 時，都吃 99 元火鍋吃到飽 今天小杰的飢餓度是 53，請引導小杰去指定地點用餐 1234567891011121314// 請用 if、else if 去判斷主人公該吃什麼// 各區塊回覆內容請顯示 console.log(&quot;主人公因為飢餓度在&quot;+hungryNum+&quot;，所以他決定去吃麥當勞&quot;)var hungryNum = 53;if(hungryNum &gt;= 20){ console.log(&quot;主人公因為飢餓度在&quot;+hungryNum+&quot;，所以他決定去吃飯糰&quot;);}else if(hungryNum &gt; 20 &amp;&amp; hungryNum &lt;= 40){ console.log(&quot;主人公因為飢餓度在&quot;+hungryNum+&quot;，所以他決定去吃肉燥飯+貢丸湯&quot;);}else if(hungryNum &gt; 40 &amp;&amp; hungryNum &lt;= 60){ console.log(&quot;主人公因為飢餓度在&quot;+hungryNum+&quot;，所以他決定去吃麥當勞&quot;);}else{ console.log(&quot;主人公因為飢餓度在&quot;+hungryNum+&quot;，所以他決定去吃99 元火鍋吃到飽&quot;);} Day8if 與指派運算子 - 幫幫小杰的金魚腦題目一：老闆考考你指派運算子老闆：「我其實很懷疑你是不是真的會了，我考考你！」老闆：「剛好今天是發薪日，先發給你薪資 23500 元(遞給小杰」小杰：「謝謝腦闆，但你怎麼把我的薪資告訴大家了..」老闆：「這不是重點，以下兩步驟動作請寫成程式」老闆：「步驟一：因為你遲到一次，我要扣你 1000 元(取走小杰手上的 1000 元」老闆：「步驟二：然後你又偷吃 Pizza，我要再扣你 2500 元 (再次取走」小杰：「不是啊！那明明是小黑吃..」老闆：「這不是重點，快點算！算出你還剩下多少錢！」 1234567var salary = 23500;// 請依照上面的武功秘笈Codepen，依序實現兩步驟,算出小杰被扣了多少錢salary = salary - 1000 - 2500;console.log(&quot;小杰目前還剩下&quot;+salary+&quot;元&quot;); 題目二： if + 指派運算子老闆：「好了，現在我要告訴你贈品條件！」 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品 而現在來了兩個客人，並依序有消費，請問現在他還剩下多少個贈品？ 12345678910111213var giftNum = 3; // 贈品數量var customerA = 150;// 顧客 A 消費金額var customerB = 99; // 顧客 B 消費金額if(customerA &gt;= 100){ giftNum -= 1;};if(customerB &gt;= 100){ giftNum -= 1;};console.log(&quot;目前贈品剩下&quot;+giftNum+&quot;個&quot;); //2 題目三：if+指派運算子老闆：「我現在補齊給你總計 50 個贈品！」老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」小杰：「老闆你今天這麼慷慨，那我的薪..」老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」 123456789101112131415161718var giftNum = 50; // 贈品數量var friesPrice = 30; // 薯條單價var hamburgerPrice = 50; // 漢堡單價// 以下是題目// mary 買了 10 份薯條，10 份漢堡// 請計算完贈品規則後,善用指派運算子去計算目前剩下的贈品有幾個// 並用下面的 if 回報給老聞maryTotal = friesPrice * 10 + hamburgerPrice * 10;if(giftNum &gt;= 0){ if(maryTotal &gt;= 50) giftNum = giftNum - Math.floor(maryTotal / 50); console.log(&quot;老聞!贈品還夠!剩下&quot;+giftNum+&quot;個~&quot; ); //34} else { console.log(&quot;老聞贈品賣光啦~&quot;);} Day9觀念總整理 - 幫小杰學會 Function 之呼吸第一式：變數型別之呼吸請回覆以下 console.log 內容 123456789101112131415161718192021var a = 1;a+=1;a+=5;var b = 5;console.log(a+b); //12var c = 3;var d = &quot;hello&quot;;console.log(c*d); //NaNvar e = 8 + 2 * &quot;9&quot;;console.log(e); //26var f = 1;var g = &quot;2&quot;;var h = 3;console.log(typeof(f+g+h)); //String 第二式運算子之呼吸請回覆以下 console.log 內容 12345678910111213141516var total = 200;var isVip = true;console.log(total&gt;=200 &amp;&amp; isVip); // truevar a = true;var b = false;console.log( a &amp;&amp; b); // falseconsole.log( a || b); // truevar c = 10;var d = 20;var e = 30;console.log(c==10 &amp;&amp; d&gt;=5 &amp;&amp; e !== 20); // trueconsole.log(c==10 || d&gt;=5 || e !== 20); // trueconsole.log(c==5 || d&gt;=40 || e !== 30); // false 第三式運算子之呼吸請告知以下 console.log，哪些會印出？如果你很閒，試試看最後一題改下布林值。 1234567891011121314151617181920212223242526var maryIsVIP = true;if(maryIsVIP){ console.log(&quot;哇貴婦餒！&quot;); // 會印出}else{ console.log(&quot;你一定搞錯了，叫你們店長出來！&quot;);}var momSwim = false;var girlfriendSwim = true;if(momSwim &amp;&amp; girlfriendSwim){ console.log(&quot;都不救，因為他們都會游泳&quot;);}else{ console.log(&quot;小杰大喊：「你們誰不會游泳啊？？」&quot;); if(girlfriendSwim){ console.log(&quot;那你自己游上來！&quot;); // 會印出 }else{ console.log(&quot;我先問我阿母會不會游泳！&quot;); } if(momSwim){ console.log(&quot;媽妳先自己游上來！&quot;); }else{ console.log(&quot;媽我去救你！&quot;); // 會印出 }} Day10函式參數設計第一題：客戶詢價函式，來更多個客人也不怕請改設計一個詢價用的函式，並新增三個參數，依序為客戶姓名、薯條數量，漢堡數量。同時來了三個客戶，請執行三次函式回報結果。 12345678910111213//定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var bobTotal;// 請將Code寫在這,運算內容賦予到 bobTotal,// 並要利用到 hamburgerPrice、friesPrice// 算出 Bob 的提問。function total(guestName, hamburgerNum, friesNum) { return `${guestName} 您好,您詢問的金額總計為 ${hamburgerPrice * hamburgerNum + friesPrice * friesNum} 元`;}console.log(total('Bob', 1, 2)); 第二題：好多客戶都在問小杰，他們錢包剩下多少錢，小杰表示無言下面截圖，請改設計一個查詢客戶錢包餘額用的函式，並新增四個參數，依序為客戶姓名、客戶錢包總額、薯條數量，漢堡數量。 同時來了三個客戶，請執行三次函式回報結果。 123456789101112131415161718// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var markWallet = 200;var markTotal;// 請將Code寫在這,運算內容賦予到markTotal,// 並要利用到 markWallet hamburgerPrice friesPrice// 算出 mark購買後剩餘的金額。console.log('馬克買完東西後,錢包剩下'+markTotal +'元')function total(guestName, walletTotal ,friesNum, hamburgerNum) { return `${guestName} 買完東西後,錢包剩下 ${ walletTotal - (hamburgerPrice * hamburgerNum + friesPrice * friesNum) } 元`;}console.log(total('Mark', markWallet, 10, 5)) 第三題：好多人都擁有九折優惠券這一題，換您來設計函式與參數看看。 突然間同時來了三個客戶，請執行三次函式回報結果。 12345678910111213141516// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var sale = 0.9;var maryWallet = 5000var maryTotal;// 請將Code寫在這,運算內容賦予到 maryTotal,// 並要利用到hamburgerPrice friesPrice sale maryWallet// 算出 maryTotal 剩下的錢。function total(guestName, walletTotal ,friesNum, hamburgerNum) { return `${guestName} 買完東西後,錢包剩下 ${ walletTotal - (hamburgerPrice * hamburgerNum + friesPrice * friesNum) * sale } 元`;}console.log(total('Mary', maryWallet, 10, 5));","link":"/2020/10/28/js60Day1toDay10/"},{"title":"[JS 60 Days] Day 11 to Day 35 - JS函式陣列","text":"Introduction接續上篇，這邊開始第11天 JS函式陣列 Day 11 - 函式參數再練習 Day 12 - DOM 操作 Day 13 - 函式+if 判斷 Day 14 - 監聽與函式設計 Day 15 - 物件運用 - 資料與渲染分離 Day 16 - forEach 與 HTML 字串累加 Day 17 - innerHTML+forEach Day 18 - 字串相加 innerHTML+ 樣式搭配 Day 19 - 驗收前夕 Day 20 - BMI 計算機團戰關卡 Day 21 - BMI 追加功能 Day 22 - BMI 陣列調整 Day 23 - 資料格式處理，陣列 unshift Day 24 - 資料格式處理，forEach + 陣列處理(一) Day 25 - 資料格式處理，forEach + 陣列處理(二) Day 25-2 - OpenData資料處理 Day 26 - AJAX、axios 題目 Day 26-2 - AJAX、axios 全台展覽資訊站 Day 27 - 陣列補充觀念 Day 28 - 陣列排序進度 Day 29 - 監聽切換排序功能 Day 30 - C3.js 圖表整合 Day 31 - 部落格文章閱讀 Day 32 - 程式整合篇 Day 33 - 圓餅圖分析 Day 34 - 圓餅圖分析(中文字串判別) Day 35 - 圓餅圖與長條圖合併使用 Day11函式參數再練習題目一：老闆想要隨時扣你的薪水老闆：「今天是發薪日，先發給你薪資 23500 元(遞給小杰」老闆：「以下三步驟動作請寫成程式」老闆：「步驟一：昨天你上廁所太久了，我要扣你 1000 元」老闆：「步驟二：小黑說不喜歡你煮的狗食，我要再扣你 3500 元 (再次取走」老闆：「步驟三：我今天心情不太好，扣個 500 元意思一下」小杰：「屁啦！心情不太好關我啥事！」老闆：「這不是重點，快點算！將之前的寫法換成函式，並增加一個參數，讓我方便何時扣你多少都沒問題」老闆：「最後你寫的函式，要執行三次，每次都要回報你的總薪水剩下多少。」 12345678910var salary = 23500;function deduct(num){ salary = salary - num; console.log(&quot;小杰目前還剩下&quot;+salary+&quot;元&quot;);};deduct(1000);deduct(3500);deduct(500); 題目二： if + 指派運算子老闆：「好了，現在我要告訴你贈品條件！」 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品 下圖為第八關截圖，請依照以下邏輯進行改寫： 現在來了三個客人，並依序有消費，A顧客消費 150、B 顧客消費 99、C 顧客消費 110。 請設計一個函式，裡面代入一個參數為顧客消費金額，確認該客戶是否符合贈品條件，若符合就讓 giftNum 變數減少數量。 並依序執行三次函式，每次函式皆會 return 目前贈品數量剩下多少。 123456789101112131415161718192021// 贈品數量 var giftNum = 3;var customerA = 150; // 顧客 A 消費金額var customerB = 99; // 顧客 B 消費金額var customerC = 110; // 顧客 C 消費金額function gift(num){ if(num &gt;= 100 &amp;&amp; giftNum &gt; 0){ giftNum -= 1; console.log(&quot;目前贈品剩下&quot;+giftNum+&quot;個&quot;); } else if(num &lt; 100){ console.log(&quot;消費不夠沒有贈品&quot;); } else{ console.log(&quot;沒有贈品了&quot;); };};gift(customerA);gift(customerB);gift(customerC); 題目三：if+指派運算子老闆：「我現在補齊給你總計 200 個贈品！」老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」小杰：「老闆你竟然利用我的特休，我跟你沒完啦。」老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」 下圖為第八關截圖，giftNum 已改為 200 份，請依照以下邏輯進行改寫： 請用函式改寫，同時來了三組客人，請用你寫的函式連續執行三次，來幫助顧客是否有符合贈品條件。 另外每次執行函式時，都必須告訴老闆一次目前贈品數量。 第一組客人：Mary 買了 10 份薯條，10 份漢堡第二組客人：Bob 買了 1 份薯條第三組客人：Tim 買了 20 份薯條，15 份漢堡 123456789101112131415161718192021222324252627var giftNum = 200; // 贈品數量var friesPrice = 30; // 薯條單價var hamburgerPrice = 50; // 漢堡單價let total;// 以下是題目// mary買了10份薯條,10份漢堡// 請計算完贈品規則後,善用指派運算子去計算目前剩下的贈品有幾個// 並用下面的 if 回報給老閱function gift(friesNum, hamburgerNum){ total = friesNum * friesPrice + hamburgerNum * hamburgerPrice if(giftNum &gt; 0){ if(total &gt;= 50){ giftNum = giftNum - Math.floor( total / 50 ); console.log(&quot;老閱!贈品還夠!剩下&quot;+giftNum+&quot;個~&quot;); } else{ console.log(&quot;客人消費不夠沒有贈品&quot;); }; } else{ console.log(&quot;老闖贈品賣光啦~&quot;) };};gift(10, 10);gift(1);gift(20, 15); Day12DOM 操作題目 請觀看此 Codepen 的線索，試圖找到密碼，並回傳密碼 以下 Codepen 的 HTML 與 CSS 面板都壞掉了，你只能編輯 JS 面板，來去尋找線索 123456789101112131415161718&lt;div class=&quot;key&quot;&gt;&lt;!-- 區塊一 --&gt; &lt;div class=&quot;keyItem keyItem1&quot; &gt; &lt;img src=&quot;https://hexschool.github.io/JSTraining/stage12/4.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;!-- 區塊二 --&gt; &lt;div class=&quot;keyItem keyItem2&quot;&gt; &lt;img src=&quot;https://hexschool.github.io/JSTraining/stage12/2.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;!-- 區塊三 --&gt; &lt;div class=&quot;keyItem keyItem3&quot;&gt; &lt;/div&gt;&lt;!-- 區塊四 --&gt; &lt;div class=&quot;keyItem keyItem4&quot; style=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt; See the Pen zYBRgGR by KaiYun Cheng (@kaiyuncheng) on CodePen. 密碼為3345678 Day13函式+if 判斷以下為 BMI 計算方式： BMI 計算為：體重(公斤) / 身高的平方(單位為公尺) 例如 150 公分 50 kg = 50/(1.5*1.5) = 22.2 BMI 指數 BMI 數值狀態如下 體重過輕：BMI ＜ 18.5 正常：18.5≦BMI＜24 過重：24≦BMI＜27 輕度肥胖：27≦BMI＜30 中度肥胖：30≦BMI＜35 重度肥胖：BMI≧35 目前現況小杰打開 Code 才發現，裡面的 if 判斷根本都在亂寫，請依照上面的 BMI 狀態來改寫，並還小杰一個清白。 請修改此 Codepen 解題 1234567891011121314151617function calculationBMI(height,kg){ let bmi = kg/(height/100*height/100); if(bmi &gt;= 35){ return &quot;重度肥胖&quot;; }else if(bmi &gt;= 30){ return &quot;中度肥胖&quot;; }else if(bmi &gt;= 27){ return &quot;輕度肥胖&quot;; }else if(bmi &gt;= 24){ return &quot;過重&quot;; }else if(bmi &gt;=18.5){ return &quot;正常&quot;; }else{ return &quot;體重過輕&quot;; };};console.log(calculationBMI(178,70)); Day14監聽與函式設計小杰打開網頁後，發現工讀生只把 HTML 標籤寫好，JS 完全沒寫，因為 HTML 面板已經壞掉了，請直接修改 JS Code，讓 .total 的顯示數值，可以正常運作。 BMI 2.0版 Codepen 網址 提示 利用 原生 的 function 觀念寫一個 BMI 計算機 See the Pen QWEmgaL by KaiYun Cheng (@kaiyuncheng) on CodePen. Day15物件運用 - 資料與渲染分離以下是護理師改寫小杰的邏輯，程式碼連結 護理師拿了之前工讀生的 Code 改寫，根本沒用小杰的。但可以看得出來，這個 Code 有刻意遺留了些不完整的地方，像是 bmiData 的物件沒有將條件寫完整，頗有想要再次考驗小杰的味道。 請各位將你們的 Code 跟護理師的進行比較，看看差異在哪裡，並透過 Slack 分享自己吸收的結果，並試著依照自己的邏輯寫一遍。 這次 HTML 面板壞掉了，你唯一可以改的面板只有 CSS 與 JS 面板。 主要運用 關注點分離：資料與畫面 See the Pen MWeVEgB by KaiYun Cheng (@kaiyuncheng) on CodePen. Day16物件運用 - forEach 與 HTML 字串累加問題小杰一時間還不知道怎麼寫，所以先寫了陣列 + forEach 的方式來累加 HTML 字串，再來顯示介面出來。範例程式碼 請你依照這邏輯，試著改寫物件格式，呈現的格式如下程式碼。 設計好物件後，依序 push 五筆資料到陣列裡，最後整理完字串資料，再 innerHTML 到 ul 裡。 這次 HTML 與 CSS 面板都壞了，請改寫 JS 面板。 PS:請拿上面的 Codepen 改寫即可，不需拿前幾關的 code 來整合 1234&lt;ul&gt; &lt;li&gt;小杰的身高為 178 公分，體重是 70 公斤，BMI 數據為 20，狀態為正常&lt;/li&gt; &lt;li&gt;小美的身高為 150 公分，體重是 200 公斤，BMI 數據為 38，狀態為超重&lt;/li&gt;&lt;/ul&gt; See the Pen LYZdddO by KaiYun Cheng (@kaiyuncheng) on CodePen. Day17物件運用 - innerHTML+forEach問題明明陣列裡面有五筆資料，但寫出來的程式碼，列表永遠只顯示一筆資料，究竟小杰哪裡觀念有問題呢？一起來幫助小杰吧~ 問題回覆請思考並在 Slack 回覆： str 放 forEach 外頭跟裡面的差異A: forEach會讓data裡的物件都跑一次，str=’’放在裡面會表示每跑一次item，str就又變成空字串。 innerHTML 放 forEach 外頭跟裡面的差異A: innerHTML放外頭，就只會跑一次，若在forEach後，直接呈現最後總合的str和放在裡面多次覆蓋後結果相同。 innerHTML 當要寫內容進去時，會不會將裡面內容給覆蓋掉？A: 會 Day18物件運用 - 字串相加 innerHTML+ 樣式搭配問題挑戰者們不要忘了，JS 始終要搭配妳寫好的 CSS 來進行渲染，護理師好像已經看膩了小杰爛到不行的陽春版本，寫了一個 .list2 版本，請依照他的 CSS 樣式邏輯，將 data 陣列裡面的資料，依序渲染到 .list2 裡面的 li 來顯示。 護理師的 Codepen 網址 See the Pen pobLVjN by KaiYun Cheng (@kaiyuncheng) on CodePen. Day19驗收前夕問題小杰打開師傅的程式碼，才發現這程式碼其實是來自於 Vic 這位工程師的範例程式碼。 雖然跟設計稿有非常大的差異，但從程式邏輯中，慢慢掌握到了一些概念。 請解讀 Vic 的(程式碼)，並在 Slack 上回報他以下邏輯是做了什麼事情： arrayBMIrecord 的陣列用途是什麼？A: 儲存每次計算出bmi的資料記錄 請描述 calculateBMI 函式做了什麼事情A: 取得身高體重的值轉成數字，用來計算bmi，判斷屬於過重或是正常等值，並記錄到userRecord變數上，最後把userRecord記錄到arrayBMIrecord 的陣列裡後，執行render，清空輸入值。 請描述 render 函式做了什麼事情A: 處理畫面的渲染，把arrayBMIrecord陣列裡的每筆資料取出，並記錄到str上，並渲染到畫面上。 Day20BMI 計算機團戰關卡Day21BMI 追加功能Day22BMI 陣列調整這三天都是在做BMI計算機因此寫在一起。第20天是完成BMI計算機的切版畫面與JS的程式，第21天是追加幾筆紀錄與平均功能，第22天是做陣列反轉reverse和unshift。 畫面上我自行做了桌機上兩欄手機畫面一欄的設計，右側欄為紀錄區可以向下捲動，紀錄上同時有時間標記與不同BMI呈現不同顏色。 DEMO Day23資料格式處理，陣列 unshift問題小杰一看到題目整個傻眼，裡面用了他從來沒看過的圖表資料，好在老闆在程式碼裡面寫了些註解，讓小杰知道自己不需要懂圖表框架，好好的把資料處理好後，圖表自然就會顯示正常，一起來幫幫小杰吧！ 以下是預期希望出現正常的圖表，請改寫PS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板 See the Pen GRqdGJp by KaiYun Cheng (@kaiyuncheng) on CodePen. Day24資料格式處理，forEach + 陣列處理(一)問題以下是預期希望出現正常的圖表，請改寫：PS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板 See the Pen MWeGBwR by KaiYun Cheng (@kaiyuncheng) on CodePen. Day25資料格式處理，forEach + 陣列處理(二)問題以下是預期希望出現正常的圖表，請改寫PS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板 See the Pen KKMRBMJ by KaiYun Cheng (@kaiyuncheng) on CodePen. Day25-2OpenData資料處理這是練習整理OpenData資料，並篩選要的資訊呈現於畫面上，這次選擇新北市政府資料開放平臺上的動物之家資料來做整理，篩選出新店區的地址。 See the Pen 新北市公立動物之家Json by KaiYun Cheng (@kaiyuncheng) on CodePen. Day26AJAX、axios 題目問題試著撈他提供的這隻 API，撈出所有的姓名列表，至少先做個雛形讓客戶安心。範例如下圖。 See the Pen rNLvPav by KaiYun Cheng (@kaiyuncheng) on CodePen. Day26-2AJAX、axios 全台展覽資訊站同樣運用axios的方式撈資料，這次我選擇文化部的展覽資訊這個api，簡單設計和製作了卡片式畫面，並加上了過濾縣市的功能。 DEMO Day27陣列補充觀念問題請從以下連結，學習 2~3 種陣列的處理方式，聽說 sort 就蠻常見的，並回報自己的範例程式碼與學到的東西。 Cheatsheet for Array Methods - JavaScript 陣列方法大全 JavaScript Array 陣列操作方法大全 ( 含 ES6 ) JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()] 這邊練習了copyWithin() : 有點像是複製貼上取代的概念，貼上會取代掉原本位置的元素參數1(必填)：從第幾個開始貼上取代參數2(選填 預設0)：從第幾個開始複製參數3(選填 預設陣列長度)：複製到第幾個前（不包含這一個） 1234567let ary = [1, 2, 3, 4, 5];ary.copyWithin(1);console.log(ary); //[1, 1, 2, 3, 4] 5 超過陣列長度，所以不會出現ary.copyWithin(2, 1, 3);console.log(ary); //[1, 2, 2, 3, 5] 複製2,3 從索引2也就是3的位置開始取代 Day28陣列排序進度這次客戶希望他們的內容可以做完課率排名功能，試著撈客戶提供的這隻 API，撈出資料後，依照每個物件的 process 來進行進度排序，範例格式如下圖。 1234&lt;ul&gt; &lt;li&gt;第 1 名是廖洧杰，他的特訓班完成度是 33%&lt;/li&gt; &lt;li&gt;第 2 名是王小明，他的特訓班完成度是 30%&lt;/li&gt;&lt;/ul&gt; See the Pen WNxKdMV by KaiYun Cheng (@kaiyuncheng) on CodePen. Day29監聽切換排序功能問題禿頭俠又提到，客戶希望能夠針對 select 切換排序方式，還請依照以下 範例來設計。 12345678910111213141516&lt;select&gt; &lt;option value=&quot;id&quot;&gt;依照 id 編號排序(由1開始從上往下)&lt;/option&gt; &lt;option value=&quot;process&quot;&gt;依照完課率排序(由最高到最低)&lt;/option&gt;&lt;/select&gt;// 以下為編號排序範例&lt;ul class=&quot;list&quot;&gt; &lt;li&gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %&lt;/li&gt; &lt;li&gt;編號 ID 2 為王小明，他的完成進度為 33 %&lt;/li&gt;&lt;/ul&gt;// 以下為完課率排序範例&lt;ul class=&quot;list&quot;&gt; &lt;li&gt;編號 ID 2 為王小明，他的完成進度為 33 %&lt;/li&gt; &lt;li&gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %&lt;/li&gt;&lt;/ul&gt; See the Pen WNxKdMV by KaiYun Cheng (@kaiyuncheng) on CodePen. 文件資源 [JS] 事件筆記（上） jQuery 筆記 - 讓網頁回到最頂點寫法 js取float型小數點後兩位數的方法 DOM Event 觸發事件 change - 表單內容更動內容時觸發 | Saffran’s Blog Day30C3.js 圖表整合這次的題目是希望用長條圖呈現完課率 長條圖C3.js 圖表整合文件 問題 這次的需求是「 用 c3.js 圖表顯示，看看誰的完課率最好，同時可以看出排名** 圖表不局限於上面的長條圖，也可尋找合適的圖 這邊我以長條圖方式呈現，把api回傳的資料， 用forEach依選擇的排列方式，把名字和完課率依序傳入到各自的新陣列，再把完課率陣列綁定到c3js圖表的data.columns裡，而名字綁定到x軸的categories上，畫面便可呈現。 See the Pen C3j 長條圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day31部落格文章閱讀這裡我推薦近期很常看的blogTimCodingBlog馬格蕾特的樹洞 Day32程式整合篇把Day29和Day30的兩個呈現方式合併 See the Pen C3j 長條圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day33圓餅圖分析問題客戶說，他在 C3.js 看到這個圓餅圖圖表，他想要我們透過 API 來觀察，尚未開賽跟已開賽的比例佔多少，一起來幫幫小杰吧！ See the Pen 圓餅圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day34圓餅圖分析(中文字串判別)問題客戶說，他想要觀察每個參賽者的「姓名長度的字元數」，規則如下： 如何判斷字元數量，請將你找到的部落格文章放到此處提供給其他勇者參考 判斷中英文字元長度 正規表示式除字串中所有標點符號 如果中文取代 **,注意正規表示 * 要刪掉避免錯誤 正則表達式的規則 - 這邊只要注意特殊字符有哪些即可 正則表達式介紹 使用 String.prototype.charCodeAt() 判斷字元是中文或英文 - 判斷字元是否超過 255 超過即代表為中文(缺點為需要把字元一個一個拆開) replace() 方法 - 講解 replace() 的用法 正則匹配範例 See the Pen 姓名長度的字元數 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day35圓餅圖與長條圖合併使用問題客戶想優化完課率的圖表設計，他想要同時顯示長條圖與圓餅圖，並顯示各區間完課率人數，小杰花了很多時間將圖表整合起來了，範例連結，但他卻不知道怎麼把 API 資料放進去，一起幫幫小杰吧！ See the Pen MWezvqd by KaiYun Cheng (@kaiyuncheng) on CodePen.","link":"/2020/10/28/js60Day11toDay35/"},{"title":"[JS] 陣列方法筆記起來","text":"前言學習Javascript到應用時，最常使用的就是陣列方法來處理資料，因此多知道一個方法但不需要死背用法來的更重要。這篇也會持續更新學到的方法。 另外整理這篇的契機是在學習過程中，看了偷米騎巴哥的影片和整理圖，十分喜歡，也讓觀念更加清晰。 出處連結在此 偷米騎巴哥-操作JS陣列的20種方式 另外也很喜歡OxxoStudio這個整理過後的大全分類，借鑒了OxxoStudio的分類整理以自己理解的觀念。 JavaScript Array 陣列操作方法大全 ( 含 ES6 ) 還有其他實用的方法 Cheatsheet for Array Methods - JavaScript 陣列方法大全 JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()] 陣列方法小筆記1. 會改變原本陣列的內容&gt; 陣列增減,複製取代push() ：加入到最後 — unshift() ：加入到最前pop() ：把最後一個去除 — shift() ：把最前一個去除splice()splice()中包含三個參數：參數1(必填)：從第幾個開始刪除或新增參數2(選填)：要刪掉幾個，0或負值則不刪除，不填時 參數1 後所有項目都刪除。參數3(選填)：新增的項目，可以是好幾個值 123let ary = [1, 2, 3, 4, 5];ary.splice(1, 0, 1000, 2000, 3000);console.log(ary); //[1, 1000, 2000, 3000, 2, 3, 4, 5] copyWithin()有點像是複製貼上取代的概念，貼上會取代掉原本位置的元素參數1(必填)：從第幾個開始貼上取代參數2(選填 預設0)：從第幾個開始複製參數3(選填 預設陣列長度)：複製到第幾個前（不包含這一個） 1234567let ary = [1, 2, 3, 4, 5];ary.copyWithin(1);console.log(ary); //[1, 1, 2, 3, 4] 5 超過陣列長度，所以不會出現ary.copyWithin(2, 1, 3);console.log(ary); //[1, 2, 2, 3, 5] 複製2,3 從索引2也就是3的位置開始取代 fill()把陣列中所有元素，換成指定的值參數1(必填)：指定的值參數2(選填 預設0 全部置換)：從第幾個開始換參數3(選填 預設陣列長度)：換到第幾個前（不包含這一個） 1234567let ary = [1, 2, 3, 4, 5];ary.fill('cool', 1);console.log(ary); // [1, 'cool', 'cool', 'cool', 'cool']ary.fill('cool', 1, 3);console.log(ary); // [1, 'cool', 'cool', 4, 5] &gt; 陣列排序reverse() ：反轉陣列排序sort() ：會將元素轉換成 字串 來排序，預設排序為unicode 從 a 排到 z , 從 小 排到 大，若有十位數以上數字則會產生排序問題，因此需要用以下方法來解決。 12345678910111213let ary = [100, 1, 4, 50];ary.sort((a,b) =&gt; b - a);console.log(ary); // [100, 50, 4, 1] 倒序ary.sort((a,b) =&gt; a - b);console.log(ary); // [1, 4, 50, 100] 正序ary.sort((a,b) =&gt; a &gt; b ? -1 : 1); console.log(ary); // [100, 50, 4, 1] 倒序ary.sort((a,b) =&gt; a &gt; b ? 1 : -1); console.log(ary); // [1, 4, 50, 100] 正序 2. 回傳陣列元素資訊或索引值(取得陣列而不會改變原始陣列) &gt; 回傳陣列元素資訊.length ： 回傳陣列的長度(元素的數量)&gt; 回傳陣列索引值indexOf()由左到右判斷是否有 參數1 的值，如果有回傳這個值的索引值，如果沒有回傳 -1參數1(必填)：要判斷的值參數2(選填 預設0)：從第幾個開始判斷 lastIndexOf()由右到左判斷是否有 參數1 的值，如果有回傳這個值的索引值，如果沒有回傳 -1參數1(必填)：要判斷的值參數2(選填 預設為最後一個)：從第幾個開始判斷 12345678let ary = [1, 2, 3, 4, 5];console.log(ary.indexOf(3)); // 2console.log(ary.indexOf(6)); // -1console.log(ary.indexOf(2, 3)); // -1console.log(ary.lastIndexOf(5)); // 4console.log(ary.lastIndexOf(2, 3)); // 1console.log(ary.lastIndexOf(5, 3)); // -1 findIndex()會將陣列中的 每一個 元素帶入函式判斷，並會回傳 第一個 符合判斷條件元素的索引值，如果沒有元素符合則會回傳 -1 &gt; 回傳陣列元素值find()會將陣列中的 每一個 元素帶入函式判斷，並會回傳 第一個 符合判斷條件的元素，如果沒有元素符合則會回傳 undefined 1234567let ary = [1, 2, 3, 4, 5];console.log(ary.findIndex(num =&gt; num &gt; 2)); // 2(索引值)console.log(ary.findIndex(num =&gt; num &lt; 0)); // -1console.log(ary.find(num =&gt; num &gt; 2)); // 3console.log(ary.find(num =&gt; num &lt; 0)); // undefined &gt; 回傳一個新字串join()可帶入值取代原有陣列的逗號區隔，回傳成字串，未帶入則用逗號隔開 123456let aryA = [1, 2, 3, 4, 5];let b = aryA.join('@');console.log(b); // '1@2@3@4@5' 字串let b = aryA.join('');console.log(b); // '12345' toString()可以把整個陣列轉換成字串 123let ary = [1, 2, 3, 4, 5];let b = ary.toString();console.log(b); // 1,2,3,4,5 字串 &gt; 回傳一個新數值reduce()將陣列中每一個元素進行計算，結果再與下個元素計算，回傳計算結果。較常見於計算加總。裡頭有一個函式 (必填) 和 一個初始計算數值 (選填)函式中可帶入4個參數參數1(必填)：計算的值參數2(必填)：該元素的值參數3(選填)：元素的索引值參數4(選填)：原本的陣列 123456let aryA = [1, 2, 3, 4, 5];let b = aryA.reduce((total, num) =&gt; total + num); console.log(b); // 15 = 1+2+3+4+5let b = aryA.reduce(((total, num) =&gt; total + num), 10); console.log(b); // 25 = 1+2+3+4+5+10 reduceRight()和reduce類似，差別在計算方式是由右到左，加法不影響，減法則會有差別 123456let aryA = [1, 2, 3, 4, 5];let b = aryA.reduce((total, num) =&gt; total - num); console.log(b); // -13 = 1-2-3-4-5let b = aryA.reduceRight(((total, num) =&gt; total - num)); console.log(b); // -5 = 5-4-3-2-1 &gt; 回傳一個新陣列filter()會將陣列中的 每一個 元素帶入指定的函式內做判斷，並會回傳符合判斷條件的元素組成一個新陣列 123let aryA = [1, 2, 3, 4, 5];let aryB = aryA.filter(num =&gt; num % 2 == 1);console.log(aryB); // [1, 3, 5] 餘1為奇數 slice()與字串.slice()用法差不多，擷取某段回傳出新陣列參數1(必填)：從第幾個開始擷取參數2(選填 預設為最後一個)：擷取到第幾個前（不包含這一個） 123456let aryA = [1, 2, 3, 4, 5];let aryB = aryA.slice(1);console.log(aryB); // [2, 3, 4, 5] let aryB = aryA.slice(1, 3);console.log(aryB); // [2, 3] concat() ：將兩個陣列串接為一個陣列…ES6語法 擴展運算符… 有相同功能 1234567let aryA = [1, 2, 3, 4, 5];let aryB = ['a', 'b', 'c'];let aryC = aryA.concat(aryB); //陣列A後串接Bconsole.log(aryC); // [1, 2, 3, 4, 5, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]let aryC = [...aryA, ...aryB] //使用...console.log(aryC); // [1, 2, 3, 4, 5, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 展開運算符(spread operator)…運用在陣列與物件 123456let aryA = [1,2,3];let aryB = [0, ...aryA, 4]; // [0,1,2,3,4] let objA = { a: 1, b: 2 };let objB = { ...objA, c: 3 }; // { a:1, b:2, c:3 }let objC= { ...objA, a: 3 }; // { a:3, b:2 } 剩餘操作符(rest operator)是解構的一種，意思就是把剩餘的東西放到一個array裏面賦值給它。 12345678910111213141516171819202122let aryA = [1,2,3];let [aryB, ...aryC] = aryA;console.log(aryB); // 1console.log(aryC); // [2,3] 如果陣列長度不夠解構 aryC為空陣列[]let ary = [1,2];let [a, ...[b,c]] = ary;console.log(a, b, c); //1 2 undefined//函式帶入的情況function test(a, ...rest){ console.log(a); // 1 console.log(rest); // [2,3]}test(1,2,3);//物件用法let obj = { name: 'Peter', age: 30, city: 'Taipei'};const {name, ...rest} = obj;console.log(name); // 'Peter'console.log(rest); // {age: 30, city: 'Taipei'} Array.of()可以把數字、字串轉換成陣列 12let ary = Array.of(1, 2, 3, 'a', ['b']);console.log(ary); // [1, 2, 3, &quot;a&quot;, [&quot;b&quot;]] Array.from()可將(「類陣列物件」：具有length屬性和索引值) 或是(「可迭代的物件」：可利用迭代的方式取得本身的元素eg: Map和Set等) 轉換成陣列，有兩個參數參數1(必填)：「類陣列物件」或是「可迭代的物件」參數2(選填)：改變轉換陣列的函式 1234567let a = '12345';let b = Array.from(a);console.log(b); // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]let b = Array.from(a, item =&gt; 0 + item );console.log(b); // [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;] 「類陣列物件」：需具有length屬性和索引值 12345678910let obj = { '0': 1, '2': 3, '1': 2, '4': 5, '3': 4, length: 5};let ary = Array.from(obj);console.log(ary); // [1, 2, 3, 4, 5] flat()可以把多層陣列平面化，一個參數(選填 預設1)為平面化幾層，設定Infinity可以直接全面平面化，回傳成新陣列 1234567let aryA = [1, 2, [[3]], [[[4], 5]]];let aryB = aryA.flat(); let aryC = aryA.flat(2); let aryD = aryA.flat(Infinity); console.log(aryB); // [1, 2, [3], [[4], 5]] console.log(aryC); // [1, 2, 3, [4], 5] console.log(aryD); // [1, 2, 3, 4, 5] flatMap()map() + flat() 帶入函式後傳出的值再平面化 123let aryA = [1, 2, [[3]], [[[4], 5]]];let aryB = aryA.flatMap(item =&gt; item + 10); console.log(aryB); // [11, 12, &quot;310&quot;, &quot;4,510&quot;] map()與 forEach 非常類似，但是 map 會 return 一個值，並會產生一個新陣列裡頭有一個函式 (必填) 和 一個callback函式裡的 this 參數 (選填)函式中可帶入3個參數參數1(必填)：每個元素帶入的變數參數2(選填)：該元素的索引值參數3(選填)：原本的陣列 123456789101112131415161718let aryA = [1, 2, 3, 4, 5];let aryB = aryA.map((item, index) =&gt; { return `${index + 1}:${item &gt; 2}`}); console.log(aryB); // [&quot;1:false&quot;, &quot;2:false&quot;, &quot;3:true&quot;, &quot;4:true&quot;, &quot;5:true&quot;]aryA.map((item, index, ary) =&gt; { return ary[index] = item * 10;}); console.log(aryA); // [10, 20, 30, 40, 50] 更改原陣列// 如果要使用callback函式裡 this 的參數，則「不能使用」箭頭函式，因為箭頭函式的 this 指向和函式的 this 指向不同，所以要用一般的函式處理。let aryA = [1,2,3,4,5];let aryB = aryA.map(function(item){ return item + this; // 此處的 this 為 10}, 10);console.log(aryB); // [11, 12, 13, 14, 15] 3. 針對每個元素處理，不用returnforEach()會將陣列中的 每一個 元素帶入指定的函式內做運算，裡頭有一個函式 (必填) 和 一個callback函式裡的 this 參數 (選填)函式中可帶入3個參數參數1(必填)：每個元素帶入的變數參數2(選填)：該元素的索引值參數3(選填)：原本的陣列 forEach() 無法用 break 中斷，如果想要中斷執行的話要使用傳統的 for 迴圈。 1234let ary = [1, 2, 3, 4, 5];let total = 0;ary.forEach(item =&gt; total += item);console.log(total); // 15 可更改原始陣列 12345let ary = [1, 2, 3, 4, 5];ary.forEach((item, index, ary) =&gt; { ary[index] = item * 10;});console.log(ary); // [10,20,30,40,50] MDN forEach()文件 4. 判斷並回傳布林值Array.isArray()判斷一個物件是否為陣列，如果是就回傳 true，不然就回傳 false。 12345let ary = [1, 2, 3, 4, 5];let obj = {a:1, b:2, c:3};console.log(Array.isArray(ary)); // trueconsole.log(Array.isArray(obj)); // false every()會將陣列中的 每一個 元素帶入指定的函式內做判斷，全部符合條件回傳 true，其中一個元素條件不符合，便回傳false。 123let ary = [1, 2, 3, 4, 5];console.log(ary.every(item =&gt; item &gt; 4)); // falseconsole.log(ary.every(item =&gt; item &gt; 0)); // true some()會將陣列中的 每一個 元素帶入指定的函式內做判斷，其中一個元素符合條件回傳 true，全部不符合，便回傳false。 123let ary = [1, 2, 3, 4, 5];console.log(ary.some(item =&gt; item &gt; 4)); // trueconsole.log(ary.some(item =&gt; item &lt; 0)); // false includes()判斷陣列中是否包含某個值，如果有包含就回傳 true，不然就回傳 false參數1(必填)：要判斷的值參數2(選填)：從第幾個開始判斷 123let ary = [1, 2, 3, 4, 5];console.log(ary.includes(2)); // trueconsole.log(ary.includes(2,3)); // false 5. 其他&gt; 回傳陣列值valueOf()回傳原本陣列的值，但如果原本陣列有修改，那麼回傳後的陣列值也會跟著改變，類似傳參考的概念。 12345let aryA = [1, 2, 3, 4, 5];let aryB = aryA.valueOf();aryB[0] = 'a';console.log(aryA); // [&quot;a&quot;, 2, 3, 4, 5]console.log(aryB); // [&quot;a&quot;, 2, 3, 4, 5] &gt; 回傳一個的Array Iterator物件keys()回傳陣列中的每一個索引值 key 成為一個新的 Array Iterator 陣列迭代器物件因為是 Array Iterator 物件，可以透過 Array.from, for…of來取得。 12345678910111213let a = ['a','b','c','d','e'];let b = a.keys(); // Array Iteratorlet c = Array.from(b);console.log(c); // [0, 1, 2, 3, 4]let a = ['a','b','c','d','e'];let b = a.keys();let d = [];for (let key of b) { d.push(key); }console.log(d); // [0, 1, 2, 3, 4] 延伸閱讀 for…of [筆記] JavaScript ES6 中的 for … of 迭代器 values()回傳陣列中的每一個元素值 成為一個新的 Array Iterator 陣列迭代器物件 12345let a = ['a','b','c','d','e'];let b = a.values(); // Array Iteratorfor (let value of b) { console.log(value); } //依序出現 a b c d e entries()回傳陣列中的每一個索引值 key 與對應元素 成為一個新的 Array Iterator 陣列迭代器物件 fromEntries()可把Array Iterator 陣列迭代器物件轉成物件Object 12345678910111213let a = ['a','b','c','d','e'];let b = a.entries(); // Array Iteratorlet c = [];for (let [key, value] of b) { c.push(`${key}${value}`); }console.log(c); // [&quot;0a&quot;, &quot;1b&quot;, &quot;2c&quot;, &quot;3d&quot;, &quot;4e&quot;]let a = ['a','b','c','d','e'];let b = a.entries();const e = Object.fromEntries(b);console.log(e); // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, 3: &quot;d&quot;, 4: &quot;e&quot;}","link":"/2020/11/03/jsArrayMethod/"},{"title":"[JS] 用C3.js來繪製圖表","text":"前言c3.js是一個免費開源的圖表套件，源自d3.js(操控SVG向量圖形進行資料視覺化的JavaScript程式庫)，類似的套件還有ChartJS C3.js 圖表整合文件 起手式js必須載入兩支d3.js和c3.js 123456&lt;!-- Load c3.css --&gt;&lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.18/c3.css&quot;&gt;&lt;!-- Load d3.js and c3.js --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.18/c3.js&quot;&gt;&lt;/script&gt; 在要建立圖表的地方插入，id可更改。 1&lt;div id=&quot;chart&quot;&gt;&lt;/div&gt; 接著初始化圖表，bindto設定對應的id名稱，就可以看到圖表畫面，接下來還有 123456789var chart = c3.generate({ bindto: '#chart', data: { columns: [ ['data1', 30, 200, 100, 400, 150, 250], ['data2', 50, 20, 10, 40, 15, 25] ] }}); 起手式 線圖 DEMO See the Pen C3.js 起手式 by KaiYun Cheng (@kaiyuncheng) on CodePen. C3.js的各式圖表example Customize Chart這邊列舉了一些用法，官方文件中還有其他更詳細介紹搭配不同圖表，就不一一介紹了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var chart = c3.generate({ bindto: &quot;#chart&quot;, data: { columns: [ // 資料位置 [&quot;data1&quot;, 30, 200, 100, 400, 150, 250], [&quot;data2&quot;, 50, 20, 10, 40, 15, 25], [&quot;data3&quot;, 2000, 20, 10, 40, 15, 25] ], axes: { // 軸數增加第二個 data2: &quot;y2&quot; }, // 圖型類型設定 types: { data2: &quot;bar&quot;, // 長條圖 data3: &quot;spline&quot; // 曲線圖 }, // 更改顏色設定 colors: { data1: &quot;#03A9F4&quot;, data2: &quot;#162F03&quot;, data3: &quot;#76FF03&quot; } }, axis: { rotated: false, //是否轉成橫向 x: { type: &quot;category&quot;, categories: [2000, 2001, 2002, 2003, 2004, 2005], // x軸單位內容 label: { text: &quot;X Label&quot;, // x軸設定顯示名稱 position: &quot;outer-left&quot; //擺放位置 } }, y: { label: { // y軸設定顯示名稱 text: &quot;Y Label&quot;, position: &quot;outer-bottom&quot; }, tick: { format: d3.format(&quot;$,&quot;) // 資料前增加$符號 } }, y2: { show: true, label: { text: &quot;Y2 Label&quot;, position: &quot;outer-middle&quot; } } }}); 另外也可在CSS上使用class名稱 c3-line-[id] 來修改畫面 123#chart .c3-line-data3 { stroke-width: 5px;} 客制設定 DEMO See the Pen C3.js Custom設定 by KaiYun Cheng (@kaiyuncheng) on CodePen. 長條圖 Bar Chart這邊會以長條圖為例把js60第29天的資料串接改成以長條圖方式呈現，把api回傳的資料， 用forEach依選擇的排列方式，把名字和完課率依序傳入到各自的新陣列，再把完課率陣列綁定到c3js圖表的data.columns裡，而名字綁定到x軸的categories上，畫面便可呈現。 See the Pen C3j 長條圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. 推薦延伸閱讀TimCodingBlog","link":"/2020/11/05/c3js/"},{"title":"[JS] 同步非同步霧煞煞(上)-AJAX","text":"前言接觸Js一段時間後，開始學習如何串接API，剛開始時就直接先被介紹用了Axios這個好用的套件，但原理等等還是不能理解，因此看了很多文章文件，才摸索到原來同步,非同步,Event Queue,Ajax,XMLHttpRequest,fetch,promise,Async,Await等等之間的關聯性，才把觀念串通。這篇會來把我所認知的概念整理起來。 同步Synchronous與非同步AsynchronousJavascript是單執行緒 (single threaded)、同步(Synchronous) 的程式語言，一次只能做一件事，但為何google上很多人都說Javascript是非同步呢？其實是使用setTimeout、AJAX、Promise等而有非同步的特性，但其實這些方法並不是由javascript程式語言本身提供的，不受單執行緒限制，他們會被放到Event Queue中。 我們目前常用的Javascript執行環境有瀏覽器和Node.js。在瀏覽器上透過document來操作DOM，document也不是程式語言本身提供，而是瀏覽器，因此click這個事件監聽也是非同步特性。在瀏覽器上其他方法還有做AJAX的 XMLHttpRequest, fetch, Promise，計時用的setTimeout和setInterval。執行環境用 &lt;script src=&quot;all.js&quot;&gt; 引入在html上。而在Node.js上則有http可做Ajax寫伺服器, os, fs來控制檔案介面，同時也有SetTimeout。執行方式安裝node.js用node all.js來執行。 以前大學的暑假，曾經在美國的麥當勞工作過，櫃檯工作的流程就很像是非同步的模式。覺得中文翻譯過來的非同步很容易讓人誤解成不能同步工作。同步應該要翻成只能一步一步做，上一步會阻礙下一步(blocking特性)，非同步則為可以分開做…不會阻礙下一步(non-blocking特性)，同步非同步這個字義讓一開始的我一直搞混。 同步synchronous模式 櫃檯小姐把你要的餐點輸入點餐機: 起司漢堡一個、薯條一份 櫃檯小姐把Order傳送給漢堡流水線去要漢堡 等待漢堡完成 漢堡製作好了，櫃檯小姐給你 櫃檯小姐把Order傳送給薯條台去要薯條 等待薯條完成 薯條製作好了，櫃檯小姐給你 結帳 非同步Asynchronous模式櫃檯小姐 (Call Stack) 櫃檯小姐把你要的餐點輸入點餐機: 起司漢堡一個、薯條一份 櫃檯小姐把Order傳送給漢堡流水線去要漢堡 (WebAPIs Request) 櫃檯小姐把Order傳送給薯條台去要薯條 (WebAPIs Request) 櫃檯小姐幫你結帳 收到薯條台通知，薯條炸好了 結帳完成 櫃檯小姐沒事了，出餐口機器手臂把薯條給櫃檯小姐後，放在給你的餐盤上 (callback function) 收到廚房通知說漢堡做好了 櫃檯小姐沒事了，出餐口機器手臂把漢堡給櫃檯小姐後，放在給你的餐盤上 (callback function) 出餐完成 –廚房端和出餐口(Event Queue) 廚房端 (WebAPIs) 漢堡流水線和薯條台接收到櫃檯小姐的Order 各自開始製作，漢堡流水線中有人去上廁所需要3分鐘才會開始製作(setTimeout 3分鐘) 各部門製作好後各自送到出餐口去(response)，製作失敗(error) 出餐口 (Callback Queue or Task Queue) 薯條製作好了，等待櫃檯小姐拿取，但他好像還在忙喔！ 出餐口機器手臂(Event Loop)偵測到櫃檯小姐結帳完了沒事(Call Stack空了)，把薯條給櫃檯小姐 漢堡製作好了，等待櫃檯小姐拿取 出餐口機器手臂(Event Loop)偵測到櫃檯小姐給完薯條了沒事(Call Stack空了)，把漢堡給櫃檯小姐 以下例子取自Tommy大的教學，非同步最常見的例子，setTimeOut設定為0秒但還是會被排到Event Queue中等待console.log(‘C’)執行完後才會再執行，因此會得到 A C B的結果。 12345678910console.log('A');function run() { console.log('B');}setTimeout(run, 0);console.log('C');// A C B 下面這個例子，setTimeOut設定為3秒，下方接一個5秒回圈後執行C，在5秒的過程中setTimeout在經過3秒後便開始在WebApis端執行並把結果放在Callback Queue中，等C一執行完成後Call Stack空了，EventLoop變馬上把Callback Function放入Stack中，B則馬上跳出。 123456789101112console.log('A');function run() { console.log('B');}setTimeout(run, 3000);var start = Date.now();while (Date.now() - start &lt;= 5000) {} // 讓迴圈重複一直跑，5 秒後才跳出執行下段console.log('c');// A 經過5秒後 C B AJAX (Asynchronous JavaScript and XML)直接翻譯過來就是 非同步的 JavaScript 與 XML 技術，可以即時向伺服器傳送(request)並取回必須的資料(response)，XML則是一種早期比較常在用的資料格式，現在比較多人使用的是JSON格式，不知道這樣AJAX要不要改成AJAJ…XD 伺服器request的底層方法: XMLHttpRequest HTML5 Fetch API 衍生的request的library套件: jQuery Ajax axios 以下兩個網站都可以用來製作測試用的 API，也可以客製化 AJAX 成功後的回傳訊息。 Mocky: Real HTTP mocking Mockable.io 這邊會用隨機用戶產生器來做練習 隨機用戶產生器 XMLHttpRequest (可支援 IE 7 以上)原生的JS，但缺點是寫法會比較難閱讀和複雜 XMLHttpRequest DEMO 非同步 GET 請求AJAX 行為會被丟到 Queue，等取得回應後才回到 JS 執行緒。 1234567891011121314var xhr = new XMLHttpRequest();const url = 'https://randomuser.me/api/';xhr.addEventListener('load', function(){ const data = JSON.parse(this.responseText); console.log(this.responseText); console.log(this.status); //拿到 Http status code 狀態碼}); //xhr.onload = function(){ … }xhr.addEventListener('error', function(error){ console.log('錯誤', error);});//xhr.onerror = function(){ … }xhr.open('GET', url, true); //預設非同步true 可不寫xhr.send(); DEMO 同步 GET 請求12345678910console.log('start');var xhr = new XMLHttpRequest();const url = 'https://randomuser.me/api/';xhr.open('GET', url, false); //非同步：falsexhr.send();console.log(xhr.responseText);console.log('end');// 'start'// responseText// 'end' DEMO 非同步 POST 請求123456789// 如何把參數發送到後端var data = new FormData(); // 宣告 FormData 物件data.append('id', '5'); // 在 FormData 中塞入資料var xhr = new XMLHttpRequest();xhr.addEventListener('load', function(){ console.log(this.responseText);})xhr.open('POST', url);xhr.send(data); // 把帶有資料的 FormData 傳送到後端 HTML5 Fetch API (IE 11 以下都不支援)MDN文件 ES6的新語法，搭配 Promise 作回應，支持 async/await.then()接續.catch()接收錯誤，回傳的是 ReadableStream 物件，需要使用不同資料類型(json,blob)使用對應方法，才能正確取得資料物件。 但使用上也有一些需要注意的： IE 11以下都不支援 回傳的 promise 不會 reject HTTP 的 error status，就算是 HTTP 404 或 500 也一樣。相反地，它會正常地 resolve，並把 ok status 設為 false。會讓它發生 reject 的只有網路錯誤或其他會中斷 request 的情況，需要封裝去處理。 預設是沒有帶cookie，需要新增配置項。 不支援超時控制，使用setTimeout及Promise.reject的實現的超時控制並不能阻止請求過程繼續在後臺執行，造成了量的浪費。 不支援原生監測請求的進度，而XHR可以 Fetch 常用的 Request 屬性url: 第一個參數，一定要填的項目，代表需要 fetch 對象的網址method: GET、POST、PUT、DELETE、HEAD ( 預設 GET )headers: 要求相關的 Headers 物件 ( 預設 {} )mode: cors、no-cors、same-origin、navigate ( 預設 cors )referrer: no-referrer、client 或某個網址 ( 預設 client )credentials: omit、same-origin、include ( 預設 omit )redirect: follow、error、manual ( 預設 manual )cache: default、no-store、reload、no-cache、force-cache ( 預設 default )body: 要加到要求中的內容 ( 如果 method 為 GET 或 HEAD 則不設定 ) Fetch 常用的 Response 屬性headers: 包含與 response 相關的 Headers 物件ok: 成功回傳 true，不成功回傳 falsestatus: 狀態代碼，成功為 200statusText: 狀態文字，成功為 oktype: response 的類型，例如 basic、cors…等url: response 的 url ReadableStream 物件Fetch API 的 回傳為 ReadableStream 物件，我們無法直接讀取資料內容，而 ReadableStream 物件中可用以下對應的方法來取得資料 (https://developer.mozilla.org/zh-TW/docs/Web/API/Body)： arrayBuffer() 返回 Promise，Buffer，代表一段記憶體區塊，僅能透過 View 操作其內容。formData() 返回 Promise，取得的資料格式將會是formData格式json() 返回 Promise，取得的資料格式將會是JSON格式text() 返回 Promise，取得的資料格式將會是純字串blob() 返回 Promise，可以將資料轉為blob物件，像是圖片就可以做這樣的轉換(這裡的圖片並非指圖片路徑，而是圖片檔案本身)。 clone() 建立 Response 的複製物件error() 返回 Response 的錯誤物件 123456789101112// unsplash 上的圖片let url = 'https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&amp;fit=crop&amp;w=634&amp;q=80'fetch(url) .then((response) =&gt; { return response.blob(); }) .then((imageBlob) =&gt; { let img = document.createElement('IMG') document.querySelector('.newImg').appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); }) Fetch DEMO 發送 GET 請求12345678910const url = 'https://randomuser.me/api/';fetch(url).then(response =&gt; { //預設method:get // 這裡會得到一個 ReadableStream 的物件 return response.json(); // 可以透過 blob(), json(), text() 轉成可用的資訊}).then(data =&gt; console.log(data);) // 取得資料.catch((err) =&gt; { console.log('錯誤:', err); Fetch DEMO 發送 POST 請求1234567891011// 把資料參數傳到後端，一樣要先宣告 FormDatavar data = new FormData();data.append('id', '5');fetch('url', { method: 'POST', body: data, }) // 如果是傳遞「中文」可能會出現亂碼，這時可以使用encodeURI來做轉碼，且要透過JSON.stringify來轉換成 string 方式傳遞。 encodeURI(JSON.stringify()).then(response =&gt; response.json();) // 解讀JSON格式.then(data =&gt; console.log(data)) // 取得資料 jQuery Ajax以XMLHttpRequest為基礎的library，使用簡單，但jQuery本身是針對MVC的程式設計，不符合現在前端MVVM的浪潮，因為現在有許多新的原生語法可取代JQuery，若單純只是使用Ajax卻引入整個jquery不太合理。 DEMO 發送 GET 請求123456789101112$.ajax({ type : &quot;GET&quot;, //預設get，如果要使用 POST 方法則換成POST url: 'https://randomuser.me/api/', dataType: 'json', success: function(data) { console.log(data); }, error : function(error){ console.log(error.status); console.log(error.responseText); }}); 12345$.ajax({ url: 'https://randomuser.me/api/'}).done(function(res){ console.log(res);}); axiosaxios 本質上也是對原生的 XMLHttpRequest 封裝，從 node.js 建立 http 請求，並可以支援 Promise，可取消請求(Promise無法)，自動轉換JSON檔，客戶端支援防止CSRF，提供了一些併發請求的介面，axios 實體建立 DEMO 發送 GET 請求12345678const url = 'https://randomuser.me/api/';axios.get('url').then(function (response) { console.log(response);}).catch(function (error) {console.log(error);}); DEMO 發送 POST 請求12345678const url = 'https://randomuser.me/api/';axios.post('url').then(function (response) { console.log(response);}).catch(function (error) {console.log(error);}); 執行多個併發請求12345678910function getData1() {return axios.get('url1');}function getData2() {return axios.get('url2');}axios.all([getData1(), getData2()]).then(axios.spread(function () {// 兩個請求現在都執行完成})); 參考資料 JavaScript Fetch API 使用教學 JavaScript 中的同步與非同步 麥克的半路出家筆記 一起來把煩人 XMLHttpRequest 變成 Fetch 怎麼樣？ 邁向 JavaScript 勇者之路 重新認識 JavaScript ES6 入門手冊(較於艱深)","link":"/2020/11/06/eventQueue/"},{"title":"[JS] 簡單認識正規表達式 Regular Expression","text":"前言這篇會來介紹正規表達式，第一次看到正規表達式時，只會想說這是什麼鬼…為何一小串就可以做完一般判斷式可能要寫好幾行的事。如果可以更深入了解活用的確可以在coding中幫助極大。因此這次我會藉由這篇讓我自己更釐清觀念。 介紹正規表達式(Regular Expression, RegEx)是被用來匹配字串中字元組合的模式。常搭配與這些字串方法(match、replace、search、split)來使用。 為什麼使用正則表達式？&gt; 用來測試字符串是否符合模式可以用於驗證，像是電話,Email,信用卡號碼是否輸入正確 &gt; 收尋匹配的字串&gt; 取代匹配到的字串&gt; 擷取出匹配到的字串正則表達式使用規則 簡易字元例如： /abc/ .replace(/abc/,’a’); 用’a’來取代匹配到的’abc’ strB 因為是abC的C為大寫，在/abc/後多加i則可以不管大小寫辨識到 strC 為ab c中有空白字元所以匹配不到 strD 在/abc/後多加g則可收尋到所有abc並且替換成a 123456789let strA = 'Hi, do you know abc?';let strB = 'The latest airplane designs evolved from slabCraft.';let strC = 'Grab crab';let strD = 'Hi abc, do you know abc?';let resultA = strA.replace(/abc/,'a'); // Hi, do you know a?let resultB = strB.replace(/abc/i,'a'); // The latest airplane designs evolved from slaraft.let resultC = strC.replace(/abc/,'a'); // ab c中有空白字元所以匹配不到let resultD = strD.replace(/abc/g,'a'); // Hi a, do you know a? 特殊字元例如： /ab*c/ *代表b可以是零或多個，所以abbbbbbc或是ac都可以匹配到 12let strA = 'Hi, do you know abbbbbbc ac abc bc?';let resultA = strA.replace(/ab*c/g,'a'); // Hi, do you know a a a bc? 圖片出處: 網頁研習室 圖片解說 字元 解說 &gt; 所有正規表示法規則都必須放到這兩者之間。 /^ 正規表示法的開始 /^A/則匹配A開頭的字元，例如Ant $/ 正規表示法的結束 /A$/則匹配A結束的字元，例如nbA [A-Z] [xyz] 字元的集合，等同於比對A到Z之間的任一大寫字母，例如[a-c]比對[abcd]這四個字母，[hcn]則比對h.c.n這三個字母 \\d [0-9] 代表比對數字格式，兩者一樣。例如/\\d/ 或 /[0-9]/ 在 “B2 is the number.” 中找到 ‘2’ {9} 樣式必須出現次數。例如/a{3}/ 無法在 “candy” 找到、但 “caaandy” 可以。[A-C]{2} 在A-C之間要符合兩次，”BA” “AC” “CA”…｜ 常用字元整理中介字元 (Meta Character) 字元 解說 /^ 正規表示法的開始 /^A/則匹配A開頭的字元，例如Ant $/ 正規表示法的結束 /A$/則匹配A結束的字元，例如nbA . 小數點 匹配任何單一字元，換行除外，例如/.n/ 匹配「nay, an apple is on the tree」中的 an 和 on，但在「nay」中沒有匹配。 字元 解說 (x) 比對x並將符合的部分存入一個變數中，例如’aaa bbb’.replace(/(…) (…)/, ‘$2 $1’)則會得到’bbb aaa’對調結果 (?:x) 比對x並將符合的部分 不存入變數中 x(?=y) 正向肯定預查，符合後面接 y 的 x x(?!y) 正向否定預查，符合後面不接 y 的 x (?&lt;=x)y 反向肯定預查，符合前面接 x 的 y (?&lt;!x)y 反向否定預查，符合後面不接 x 的 y 字元 解說 x|y x或者y [A-Z] [xyz] 字元的集合，等同於比對A到Z之間的任一大寫字母，例如[a-c]比對[abcd]這四個字母，[hcn]則比對h.c.n這三個字母 [^xyz] 則與上方相反，比對不在[]內的任一字元。例如[^ecm]比對welcome則會找到w.l.o 字元 等價 解說 \\d [0-9] 比對數字字元。例如/\\d/ 或 /[0-9]/ 在 “B2 is the number.” 中找到 ‘2’ \\D [^0-9] 比對非數字字元 \\w [A-Za-z0-9_] 比對數字字母與底線的所有字元 \\W [^A-Za-z0-9_] 比對不包含數字字母與底線的字元 \\b 比對字元的邊界，例如空格 /\\wB\\b/比對’aaaB mbbA’找到aB，/\\bmb/則找到第二行的’mb’ \\B 比對非字元邊界 \\s [ \\f\\n\\r\\t\\v] 比對任何空白字元 \\S [^ \\f\\n\\r\\t\\v] 比對任何非空白字元 \\f [\\x0c\\cL] 符合一個換頁符 \\n [\\x0a\\cJ] 符合一個換行符 \\r [\\x0d\\cM] 符合一個 Enter 符 \\t [\\x09\\cI] 符合一個制表符 \\v [\\x0b\\cK] 符合一個垂直制表符 \\ 反斜線為避開特殊字元，若要表現\\則須用兩個反斜線\\\\ \\cX 控制字元，X 為 A-Z。也就是 Ctrl + [A-Z] 的意思 量詞 (Quantifier)：限制符 指定匹配次數 字元 解說 * 樣式必須出現0次或多次(&gt;0)。例如：/a*/ + 樣式必須出現1次以上(&gt;1)。例如：/a+/ ? 樣式必須出現0或1次(0 or 1)，等同於 {0,1}，例如/a?b/可比對’Aab’的ab或是’Aa’的a * 如果同時使用 + ? 或 {}，將會變成儘可能匹配最少的字元。例如：在「123abc」中應用 /\\d+/ 可匹配「123」，但使用 /\\d+?/ 在相同字串上只能匹配「1」 {n} 樣式必須出現n次。例如/a{3}/ 無法在 “candy” 找到、但 “caaandy” 可以。[A-C]{2} 在A-C之間要符合兩次，”BA” “AC” “CA”…｜ {n,} 樣式至少符合出現n次。｜ {n,m} 樣式出現次數必須介於n到m之間(n~m) 常見用法 功能 正規式 只能輸入數字 /^[0-9]*$/ 只能輸入 n 位的數字 /^\\d{n}$/ 只能輸入至少 n 位的數字 /^\\d{n,}$/ 只能輸入 m~n 位的數字 /^\\d{m,n}$/ 只能輸入零和非零開頭的數字 /^(0|[1-9][0-9]*)$/ 只能輸入有兩位小數的正實數 /^[0-9]+(.[0-9]{2})?$/ 只能輸入有 1~3 位小數的正實數 /^[0-9]+(.[0-9]{1,3})?$/ 只能輸入非零的正整數 /^+?[1-9][0-9]*$/ 只能輸入非零的負整數 /^-[1-9][0-9]*$/ 只能輸入長度為 3 的字符 /^.{3}$/ 只能輸入由 26 個英文字母組成的字符串 /^[A-Za-z]+$/ 只能輸入由 26 個大寫英文字母組成的字符串 /^[A-Z]+$/ 只能輸入由 26 個小寫英文字母組成的字符串 /^[a-z]+$/ 只能輸入由數字和 26 個英文字母組成的字符串 /^[A-Za-z0-9]+$/ 只能輸入由數字、26 個英文字母或者下劃線組成的字符串 /^\\w+$/ 只能輸入漢字 /^[\\u4e00-\\u9fa5]{0,}$/ 驗證用戶密碼(以字母開頭，長度在 6~18 之間，只能包含字符、數字和下劃線) /^[a-zA-Z]\\w{5,17}$/ 驗證 Email 地址 /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$/ 驗證 InternetURL /^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$/ 驗證一年的 12 個月 /^(0?[1-9] 驗證一個月的 31 天 /^((0?[1-9]) 驗證電話號碼 /^((\\d{3,4}-) 驗證台灣身份證字號(1位大寫英文字母和首位數字1或2，共9位數字) /^[A-Z]{1}[1-2]{1}[0-9]{8}$/ 驗證台灣手機電話號碼(09開頭的10個數字) /^09[0-9]{8}$/ 驗證台灣電話號碼/^([-_－—\\s(]?)([(]?)((((0?)|((00)?))(((\\s){0,2})|([-_－—\\s]?)))|(([)]?)[+]?))(886)?([)]?)([-_－—\\s]?)([(]?)[0]?[1-9]{1}([-_－—\\s)]?)[1-9]{2}[-_－—]?[0-9]{3}[-_－—]?[0-9]{3}$/ 可以用來驗證以下號碼(02)3195693093695770209877997560989861389+886912345678+886 2 12345678 驗證用戶密碼長度在 6-18 之間，必須以英文字母開頭，其餘可使用英文字母、數字和下底線/^[a-zA-Z]\\w{5,17}$/ 長度在 6-15 之間，必須包含至少一個大和小寫英文字、一個數字和一個特殊符號/^(?=.[A-Z])(?=.[a-z])(?=.\\d)(?=.[~!@#$%^&amp;*()_+`-={}[]:”;’&lt;&gt;?,./]).{6,15}$/ 移除字串中所有標點符號12let str=”jfkldsjalk,.23@#!$$k~! @#$%^&amp;*()(_ -=|\\{}[]’;:,./&lt;&gt;??gg g~“`gf”; str = str.replace(/[\\ |\\~|\\`|\\!|\\@|\\#|\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\ |\\=|\\||\\\\|\\[|\\]|\\{|\\}|\\;|\\:|\\”|\\’|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?]/g,''); 判斷中英文字串的長度因為中文佔兩個字元，英文佔1個字元，單純用.length判斷度不對，可使用下方正規式先做字元轉換 123function getLength(str){ return str.replace(/[^\\x00-\\xff]/g,&quot;**&quot;).length;} 正規式測試用 Regex101 Javascript 常搭配正規式的字串方法.match()會回傳一個符合比對的陣列 123var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';var ary = str.match(/[A-E]/gi); //g比對回傳全部符合的 i不分大小寫console.log(ary); // ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e'] .replace()比對後取代 .replace(/abc/,’a’); 用’a’來取代匹配到的’abc’ strB 因為是abC的C為大寫，在/abc/後多加i則可以不管大小寫辨識到 strC 為ab c中有空白字元所以匹配不到 strD 在/abc/後多加g則可收尋到所有abc並且替換成a 123456789let strA = 'Hi, do you know abc?';let strB = 'The latest airplane designs evolved from slabCraft.';let strC = 'Grab crab';let strD = 'Hi abc, do you know abc?';let resultA = strA.replace(/abc/,'a'); // Hi, do you know a?let resultB = strB.replace(/abc/i,'a'); // The latest airplane designs evolved from slaraft.let resultC = strC.replace(/abc/,'a'); // ab c中有空白字元所以匹配不到let resultD = strD.replace(/abc/g,'a'); // Hi a, do you know a? .search()收尋與比對相符的字串後，回傳第一個字元的索引值，若沒有比對相符則回傳-1 123const str=&quot;Visit the World!&quot;;console.log(str.search(/world/i)); //10console.log(str.search(/a/i)); //-1 .split()比對符合的字元做為斷點來切割 123var myString = &quot;Hello 1 word. Sentence number 2.&quot;;var splits = myString.split(/(\\d)/); // 以數字為斷點切分成5段console.log(splits); // [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 參考資料 MDN文件 網頁研習室 判斷中英文字元長度 正規表示式除字串中所有標點符號 如果中文取代 **,注意正規表示 * 要刪掉避免錯誤 正則表達式的規則 - 這邊只要注意特殊字符有哪些即可 正則表達式介紹 使用 String.prototype.charCodeAt() 判斷字元是中文或英文 - 判斷字元是否超過 255 超過即代表為中文(缺點為需要把字元一個一個拆開) replace() 方法 - 講解 replace() 的用法 正則匹配範例","link":"/2020/11/10/regularExpression/"},{"title":"[JS 60 Days] Day 36 to Day 46 - ES6 Git window.location","text":"Introduction Day 36 - ES6 起步走 - Template String 樣板字串 Day 37 - let 與 const Day 38 - let 與 const 觀念複習 Day 39 - 箭頭函式(arrow function) Day 40 - ES6 團戰關卡 Day 41 - new Date() 時間處理 Day 42 - new Date() 與字串處理 Day 43 - GitHub Pages Day 44 - window.location Day 45 - window.location Day 46 - window.location Day36ES6 起步走 - Template String 樣板字串第36天的作業是改寫[第 20 關]的字串相加邏輯，以符合 ES6 寫法，因為當初寫時就已經是用樣板字面字的方式寫了，所以這次會來練習fetch，這兩篇是我的整理筆記同步非同步霧煞煞(上)-AJAX同步非同步霧煞煞(下)-Promise,Async,Await 如果你已經早就會 ES6 字串處理，請觀看以下文章，挑選一個你不會的技術觀念，並分享你學到了什麼 邁向 JavaScript 勇者之路 重新認識 JavaScript ES6 入門手冊(較於艱深) Day37let 與 const比較了這三個用法 var let constvar, let, const 差異比較 Day38let 與 const 觀念複習問題一請問下面會出現的 console 是？ 12console.log(a); // ReferenceError: a is not definedlet a = 10; 問題二以下是否會正常執行？若不會，會顯示什麼紅字錯誤？ 123let a = 1;a=3;//會正常執行，let可以重新賦值 123let b = 1;let b = 2;//會錯誤 不能重複宣告 123const c = 3;c=4//會錯誤 const不能重新賦值 問題三：此為熱門面試題目(選答)請問 var、let、const 的區別是？ 我整理了一篇比較文章var, let, const 差異比較 Day39箭頭函式(arrow function)arrow function 會如何影響到 this？我整理了一篇文章箭頭函式 Arrow Functions 和 this Day40ES6 團戰關卡請挑選20天或35天改為ES6寫法，若已經改寫，以下面試題目請挑選一題來解釋，並下方附上你的 HackMD 文章a. 請解釋什麼是 this？請寫範例解釋？箭頭函式 Arrow Functions 和 this b. 你對 promise、promise all 有多熟悉？請寫範例解釋？c. Fetch 與 XMLHttpRequest同步非同步霧煞煞(上)-AJAX同步非同步霧煞煞(下)-Promise,Async,Await d. 什麼是原型繼承(prototype)？ Day41new Date() 時間處理Day42new Date() 與字串處理Day43GitHub Pages問題請依照技術主管的指示，將網頁放在 GitHub Pages 上的服務 在本地端新增一個 index.html，裡面多加上一個 h1 的標籤，裡面寫自己 Slack 的暱稱 觀看此文件，讓自己的網頁上傳到 GitHub Pages 上 在下方列表，張貼自己的 GitHub Pages 網址 接下來我們將會持續用 GitHub Pages 更新網頁 我的github Day44window.locationDay45window.locationDay46window.location","link":"/2020/11/11/js60Day36toDay46/"},{"title":"[JS] 同步非同步霧煞煞(下)-Promise,Async,Await","text":"前言接續上一篇同步非同步霧煞煞(上)-AJAX，這篇會介紹Callback hell, promise, Async, Await Callback hell 回呼地獄上一篇提到有非同步特性方法像是Ajax, setTimeout等，當我們使用這些有非同步特性方法，但又希望可以按照我們想要的順序來執行時，一種解決方式是用callback function DEMOsetTimeout的延遲時間為隨機秒數，非同步的特性無法控制哪個setTimeout先執行，把setTimeout個別用 function包起來，且各個 function 都帶入一個 callback 參數。B為A的callback，C為B的，但是如果有太多函式要依序就會變成callback hell，導致程式碼過巢會很難閱讀。 123456789101112131415161718192021222324252627function funcA(check){ setTimeout(function(){ console.log('A'); check('A'); }, Math.random() * 1000);}function funcB(check){ setTimeout(function(){ console.log('B'); check('B'); }, Math.random() * 1000);}function funcC(check){ setTimeout(function(){ console.log('C'); check('C'); }, Math.random() * 1000);}funcA(function(){ funcB(function(){ funcC(function(){ }); });}); Promise早期也有另一個方式是generator，但很少人這樣做。而現在最多人使用的則是Promise來解決常見的非同步問題： Callback hell 寫法不一致(promise用.then來回呼) 無法同時執行無法同時執行(jQuery有並行寫法但不直覺) MDN文件 Promise 可能處於三種階段中任意階段：Pending：正在進行中，還不知道是完成或失敗Resolved（Fulfilled）：表示成功，回傳結果Rejected：表示失敗，回傳失敗原因 1234const newPromise = new Promise((resolve, reject) =&gt; { resolve(someValue); // 成功 reject('失敗原因'); // 失敗}); then()、catch()、finally()在function使用promise功能，return一個 promise 物件即可，then()接收成功，catch()接收失敗，finally()非同步執行完畢（無論是否正確完成）： 123456789101112131415161718192021function promiseFunction(timeout) { // console.log(1) 執行程序1 return new Promise((resolve, reject) =&gt; { // console.log(2) 執行程序2 setTimeout(() =&gt; { resolve('成功'); // console.log(4) 執行程序4 },timeout); if (timeout === 0){ reject('失敗'); // reject(new Error('失敗')) } });};promiseFunction(1000).then((response) =&gt;{ console.log('執行成功', response);}).catch((error)=&gt;{ console.log('執行失敗', error);});// console.log(3) 執行程序3 Promise Chain要串連執行多個 promise 功能的話，則用then()來連結，若其中一個沒成功則會跳到失敗。 12345678910111213promiseFunction(1000).then((response) =&gt;{ console.log('執行成功', response); return promiseFunction(2000);}).then((response) =&gt;{ console.log('執行成功2', response); return promiseFunction(3000);}).then((response) =&gt;{ console.log('執行成功3', response);}).catch((error)=&gt;{ console.log('執行失敗', error);}); 用promise解決上面callback hell的demo 123456789101112131415function promiseFunction(func) { return new Promise((resolve, reject) =&gt; { func(function(){ resolve(); }) });};promiseFunction(funcA).then(()=&gt;{ return promiseFunction(funcB);}).then(()=&gt;{ return promiseFunction(funcC);}).catch((error)=&gt;{ console.log('執行失敗', error);}); //若其中一個沒成功則會跳到失敗 Promise.all()如果funcA, funcB, funcC 的先後順序不重要，直到這三個函式都回覆成功或是其中一個跳失敗 才可以繼續後面行為，可以透過 Promise.all() 來做到： 1234Promise.all([promiseFunction(funcA), promiseFunction(funcB), promiseFunction(funcC)]) .then((response) =&gt;{ console.log(response); }); 適合需要多支 API 要一起執行，並確保全部完成後才進行其他工作時。 Promise.race()同時執行多支API，但僅會回傳最快回應的結果 1234Promise.race([promiseFunction(funcA), promiseFunction(funcB), promiseFunction(funcC)]) .then((response) =&gt;{ console.log(response); }); Async、Awaitasync await 是ES7的語法，搭配Promise來使用，寫法更精簡閱讀起來更簡單，像是在讀同步程式碼，兩者必須一起使用 使用 async function定義一個非同步函式，讓這個函式本體是屬於非同步，但其內部以“同步的方式運行非同步”程式碼。 123456789async function asyncFn() { return data}console.log(asyncFn());//可以得到與 Promise 結構相似的函式，該函式是以非同步的方式運行，無法直接使用 console.log 取得其值。asyncFn().then(r =&gt; { console.log(r)}); await可以暫停非同步函式的運行（中止 Promise 的運行），直到非同步進入 resolve 或 reject，當接收完回傳值後繼續非同步函式的運行。 12345678910111213function promiseFunction(func) { return new Promise((resolve, reject) =&gt; { func(function(){ resolve(); }) });};(async function () { await promiseFunction(funcA); await promiseFunction(funcB); await promiseFunction(funcC);})(); try…catch用try和catch來處理成功和失敗 123456789101112131415161718function promiseFunction(func) { return new Promise((resolve, reject) =&gt; { func(function(){ reject('失敗'); }) });};(async function () { try{ await promiseFunction(funcA); await promiseFunction(funcB); await promiseFunction(funcC); } catch(error){ console.log(error); }})(); 回傳不同錯誤訊息 1234567891011121314151617(async function () { try{ await promiseFunction(funcA); } catch(error){ console.log('A', error); } try{ await promiseFunction(funcB); } catch(error){ console.log('B', error); } try{ await promiseFunction(funcC); } catch(error){ console.log('C', error); }})(); 搭配 Promise.all()123456789(async function () { try{ const data = await Promise.all([promiseFunction(funcA), promiseFunction(funcB), promiseFunction(funcC)]); console.log(data); } catch(error){ console.log(error); }})(); Fetch搭配Async、Awaitfetch 也是基於 Promise 的 Web API，因此它也同樣能夠使用 async/await 來進行改寫，fetch 與一般 AJAX 套件比較不同之處是在 JSON 回傳後，必須在使用 json() 的方法將資料輸出成 JSON 格式（相關介紹可以參考：MDN Fetch）。 當使用 Promise then 時，則會使用 return 來呼叫 json() 方法（箭頭函式縮寫，所以省略了 return）， 1234567891011121314151617181920const url = 'https://randomuser.me/api/';fetch(url).then(response =&gt; response.json()).then(data =&gt; console.log(data)) .catch((err) =&gt; { console.log('錯誤:', err); //async 改寫const url = 'https://randomuser.me/api/';(async function(){ try{ const response = await fetch(url); const data = await response.json(); console.log(data); } catch(error){ console.log(error); }})();","link":"/2020/11/11/promise/"},{"title":"[JS] var, let, const 差異比較","text":"前言這篇會來整理宣告變數傳統的var和ES6新語法let, const的差異比較。 var傳統變數宣告，作用域(scope)為function，在function內宣告只有在function才有作用。如果在function外則為全域(global)。 1234function fn(){ var a = 'ABC';};console.log(a); // a is not defined 在一些區塊(block)，像是if..else、for、while的{大括號}使用var則容易會污染全域變數。 1234567function fn() { var a = 'AAA'; if (true) { var a = 'BBB'; } console.log(a); // 'BBB'} letlet的作用域(scope)為區塊(block)，區塊是指在{大括號}裡面，像是if..else、for、while的{}。另一個特性是禁止在同一層重複宣告(var 可以)，算是跟var類似但較嚴謹的用法。 下面這個例子，若使用var來宣告i，setTimeout 最後結果只會印出 ‘這執行第10次’。是因為用var將i宣告成全域變數，i透過回圈累加，當setTimeout執行時只會拿到最終i=10這個值，解決辦法則是用let宣告。 123456789101112131415161718192021222324for (var i = 0; i &lt; 10; i++) { console.log(i); setTimeout(function () { console.log('這執行第' + i + '次'); }, 10);} for (let i = 0; i &lt; 10; i++) { console.log(i); setTimeout(function () { console.log('這執行第' + i + '次'); }, 10);} //用let宣告i 則會只作用於{}內 並可列印出所有ｉ//若不用let 可用立即函式帶入i這個值到j變數上for (var i = 0; i &lt; 10; i++) { (function (j) { setTimeout(function () { console.log('這執行第' + j + '次'); }, 10); })(i);} var 在全域下的變數會在 window 上，可以在這裡使用 console.log() 看看兩者之間的差異： 123456// 這段宣告擇一執行var mom = &quot;老媽&quot;;let mom = &quot;老媽&quot;;console.log(window.mom);// var 會出現 &quot;老媽&quot;// let 會出現 undefined const與 let ㄧ樣，作用域(scope)為區塊(block)，區塊是指在{大括號}裡面，像是if..else、for、while的{}。不同的地方是const在宣告時必須賦予一個值，並且之後不能再更改。也無法再用 let或 var 重新宣告變數。 123const a ='AAA';const a ='BBB';// 會跳錯 Identifier 'a' has already been declared 參考資料 ES6 開始的新生活 let, const ECMAScript6 入門：var、let、const 差異 JavaScript: var, let, const 差異 JavaScript ES6 Block Scope - let, const Day26 var 與 ES6 let const 差異","link":"/2020/11/17/varLetConst/"},{"title":"[JS] 箭頭函式 Arrow Functions 和 this","text":"前言箭頭函式(Arrow Functions)是一個ES6的新語法，對我來說前前後後接觸js，一直有碰到this，但要詳細解釋還是很難，因此想藉由這篇讓我更加深this的觀念，會整理出this在箭頭函式的差別與其他this的觀念。另外感謝Kuro大的文章，讓我更容易了解this，分享連結在下面。 箭頭函式(Arrow Functions)箭頭函式(Arrow Functions)是一個ES6的新語法，與傳統function類似，有點像是傳統function更簡短寫法，但沒有 arguments 參數，this上也有差別。 1234567891011121314151617181920212223242526//傳統函式let helloName = function(name) { return `hello, ${name}`;}// 箭頭函式var helloName = (name) =&gt; { return `hello, ${name}`;}// 單一行陳述則可以不加 {}var helloName = (name) =&gt; `hello, ${name}`;// 只有一個參數則可以不加 ()var helloName = name =&gt; `hello, ${name}`;console.log(helloName('John'));// 沒有任何參數時則必須加 ()var helloName = () =&gt; `hello`;// 有{}時 必須加上return，否則沒有回傳功能var helloName = name =&gt; { `hello, ${name}`; // return `hello, ${name}`;} console.log(helloName('John')); //undefined 關於this傳統函式 this不等於functionthis是傳統函式function執行時，自動生成的一個內部物件。隨著執行呼叫場合的不同，所指向的值也會不同。 &gt; 預設綁定(Default Binding) this 指向全域物件當沒有特定指明 this 的情況下，預設綁定 (Default Binding) this 為 「全域物件」，也就是 window。 直接執行呼叫函式 Simple Call無論把function宣告在哪邊，只要是一般的Simple Call，this指向為 全域物件window。 立即函式(IIFE)理論上也是直接呼叫，this也是指向全域 非同步的事件 (setTimeout, Ajax等)中callback function 的this也是指向全域。 &gt; 隱含的綁定(Implicit Binding) 透過物件執行呼叫函式透過物件執行函式時，this指向為該物件。 12345678910var obj = { fn1: function(){ console.log(this); var fn2 = function(){ console.log(this); //this 為 window }; fn2(); //Simple Call }};obj.fn1(); //透過物件執行呼叫函式 this 為 obj 若宣告嚴格模式的話(use strict)，會禁止 this 自動指定為全域物件，this則會變成 undefined。 1234567891011var obj = { fn1: function(){ &quot;use strict&quot;; console.log(this); var fn2 = function(){ console.log(this); //undefined }; fn2(); }};obj.fn1(); 透過DOM物件來呼叫function時，this也是同樣指向該DOM物件(event.currentTarget) See the Pen DOM this by KaiYun Cheng (@kaiyuncheng) on CodePen. 重新指向 thisvm, that, self非同步的事件 (setTimeout, Ajax等)中 callback function 的this指向全域window，因此若我們需要把this指回DOM物件，一般常見的作法是用一個變數(vm, that, self)來代替要指回的this See the Pen PozgBWe by KaiYun Cheng (@kaiyuncheng) on CodePen. &gt; 明確綁定(Explicit Binding) bind(),call(),apply()bind()在function後面加上 .bind(this) 就可以強制將 () 內的物件帶入至 callback function 內 See the Pen bind by KaiYun Cheng (@kaiyuncheng) on CodePen. 1234567891011let familyBaker = { mom: 'Nicole Baker', dad: 'Tom Baker'};let familyName = function () { console.log(this.mom);};familyName(); // 未指定this 則會指向全域familyName.bind(familyBaker)(); //指向Baker ㄧ家 Nicole Baker call()apply() 在function後面加上 .call() 或 .apply()來呼叫function，指定第一個帶入的參數作為該function執行呼叫時的this，兩者的差別只在於參數寫法，第一個都是指定this，.call()的第2.3.4…個參數用逗號隔開。.apply()第二個參數為陣列，陣列則可以帶入好幾個參數。 123456function add(a, b) { return a + b;}console.log(add(1, 2)); // 3console.log(add.call(null, 1, 2)); // 3, this = nullconsole.log(add.apply(null, [1, 2])); // 3, this = null 12345678910111213var animals = [ {species: 'Lion', name: 'King'}, {species: 'Whale', name: 'Fail'}];for (var i = 0; i &lt; animals.length; i++) { (function (i) { this.print = function () { console.log('#' + i + ' ' + this.species + ': ' + this.name); } this.print(); }).call(animals[i], i); //參數1綁定animals[i]為this} &gt; new 綁定 - 建構式的調用 (As a constructor)當一個 function 前面帶有 new 被呼叫時，會發生： 會產生一個新的物件 (物件被建構出來) 這個新建構的物件會被設為該function this的綁定目標，也就是 this 會指向新的物件。 除非這個 function 指定回傳 (return) 了他自己的替代物件，否則這個透過 new 產生的物件會被自動回傳。 123456789101112var mom = '媽咪'function findMom (name) { this.mom = name console.log(this); console.log(this.mom);}findMom('AAA'); //this會指向到全域 全域的mom會替換成AAAvar newFindMom = new findMom('BBB'); //建構了一個新物件 並把this指向newFindMom console.log(newFindMom.mom); // BBB 箭頭函式 this回到上面說的箭頭函式，this會依據語彙環境的父層區域(parent scope)來綁定。簡單的說法是，箭頭函式沒有this，this指向往上一層找，一般若上層為預設綁定(Default Binding)，則指向全域window。 舉例 四種找媽函式 呼叫方式皆為family物件中呼叫 family.findMom1(); 12345678910111213141516171819202122232425262728293031323334353637383940414243var findMom1 = function () { console.log(this.mom); //區域媽咪 傳統函式this指向family setTimeout(function () { console.log(this.mom); //全域媽咪 非同步回呼沒特別指定指向全域 }, 1000); };var findMom2 = function () { console.log(this.mom); //區域媽咪 傳統函式this指向family setTimeout(() =&gt; { console.log(this.mom); //區域媽咪 箭頭函式的parent scope是傳統函式function this 指向family }, 1000); };var findMom3 = () =&gt; { console.log(this.mom); //全域媽咪 箭頭函式的parent scope是全域window this也就指向全域window setTimeout(function () { console.log(this.mom); //全域媽咪 非同步回呼沒特別指定指向全域 }, 1000); };var findMom4 = () =&gt; { console.log(this.mom); //全域媽咪 箭頭函式的parent scope是全域window this也就指向全域window setTimeout(() =&gt; { console.log(this.mom); //全域媽咪 箭頭函式的parent scope是全域window this也就指向全域window }, 1000); };var mom = '全域媽咪';var family = { findMom1, findMom2, findMom3, findMom4, mom: '區域媽咪'};family.findMom1();family.findMom2();family.findMom3();family.findMom4(); DOM物件的例子： 同理在Vue中，使用Ajax回呼用箭頭函式指向為上一層parent scope，便可以使用this呼叫到data See the Pen arrow functions by KaiYun Cheng (@kaiyuncheng) on CodePen. 參考資料 JavaScript ES6 Arrow Functions 箭頭函數 鐵人賽：箭頭函式 (Arrow functions) this是甚麼? 談談 JavaScript 中的 “this” 和它的問題 JavaScript ES6 中的箭頭函數（arrow function）及對 this 的影響 鐵人賽：JavaScript 的 this 到底是誰？ 重新認識 JavaScript: Day 20 What’s “THIS” in JavaScript (鐵人精華版) Function 內的 this 到底是哪個 this","link":"/2020/11/17/arrowFunctions/"},{"title":"[JS] 物件導向: 原型Prototype與物件Object","text":"前言這篇會來整理關於JS原型、類別、物件導向、原型鍊、繼承、建構子等。這幾個關聯又有點難懂的關鍵字，在學JS時時常聽到，一開始只是去使用JS、Vue到現在去了解他背後運作的原理，才恍然大悟原是這樣啊！ JavascriptJavaScript 是一個以原型為基礎 (Prototype-based)、多範型的、動態語言。支援物件導向(Object-oriented programming, OOP)、指令式以及宣告式 (如函數式程式設計)。 物件導向程式設計 OOP是將 軟體 想像成由一群物件交互合作所組成，而非以往以函數 (Function) 或簡單的指令集交互合作所組成。在物件導向的架構中，每個物件都具有接收訊息，處理資料以及發送訊息給其他物件的能力。每個物件都可視為獨一無二的個體，他們扮演不同的角色並有不同的能力及責任。物件導向程式設計強調模組化，使得程式碼變的較容易開發和理解。 類別 (Class) 和 物件 (Object)類別 (Class)類別是用來定義物件的屬性 (properties) 和方法 (methods)的藍圖。 物件 (Object)物件為一個類別的實體 (Instance)，包含屬性 (properties)與方法 (methods)的資料結構。 上述有提到Javascript是以原型為基礎 (Prototype-based)的語言，不用先設計藍圖(類別)就可以建立物件，是無類別的 (Classless)。 那JS沒有類別要如何用原型基礎來實現物件導向的概念呢？JS的物件透過原型(Prototype)相互繼承各自功能，形成原型鍊(Prototype Chain)。建立物件時，會用一個函式function也就是建構式 (Constructor)來定義物件的藍圖，類似類別的概念。 ES6有個class的新語法，只是個語法糖，讓建構式 (Constructor)的寫法更簡潔易懂，更近似於其他物件導向語言C++、JAVA定義類別的方式，但JavaScript仍然是基於原型的語言。 建構式 (Constructor) aka 建構子 建構器Constructor為用來定義物件的藍圖，可以定義物件的屬性、物件本身的方法。也可以藉由.prototype來定義該Constructor原型的方法。 在Javascript中有以下內建的ConstructorString(),Number(),Boolean(),Array(),Object(),Function(),RegExp(),Date(),Error(),Symbol() 當然也可以自定義Constructor，而要建立新物件時，可以在Constructor前面用 new 這個關鍵字 123456789101112131415161718192021222324// 自定義Constructor 名稱第一個字為大寫function CarFactory (brand, model, price){ // 定義物件的屬性 this.brand = brand; this.model = model; this.price = price; // 定義物件本身的方法 this.description = function(){ console.log(`Brand ${brand}, this year new model ${model} is $${price}`); }; } // 定義原型上的方法CarFactory.prototype.discount = function() { this.discountPrice = this.price * 0.9; console.log(`New Car gets 10% off, the discounted price is $${this.discountPrice}`);}; var berlingo = new CarFactory( 'Citroen', 'Berlingo', '40000');berlingo.description(); //物件本身的方法berlingo.discount(); //CarFactory物件原型上的方法，並不在物件本身上var vios = new CarFactory( 'Toyota', 'Vios', '20000');vios.description();vios.discount(); 以ES6 Class 的寫法則為 1234567891011121314151617181920212223242526class CarFactory { constructor(brand, model, price) { this.brand = brand; this.model = model; this.price = price; // 定義物件上的方法 this.description = function(){ console.log(`Brand ${brand}, this year new model ${model} is $${price}`); }; } // 定義原型上的方法 discount(){ this.discountPrice = this.price * 0.9; console.log(`New Car gets 10% off, the discounted price is $${this.discountPrice}`); }}var berlingo = new CarFactory( 'Citroen', 'Berlingo', '40000');berlingo.description(); //物件本身的方法berlingo.discount(); //CarFactory物件原型上的方法，並不在物件本身上var vios = new CarFactory( 'Toyota', 'Vios', '20000');vios.description();vios.discount(); .prototype 定義原型方法 藉由.prototype來定義新增該Constructor原型的方法。很多Polyfill就用這種做法在某些版本瀏覽器不支援時，在原型上增加語法。 原型(prototype) 和 原型鏈 (Prototype Chain)若我們用上述的例子來舉例 Console.log(berlingo)後會發現物件上除了本身的屬性和方法外，會有一個__proto__可以展開，這就是CarFactory這個原型，用.prototype定義的屬性和方法則會在原型上，然後我們會發現CarFactory這個原型上還有個proto:Object，這個是物件最上層的原型Object Prototype，所有物件最上層的原型都是Object Prototype，再往上則會是空值Null。 在CarFactory這個原型我們定義了discount()這個方法，這個方法是一個函式，展開後我們會發現proto:f()，就是函式的原型，可以看到函式的內建方法bind、call、apply等等，函式原型裡頭又會有個最上層的物件原型Object Prototype。 這種一層一層原型接來接去，就是原型鏈 (Prototype Chain)的概念。 繼承(Inheritance)原型這樣接來接去，會繼承上面那個原型的屬性和方法。用同樣上述例子，berlingo這個物件本身是沒有discount()這個方法，而是berlingo繼承了CarFactory這個原型上的方法，所以berlingo也可以使用。 instanceof 查看原型語法以 上述建構式 為例： 12console.log(vios instanceof CarFactory); // true CarFactory 是vios的原型console.log(vios instanceof Object); // true Array陣列、Array-like類陣列DOM方法取得的並不是一般的陣列是類陣列，可以看到他的原型是NodeList，跟Array的原型proto: Array 不同。因此Array可以使用的方法，NodeList不一定有，像是.map()等。Arguments也是一種類陣列，可用…展開或array.from轉成陣列。 1234567891011121314var divList = document.querySelectorAll('div');// __proto__: NodeList//可用...展開或array.from轉成陣列var divArr = [...divList];var divArr = Array.from(divList);function fn(a){ return arguments; //__proto__: Object} var args = fn('1','2','3','4');var fnArr = [...args];var fnArr = Array.from(args); Object.create() 繼承ES6的新語法 用(物件a)作為原型來建立新的物件b新物件b繼承了物件a的屬性與方法 123var a = {name: 'Zoe'}; // a ---&gt; Object.prototype ---&gt; nullvar b = Object.create(a); // b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.name); //Zoe Object.setPrototypeOf()可帶入兩個參數 第一個為接受繼承的物件 第二個為原型以下例子結果與create一樣 12345678910var a = {name: 'Zoe'}; // a ---&gt; Object.prototype ---&gt; nullvar b = {}; Object.setPrototypeOf(b, a); // b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.name); //Zoe var c = {age: 18};Object.setPrototypeOf(b, c); // b ---&gt; c ---&gt; Object.prototype ---&gt; null//同一個物件無法指定兩種原型物件Object.setPrototypeOf(c, a); // c先繼承aObject.setPrototypeOf(b, c); // b再繼承c 則也會有a的屬性 ES6 Class, Extend, Super ES6 Class語法 1234567891011121314151617181920212223242526272829class CarFactory { constructor(model, price) { this.model = model; this.price = price; // 定義物件上的方法 this.description = function(){ console.log(`this year new model ${model} is $${price}`); }; } // 定義原型上的方法 discount(){ this.discountPrice = this.price * 0.9; console.log(`New Car gets 10% off, the discounted price is $${this.discountPrice}`); }};class Toyota extends CarFactory{ //Toyota 繼承 CarFactory原型 constructor(model, price, brand) { super(model, price) //CarFactory原型 原有變數 this.brand = brand; //Toyota原型 新增的變數 }; introduce(){ console.log(`${this.model} is a ${this.brand} car.`); };};var wish = new Toyota('Wish', '20000', 'Toyota');wish.introduce(); .hasOwnProperty()此物件本身是否有這個屬性 (原型的屬性不算); 12345var a = {name: 'Zoe'}; var b = {sex: 'female'}; Object.setPrototypeOf(b, a); console.log(b.hasOwnProperty('name')); //falseconsole.log(b.hasOwnProperty('sex')); //true in 判斷物件是否有繼承到這個屬性b裡是否有繼承到name這個屬性 1console.log('name' in b); //true 最頂層 物件原型 Object Prototype的方法更改屬性值 Object.definePropertyObject.defineProperty(obj, Property, descriptor)第一個變數是要定義的物件第二個變數是要定義物件的屬性第三個則是屬性描述器 valueOf() 取得屬性值屬性描述器（Property descriptor）可用 Object.getOwnPropertyDescriptor(obj, property) 取得屬性描述在 屬性描述可分成有六種數值value(選填 預設undefined): 屬性的值writable(選填 預設false): 定義屬性是否可以改變，如果是 false 那就是唯讀屬性。enumerable(選填 預設false): 定義物件內的屬性是否可以透過 for-in 語法來迭代。configurable(選填 預設false): 定義屬性是否可以被刪除、或修改屬性內的 writable、enumerable 及 configurable 設定。get(選填 預設undefined): 物件屬性的 getter function。set(選填 預設undefined): 物件屬性的 setter function。 1234567891011121314berlingo.price = 10000;//可透過Object.defineProperty來設定物件屬性Object.defineProperty(berlingo, 'price', { value: 10000});Object.getOwnPropertyDescriptor(berlingo, 'price');// configurable: true// enumerable: true// value: &quot;10000&quot;// writable: trueberlingo.price.valueOf(); //10000 get 和 set 存取器描述器 (Accessor Descriptor)取值器 getter: 取得指定屬性的值的方法設值器 setter: 設定指定屬性的值的方法 12345678910111213var berlingo = { price: 40000, _discount: 0.8, get discount(){ return this.price * this._discount; }, set discount(num){ this._discount = num; }};berlingo._discount = 0.7console.log(berlingo.discount); //28000 ES6 語法 1234567891011121314151617var berlingo = { price: 40000};Object.defineProperty(berlingo, 'discount', { get: function(){ return this.price * this._discount_; //40000*0.5 }, set: function(num){ this._discount_ = num; //0.5 }, configurable: true, enumerable: true});berlingo.discount = 0.5;console.log(berlingo.discount); // 20000 參考資料 MDN文件 MDN 物件導向 了解JavaScript中原型(prototype)、原型鍊（prototype chain）和繼承(inheritance)的概念 重新認識 JavaScript: Day 25 原型與繼承 重新認識 JavaScript: Day 22 深入理解 JavaScript 物件屬性 JavaScript 的原型繼承","link":"/2020/11/19/prototype/"}],"tags":[{"name":"coding girl","slug":"coding-girl","link":"/tags/coding-girl/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"c3.js","slug":"c3-js","link":"/tags/c3-js/"},{"name":"Regular Expression","slug":"Regular-Expression","link":"/tags/Regular-Expression/"},{"name":"RegEx","slug":"RegEx","link":"/tags/RegEx/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"window.location","slug":"window-location","link":"/tags/window-location/"},{"name":"event queue","slug":"event-queue","link":"/tags/event-queue/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"Synchronous","slug":"Synchronous","link":"/tags/Synchronous/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Fetch","slug":"Fetch","link":"/tags/Fetch/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","link":"/tags/XMLHttpRequest/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Async","slug":"Async","link":"/tags/Async/"},{"name":"Await","slug":"Await","link":"/tags/Await/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"Arrow Functions","slug":"Arrow-Functions","link":"/tags/Arrow-Functions/"},{"name":"Inheritance","slug":"Inheritance","link":"/tags/Inheritance/"},{"name":"Prototype Chain","slug":"Prototype-Chain","link":"/tags/Prototype-Chain/"},{"name":"Prototype","slug":"Prototype","link":"/tags/Prototype/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Object","slug":"Object","link":"/tags/Object/"}],"categories":[{"name":"murmur","slug":"murmur","link":"/categories/murmur/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"}]}