{"posts":[{"title":"JSDoc - 產生API說明文件","text":"JSDochttps://jsdoc.app/ 用法 註解(comment) /** */ 標記(tags) @ HTML 型別註釋(type notation)123/** Repeat &lt;b&gt;AAA&lt;/b&gt; * @namespace */ 123456789101112/** * Represents a book. * @constructor * @param {string} title - The title of the book. * @param {string} author - The author of the book. * @param {string | number} [code = 0] - The code of the book. * @param {string[]} tags - The tags of the book. */ function Book(title, author, code, tags) {} 名稱路徑(NamePath) 1234567891011121314151617181920212223/** @constructor */var Person = function() { this.say = function() { return \"I'm an instance.\"; } function say() { return \"I'm inner.\"; }}Person.say = function() { return \"I'm static.\";}var p = new Person();p.say(); // I'm an instance.Person.say(); // I'm static.// there is no way to directly access the inner function from herePerson#say // the instance method named \"say.\"Person.say // the static method named \"say.\"Person~say // the inner method named \"say.\" @class@leads NamePath 123456789101112/** * A class for managing persons. * @class */var Person = makeClass(){ /** @leads Person# */ { say: function(message) { return \"This person says\" + message; } }}; @constructs@memberof 1234567891011121314var Person = makeClass(){ /** * A class for managing persons. * @constructs Person */ /** @memberof Person# */ { say: function(message) { return \"This person says\" + message; } }}; @extends namePath標示子類別 12345678/** * @constructor * @extends Person */function Programmer(name){ Person.call(this, name);}; https://github.com/jsdoc/jsdoc","link":"/2022/11/12/JSDoc/"},{"title":"Typescript Note - 安裝 &#x2F; 型別 &#x2F; 用法","text":"Typescript 編譯安裝指令 全域安裝Typescriptnpm install -g typescript 專案資料夾 初始化 tsc --init 生成 tsconfig.json 配置檔 Typescript compiler tsc hello.ts tsc 檔案名稱 live watch tsc --watch 查看Typescript版本 tsc -v tsconfig.json 配置檔 https://aka.ms/tsconfig 若要 compile 整個 src 資料夾可更改配置輸入位置\"rootDir\": \"./src\",輸出位置\"outDir\": \"./dist\",指令 tsc 即可編譯整個資料夾底下的所有ts到dist資料夾 建議開啟source map 可以在除錯時更快找到原始ts檔\"sourceMap\": true, 若有舊檔案js 需要import可開啟\"allowJs\": true, null undefined原始設定在number情況會被接受\"strictNullChecks\": true Typescript = JS + type system 原始型別 Primitive Types 物件型別 Object Types Number Object String Array Boolean Function Undefined Date Null RegExp Symbol Error …（其他內建） BigInt 原始型別 容易出錯的地方12345678let num1 = 999let num2: number; //若無值也沒有宣告型別，則會被判斷為any，這種情況建議避免。let un1 = undefined //型別會被推斷為anylet un2: undefined //型別指定為undefinedlet n1 = null //型別會被推斷為anylet n2: null //型別指定為null Union 聯合型別12345678910111213141516const arr: (string | boolean)[] = []arr.push(false)arr.push('')let name: string | number;function displayPrice(price: number | [number, number]){ if(typeof price === \"number\"){ console.log(`價格:${price}`) }else{ console.log(`價格範圍:${price[0]}~${price[1]}`) }}displayPrice(49.99);displayPrice([33,55]) Array1234567const arr1 = [1, 2, 3] // number[]const arr2 = [1, 2, '3'] // (number | string)[]const arr3: string[] = [] const arr4: Array&lt;string&gt; = [] // 泛型與 string[]相同const arr5: string[][] = [['1', '2'], ['3', '4']] Tuple 元組12const tu1: [number, string, boolean] = [123, 'apple', false]const tu2: [number, number][] = [[11, 22], [33, 44]] Object 物件1234let obj: { name: string, age?: number | undefined } // age?為選填obj = { name: 'Jay',} any / unknownunknown : 可以用較安全的any來理解 12345678910111213141516const status = falsefunction getName() { let name: unknown //這邊使用unknown 會在接下來的result做防護 if (status) { name = 'Tom' } else { name = null } return name}const result = getName()if (typeof result === 'string') { result.split('')} Type Assertion 斷言 as應用於原本不確定的回傳型別檔案，再賦予該檔案的型別 1234567891011121314151617181920212223242526async function getData() { const res = await fetch('https://jsonplaceholder.typicode.com/todos/1') const data = await res.json() as { userId: number, id: number, title: string, completed: boolean } console.log(data)}getData()//DOM const txt = document.querySelector(\".taskName\") as HTMLInputElementconsole.log(txt.value)// return 陣列 (避免union情況的發生)// 寫法1 getArr自動推斷成return (string | number)[] 用as const 讓 id, age, userName對應到正確的型別function getArr() { return [0, 30, 'Kim'] as const }const [id, age, userName] = getArr()// 寫法2 as直接定義型別function getArr() { return [0, 1, 'bruce'] as [number, number, string]} 強制斷言強制去轉型 先轉成unknown或是any 再轉成結果型別 12let code1 = 999let code2 = code1 as unknown as string never 類型12345678910let code: string | numbercode = 'abc'code = 123// never 永遠不可能發生的類型，當寫出code是字串類型時，ts會報錯，因為code已經賦予成數字if (typeof code === 'string') { code.split() // Property 'split' does not exist on type 'never'} type 自定義類型12345678type Name = string | boolean | numberlet name1: Namelet name2: Namelet name3: Nametype OBJ = { name: string, age: number }let obj1: OBJlet obj2: OBJ interface 介面123456789interface UserCard { name: string age: number | null}const usercard: UserCard = { name: '', age: null} type vs interface兩者除了寫法有點不太一樣外，interface擁有合併多個的功能，type則沒有 12345678910111213141516type Animal = { name: string}type Cat = Animal type Dog = Animal &amp; { age: number} let dog: Dog = { name: 'dog', age: 99}let cat: Cat = { name: 'cat',} 12345678910111213141516171819interface Animal { name: string}interface Cat extends Animal {} interface Dog extends Animal { age: number} let dog: Dog = { name: 'dog', age: 99}let cat: Cat = { name: 'cat',} 更詳細的差異圖 更詳細介紹文章 Interfaces vs Types in TypeScript Day 16. 機動藍圖・介面與型別 X 混用與比較 - TypeScript Interface V.S. Type &lt;标签标题&gt; &lt;标签标题&gt; &lt;标签内容&gt; &lt;标签内容&gt; interface 合併1234567891011121314151617181920212223//interface可以重複宣告並合併interface Animal { name: string}interface Animal { age: number}let dog: Animal = {}//type無法重複宣告 無法兩者合併type Animal = { name: string}type Animal = { age: number}let dog: Animal = {} enum 枚舉值適合用在 狀態 日期 星期 有一定範圍的情況 1234567891011121314151617181920212223242526enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};//枚舉成員從0開始排列與下方賦值寫法相同enum Days { Sun = 0, Mon = 1, Tue = 2, Wed = 3, Thu = 4, Fri = 5, Sat = 6};//也可以自定義賦值，但未定義賦值的成員會接著上一個+1遞增有可能會有重複情況 Sun = 4 Thu = 4 導致使用上錯誤，要特別注意enum Days { Sun = 4, Mon = 1, Tue = 2, Wed = 3, Thu, Fri, Sat}; 12345678910111213141516171819202122232425enum TaskStatus { Todo, InProgress, Done}// 空任務陣列let tasks:{name:string,status:TaskStatus}[] = [];// 新增陣列function createTask(name: string){ tasks.push({ name: name, status: TaskStatus.Todo })}// 新增任務到任務列表createTask(\"學習TS\");createTask(\"去超市購物\");//顯示任務console.log(tasks); function12345678910111213//陳述式 Declarationfunction checkNum(num: number): boolean { return num &gt; 10;}//表達式 Expressionlet checkNum = function(num: number): boolean{ return num &gt; 10;}let addNum: (a: number, b: number)=&gt; number = function(a, b) { return a+b;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// :後面 為回傳值的型別 指定為number 若沒寫則為ts自行推定為stringfunction get(a: number, b: string, c: boolean): number { return Number(a + b);}get(99, '', true);// ?為可選參數 ts會避免錯誤 而要求增加判斷function setUser(name: string, age?: string) { if (typeof age === 'string') { return age.split('') }}// type type Info = { name: string, age: number}function createUserInfo(info: Info) { console.log(info.name) //當使用info時會自動提示info內的屬性名稱 return info}// 回傳值 never function getUserData(): never { throw new Error('...')}// 沒有return 回傳值 void function hello() { console.log()}function printMessage(message: string): void{ alert(\"message\");}// 構建函數的寫法 newtype CardObj = { name: string}type CardCreator = { new(name: string): CardObj}function createCard (cardCreator: CardCreator) { return new cardCreator('abc')}// 簡易function泛型 &lt;&gt;// 使用時才定義傳入參數的型別function print&lt;T&gt;(data: T) { console.log(data);}print&lt;string&gt;('abc')print&lt;number&gt;(123)print&lt;boolean&gt;(true) overload function 過載某些情況會需要傳入參數為不同型別，可以使用聯合型別union來做，但回傳值無法精確的定義回傳的型別為何，則可用過載的方式來定義傳入與回傳的型別 reverse 字串反轉 / 數字反轉 12345678910111213141516171819// 聯合型別 union function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }}// 過載 overloadfunction reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} function …rest有多個參數傳入的情況，數量不確定時 1234function calculate(...nums: number[]) { console.log(nums);}calculate(1, 2, 3, 4, 5, 99, 3213) 使用斷言as 12345678function calculate(a: number, b: number, c: number) { console.log(a); console.log(b); console.log(c);}const nums = [1, 2, 3] as constcalculate(...nums)","link":"/2024/01/02/Typescript_01/"},{"title":"Typescript Note 2 - OOP &#x2F; class &#x2F; interface","text":"物件導向 OOP / class 設計圖在物件導向的架構中，每個物件都具有接收訊息，處理資料以及發送訊息給其他物件的能力。 一個簡易的會員資料集 屬性： name age address功能： 新增資料 更新資料 刪除資料 123456789101112131415161718192021// 會員資料物件的設計圖class User { constructor(name: string, age: number) { console.log('物件建立之前回執行的內容'); this.name = name this.age = age } // 屬性 name: string age: number address: string // 功能 add() {} update() {} delete() {}}const user1 = new User('Tom', 19) //user1.name = Tomconst user2 = new User('Amy', 22) //user2.age = 22const user3 = new User('John', 50) interface implements在class類別 使用implements interface 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152interface UserInterface { id: number name: string age: number address: string // 功能 add: (data: any) =&gt; void update: (id: number) =&gt; boolean delete: (id: number) =&gt; boolean}class LiveUser implements UserInterface { id: number name: string age: number address: string add(data: any) {} update(id: number) { // ... return true } delete(id: number) { // ... return true } // 額外新增的功能 startLive() {} endLive() {}}class VideoUser implements UserInterface { id: number name: string age: number address: string add(data: any) {} update(id: number) { // ... return true } delete(id: number) { // ... return true } // 額外新增的功能 postVideo() {} deleteVideo() {}} extends 類別繼承123456789101112131415161718192021// constructor superclass Animal { name: string constructor (name: string) { this.name = name } run() { console.log('run....', this.name); }}class Dog extends Animal { run() { //複寫父層的run(); super.run() //使用super呼叫父層的run(); console.log('dog run....', this.name); }}const dog1 = new Dog('狗狗1')d1.run() //run....狗狗1 //dog run....狗狗1 abstract 抽象類別1234567891011121314151617181920212223242526abstract class Animal { run() { console.log('run....'); } abstract hello(): void }// 抽象類別無法實體化 所以底下使用new會報錯// const a1 = new Animal()class Dog extends Animal { hello() { console.log('hello...') }}class Cat extends Animal { hello() { console.log('hello...') }}const d1 = new Dog()d1.run()d1.hello() Access Modifiers (public, private, protected, readonly)修飾詞（公開，私有，受保護的, 唯讀） public 可以被修改，可以在任何地方存取修改該屬性的值或是使用該函式(預設值) private 私有的，只能在在該類別才能存取修改該屬性的值或是使用該函式，外部無法使用，可使用function在原類別調用出來 protected 受保護的，在該類別或是子類別裡才能存取修改該屬性的值或是使用該函式 readonly 無法被修改的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//publicclass Animal { public name: string; public constructor(name: string) { this.name = name; }}let dog = new Animal('Dog');console.log(dog.name); // Dogdog.name = 'DogDog';console.log(dog.name); // DogDog//privateclass Animal { private name: string; public constructor(name: string) { this.name = name; } getName() { return this.name }}let dog = new Animal('Dog');console.log(dog.name); // 外部無法調用與修改 但主要用在開發階段 在瀏覽器還是可以調用得到console.log(dog.getName()); // 可調用class Cat extends Animal { constructor(name) { super(name); console.log(this.name); // 外部無法調用與修改 }}//protectedclass Animal { protected name:string; public constructor(name:string) { this.name = name; }}class Cat extends Animal { constructor(name:string) { super(name); console.log(this.name); // 外部可以調用和修改 }}//readonlyclass Animal { readonly name:string; public constructor(name:string) { this.name = name; }}let a = new Animal('Jack');console.log(a.name); // 可讀取a.name = 'Tom'; //無法修改 JS 原生私有成員寫法（ES6）加上# 代表private需在 tsconfig.json 配置檔 指定target es6以上版本 才有支援\"target\": \"es6\", 12345678910class UserInformation { #name: string = 'Kim' getName() { return this.#name }}const u = new UserInformation()console.log(u.#name); //外部呼叫不到console.log(u.getName()); //需用內部function調用 Access Modifiers (readonly)12345678910class Animal { readonly name:string; public constructor(name:string) { this.name = name; }}let a = new Animal('Jack');console.log(a.name); // 可讀取a.name = 'Tom'; //無法修改 Access Modifiers (static) 靜態屬性 (es7)static 可以直接被取用的 用於全局、可共用的大項目中 1234567891011121314151617181920212223242526272829//共用的金庫 取錢 withdraw 和 查看 getBalance 皆可以直接被取用class Bank { private static balance: number = 1000 static withdraw(money: number) { if (this.balance &lt;= 0) return this.balance -= money } static getBalance() { return this.balance }}// const bb1 = new Bank() static 不用使用new 即可取得Bank.balance = 99999 // 設為private 無法修改console.log(Bank.balance); // 設為private 無法被取用//可以在不用new實體或是extends 直接被取用function userAWithdraw(money: number) { Bank.withdraw(money) console.log(Bank.getBalance())}function userBWithdraw(money: number) { Bank.withdraw(money) console.log(Bank.getBalance()) }userAWithdraw(200) //800userAWithdraw(500) //300 override 多型1234567891011121314151617class SomeComponent { //當show(), hide()在原始類別被刪除時， SpecializedComponent繼承的不會跳錯，會被當成是新的function- show() {- // ...- }- hide() {- // ...- }}class SpecializedComponent extends SomeComponent { show() { // ... } hide() { // ... }} 使用override來避免這個情況 12345678class SpecializedComponent extends SomeComponent { override show() { // ... } override hide() { // ... }} 泛型 &lt;&gt;1234567function hello&lt;T, U&gt;(text: T, text2: U): U { console.log(text, text2); return text2;}hello&lt;string, number&gt;('abc', 123)hello&lt;number, boolean&gt;(123, true) 123456789101112131415161718192021222324252627282930interface Card&lt;T&gt; { title: string desc: T}function printCardInfo&lt;U&gt; (desc: U): Card&lt;U&gt; { const data: Card&lt;U&gt; = { title: 'ABC', desc } return data}console.log(printCardInfo&lt;number&gt;(9999)) //U變成number 再傳入Card&lt;T&gt; T也變成number//class 寫法interface CarProps&lt;T&gt; { name: T}class Car&lt;U&gt; implements CarProps&lt;U&gt; { name: U constructor(name: U) { this.name = name }}const car = new Car&lt;string&gt;('Toyota')console.log(car); interface / type extends 條件判斷1234567891011121314151617181920//type type T1 = string extends string ? string : number //T1判斷為stringtype T1 = string extends boolean ? string : number //T1則判斷為number//interface有繼承關係的A, Binterface A { name: string}interface B extends A {}type T2 = B extends A ? string : number //T2判斷為string//interface無繼承關係的C, D 但C的條件滿足D 因此 D extends C 判斷為 trueinterface C { name: string }interface D { name: string, age: number }type T3 = D extends C ? string : number //T3判斷為string// T肯定會是array 用extends去指定function sliceArr&lt;T extends Array&lt;T&gt;&gt;(a: T) { console.log(a.length)} 基本泛型用法1234type T4 = 'abc' extends 'abc' ? string : number //T4判斷為stringtype T5&lt;T&gt; = T extends 'abc' ? string : number //T5判斷為stringtype Res = T5&lt;'abc'&gt; Union1234567891011type T6 = 'abc' extends 'abc' | 'abc2' ? string : number //T6判斷為stringtype T7 = 'abc' | 'abc2' extends 'abc' ? string : number //T7判斷為numbertype T8&lt;T&gt; = T extends 'abc' ? string : numbertype Res = T8&lt;'abc' | 'abc2'&gt; // res 會判斷成 string | number// 步驟會是// 1. 'abc' -&gt; T = string// 2. 'abc2' -&gt; T = numbertype TT7&lt;T&gt; = [T] extends ['abc'] ? string : numbertype Res = TT7&lt;'abc' | 'abc2'&gt; //與T7相同 []內的整個union視為一體 則被判斷成number never12345// never 是所有類型的子類別 N1判斷成stringtype N1 = never extends 'abc' ? string : numbertype N2&lt;T&gt; = T extends 'abc' ? string : numbertype Res = N2&lt;never&gt; // 被當成一個空的union res判斷成never infer12345678910111213// infer用法 類似 var,let 如果T extends Array&lt;infer P&gt;成立 則宣告Ptype TT1&lt;T&gt; = T extends Array&lt;infer P&gt; ? P : never;type R1 = TT1&lt;[123, 'abc']&gt; //符合array 則宣告P為 123, 'abc'type R2 = TT1&lt;number&gt; //不符合 則不會宣告P 直接進入判斷為never// function用法type TT2&lt;T&gt; = T extends (param: infer P) =&gt; any ? P : nevertype R3 = TT2&lt;(a: number) =&gt; void&gt; //符合(param: infer P) =&gt; any 則宣告P爲 numberinterface UserCard { name: string }type R4 = TT2&lt;(a: UserCard) =&gt; void&gt; //符合(param: infer P) =&gt; any 則宣告P爲 UserCardtype R5 = TT2&lt;[]&gt; //不符合 則不會宣告P 直接進入判斷為never keyof 用法12345678910111213141516interface UserCard { name: string age: number cardTitle: string cardDesc: string}type T1 = keyof UserCard// T1 會被推斷成union類型 內容有 'name' | 'age' | 'cardTitle' | 'cardDesc'const a: T1 = 'name'// 泛型 K去繼承T的key值function getValue&lt;T, K extends keyof T&gt; (obj: T, key: K): T[K] { return obj[key]} typescript module 模組假設環境內不同ts檔案有相同名命，ts會視為同一個模組便會跳錯，避免這種情形可以在個別ts設定 export 讓ts視為分開的模組 module 模組 與 tsconfig.json 配置檔 https://aka.ms/tsconfig 上一篇有紀錄一些配置檔的設定，這邊會主要針對模組化的部分 如果使用webpack的ts loader，官方文件不建議module設定為CommonJS，會失去tree shaking的功能。只有在es6/es2015以上才有tree shaking的效果。 “module”: “es6”“target”: “es6” 輸出的版本 “moduleResolution”: “node” 用node的方式去解析import路徑 “esModuleInterop”: true 可以引入較舊的CommonJS pkg “allowSyntheticDefaultImports”: true 假設設定false 當引入沒有設定export default檔案時，是無法給予別名 可用 import * as webpack from ‘webpack’; 替代或是設定為true 設定根目錄例如引入時 import abc from '../utils/abc.ts' 可以設定成 import abc from '@/utils/abc.ts' @代表 ./src底下 “baseUrl”: “./src”,“paths”: { “@/“: [““]} 若有使用webpack打包，也須在webpack.config.js下設定 123456resolve: { extensions: ['.tsx', '.ts', '.js'], alias: { '@': path.resolve(__dirname, 'src'), }}, Typescript Cheat Sheets","link":"/2024/01/03/Typescript_02/"},{"title":"[JS] 用C3.js來繪製圖表","text":"前言c3.js是一個免費開源的圖表套件，源自d3.js(操控SVG向量圖形進行資料視覺化的JavaScript程式庫)，類似的套件還有ChartJS C3.js 圖表整合文件 起手式js必須載入兩支d3.js和c3.js 123456&lt;!-- Load c3.css --&gt;&lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.18/c3.css\"&gt;&lt;!-- Load d3.js and c3.js --&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.18/c3.js\"&gt;&lt;/script&gt; 在要建立圖表的地方插入，id可更改。 1&lt;div id=\"chart\"&gt;&lt;/div&gt; 接著初始化圖表，bindto設定對應的id名稱，就可以看到圖表畫面，接下來還有 123456789var chart = c3.generate({ bindto: '#chart', data: { columns: [ ['data1', 30, 200, 100, 400, 150, 250], ['data2', 50, 20, 10, 40, 15, 25] ] }}); 起手式 線圖 DEMO See the Pen C3.js 起手式 by KaiYun Cheng (@kaiyuncheng) on CodePen. C3.js的各式圖表example Customize Chart這邊列舉了一些用法，官方文件中還有其他更詳細介紹搭配不同圖表，就不一一介紹了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var chart = c3.generate({ bindto: \"#chart\", data: { columns: [ // 資料位置 [\"data1\", 30, 200, 100, 400, 150, 250], [\"data2\", 50, 20, 10, 40, 15, 25], [\"data3\", 2000, 20, 10, 40, 15, 25] ], axes: { // 軸數增加第二個 data2: \"y2\" }, // 圖型類型設定 types: { data2: \"bar\", // 長條圖 data3: \"spline\" // 曲線圖 }, // 更改顏色設定 colors: { data1: \"#03A9F4\", data2: \"#162F03\", data3: \"#76FF03\" } }, axis: { rotated: false, //是否轉成橫向 x: { type: \"category\", categories: [2000, 2001, 2002, 2003, 2004, 2005], // x軸單位內容 label: { text: \"X Label\", // x軸設定顯示名稱 position: \"outer-left\" //擺放位置 } }, y: { label: { // y軸設定顯示名稱 text: \"Y Label\", position: \"outer-bottom\" }, tick: { format: d3.format(\"$,\") // 資料前增加$符號 } }, y2: { show: true, label: { text: \"Y2 Label\", position: \"outer-middle\" } } }}); 另外也可在CSS上使用class名稱 c3-line-[id] 來修改畫面 123#chart .c3-line-data3 { stroke-width: 5px;} 客制設定 DEMO See the Pen C3.js Custom設定 by KaiYun Cheng (@kaiyuncheng) on CodePen. 長條圖 Bar Chart這邊會以長條圖為例把js60第29天的資料串接改成以長條圖方式呈現，把api回傳的資料， 用forEach依選擇的排列方式，把名字和完課率依序傳入到各自的新陣列，再把完課率陣列綁定到c3js圖表的data.columns裡，而名字綁定到x軸的categories上，畫面便可呈現。 See the Pen C3j 長條圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. 推薦延伸閱讀TimCodingBlog","link":"/2020/11/05/c3js/"},{"title":"Before starting","text":"為何會開始學code今年，也是Covid-19疫情大爆發的一年。我在國外打滾了好幾年，待了幾個國家，圓了一個年輕時的潛水夢想回到台灣，一方面是短期可能不能再出國了，一方面是對未來有別的規劃，因此決定轉換跑道，所以趟上了學習前端這個無底洞道路。 選擇前端是因為大學時期念工業設計，先前做設計師時的工作上有接觸過一些網站視覺設計和app的UI設計，更早期還是國中生時，曾經迷上一陣子網站設計，當時雖然是用Dreamweaver和frontpage的年代，但也製作出電子報和個人網站，印象中還用了FTP上傳到免費空間，不知道這樣是不是不小心透露了年紀了 XD。加上高中時期數學蠻好的，讓我認為學寫程式可能蠻適合我的。 學習的道路上今年5月開始在線上找尋學習資源，線上課程、教學網站、技術文章、別人的分享等等，Medium是我很常去看文章的平台，再加上好幾位大大的blog、Youtube。從中學習到非常多，越學越會發現還有更多要學的呢，學習過程中覺得寫扣很有趣，尤其是辛苦寫完畫面功能成功後的成就感，一切都值得。之後會在我的blog-CodeNotes上再分享有哪些推薦的網站。 CodeNotes的第一天最近看了許多大大用hexo創建自己的blog，覺得很有趣從中又可以學到code的用法，於是就也照本宣科創建了CodeNotes，還有許多功能在摸索，另外也會開始慢慢post最近學習不專業筆記。還請各位觀眾多多指教。","link":"/2020/10/27/beforeStarting/"},{"title":"[Functional JS] Currying 柯里化 &amp; Partial application","text":"前言最近在前端面試中遇到的考題中出現了柯里化，一個會讓人出現很多問號的js高階用法，一直是我沒有很熟悉高階js、functional programming這一塊，因為不是資訊科系出身，深感還有好多不足(嘆…)，希望可以趕快補足。在研究了解柯里化，就會發現其中的好處，也可以應用在實際案例中。 柯里化 Currying柯里化 Currying 可以讓呼叫函式 f(a, b, c) 轉換成可以分開呼叫 f(a)(b)(c)。原理是透過部分的參數呼叫一個 function，它會回傳一個 function 去處理剩下的參數。可應用在 參數共用 和 延遲執行 等。之所以叫做curry是提出這個概念者的名字 Haskell Curry。 Partial application類似Currying但可以接收多個參數，currying是一次一個，函式 f(a, b, c) 轉換成可以分開呼叫 f(a)(b, c) 基礎寫法1234567891011121314151617const add = function(a) { return function(b) { return a + b; };};//一次性呼叫add(1)(2); // 3//也可以每次只傳遞一個參數const Fn = add(1);Fn(2); // 3const curry = a =&gt; b =&gt; a + b;const add1 = curry(1)add1(2); //3 參數共用的應用用柯里化的其中一個好處是可以讓共同的參數進行重複使用例如：要做一個url，共用到https:// 123456789const urlCurrying = function(protocol) { return function(hostname, pathname) { return `${protocol}${hostname}${pathname}` };};const urlHttps = urlCurrying('https://');const url = urlHttps('www.abc.com','/123');console.log(url); // https://www.abc.com/123 123456const curry = f =&gt; a =&gt; b =&gt; f(a, b);const add = (a, b) =&gt; a + b;const minus = (a, b) =&gt; a - b;console.log(curry(add)(3)(4)) // 7console.log(curry(minus)(3)(4)) // -1 兩組物件，key值不同，但想取兩個物件裡的名字 1234567891011121314151617181920212223242526const girlList = [ {girl:'May'}, {girl:'Amy'}, {girl:'Tina'}, {girl:'Gina'},];const boyList = [ {boy:'Kevin'}, {boy:'Lyon'}, {boy:'Henry'}, {boy:'Pete'},];const curry = name =&gt; element =&gt; element[name];console.log(boyList.map(curry('boy')));console.log(girlList.map(curry('girl')));const curry = f =&gt; a =&gt; b =&gt; f(a, b);const getNames = (a, b) =&gt; { return a.map((i)=&gt;i[b])};console.log(curry(getNames)(boyList)('boy'));// [\"Kevin\", \"Lyon\", \"Henry\", \"Pete\"]console.log(curry(getNames)(girlList)('girl'));// [\"May\", \"Amy\", \"Tina\", \"Gina\"] 多組參數延遲輸入的應用若我們要實現f(a, b, c)、f(a)(b)(c)、f(a,b)(c)等多組不同參數帶入方式，但return出同樣的結果 1234567891011121314151617181920function add() { const args = [...arguments]; const inner = function() { args.push(...arguments); return inner; } //自己調用自己來實現重複輸入參數 //回傳的inner函式呈現方式是函式字串， //所以可以透過調用toString這個方法來實現回傳的結果。也叫做反柯里化 //反柯里化：透過隱式調用valueOf和toString方式結束延後執行 inner.toString = function(){ return args.reduce((a, b)=&gt;a + b); } return inner; }//但實際上回傳的值是function顯示成字串但typeOf去查看是functionconsole.log(add(1, 2, 3)); // 6console.log(add(1)(2,3)); // 6console.log(add(1)(2)(3)); // 6 別種解法回傳為 number，但無法帶入超過的參數 1234567891011121314151617181920212223function curry(func) { return function curried(...args) { if (args.length &gt;= func.length) { return func.apply(this, args); //當args陣列中的參數數量大於func函式的參數數量則直接執行func //若不成立的話則把參數和在一起再調用function curried } else { return function(...args2) { return curried.apply(this, [...args,...args2]); } } }}function add(a, b, c) { return a + b + c;}let curriedSum = curry(add);console.log(curriedSum(1, 2, 3)); // 6，args.length = func.length 正常調用console.log(curriedSum(1)(2,3)); // 6，第一個參數先柯理化console.log(curriedSum(1)(2)(3)); // 6，所有參數柯里化 柯里化非同步的應用123456789101112131415161718192021222324252627282930313233343536373839404142function fetchData(url, handler) { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); let result = JSON.parse(xhr.responseText); handler(result);}function showResult(result) { console.log(result); console.log(`${result[0].name.first}`);}const url = 'https://next.json-generator.com/api/json/get/EkcNtgkpY';fetchData(url, showResult);//使用currying後，寫法更簡便function curriedFetchData(url) { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); let result = JSON.parse(xhr.responseText); return function(_callback) { _callback(result); }}function showResult(result) { console.log(result); console.log(`${result[0].name.first}`);}const url1 = 'https://next.json-generator.com/api/json/get/EkcNtgkpY';const url2 = 'https://next.json-generator.com/api/json/get/NJB_fbk6F';const getData1 = curriedFetchData(url1);const getData2 = curriedFetchData(url2);getData1(showResult);getData2(showResult); 柯里化的一些觀念和缺點這邊參考了這篇文章提到的 大佬，JavaScript 柯里化，了解一下？ 優 currying的方式提升了函式的重複使用性。 缺 有其他解决方案。在JS中使用柯里化其實效能上較不好，例如操作dom的事件，但在差異沒有很大，在整個架構上看，差異可以忽略。像是用bind、箭頭函式可以解決。 currying是函數式的程式概念，若還沒準備好寫純正的函數式程式，有更好的替代方案，例如在JSX中綁定一次共同參數用bind或箭頭函式即可。JavaScript 並不是真正的函數式程式语言，相比 Haskell 等函數式程式语言，JavaScript 使用 Currying 等函數式特性有額外的性能開銷，也缺乏類型推導。把js寫的符合函數式程式的思想和規範的項目比較少，也限制了currying等技術在js中普遍使用。 lodashlodash提供了_.curry和_.curryRight(參數相反)的方法 123456789101112131415161718var abc = function(a, b, c) { return [a, b, c];}; var curried = _.curry(abc); curried(1)(2)(3);// =&gt; [1, 2, 3] curried(1, 2)(3);// =&gt; [1, 2, 3] curried(1, 2, 3);// =&gt; [1, 2, 3] // Curried with placeholders.curried(1)(_, 3)(2);// =&gt; [1, 2, 3] 123456789101112131415161718var abc = function(a, b, c) { return [a, b, c];}; var curried = _.curryRight(abc); curried(3)(2)(1);// =&gt; [1, 2, 3] curried(2, 3)(1);// =&gt; [1, 2, 3] curried(1, 2, 3);// =&gt; [1, 2, 3] // Curried with placeholders.curried(3)(1, _)(2);// =&gt; [1, 2, 3] 有興趣的話可看 lodash curry lodash curry原始碼 參考資料 Currying 大佬，JavaScript 柯里化，了解一下？ Functional-Light JavaScript 柯里化（Currying） Currying in JavaScript（柯里化） DRYing up JS with Function Currying","link":"/2020/12/25/currying/"},{"title":"[JS]關於解構賦值(Destructuring Assignment)","text":"前言剛開始接觸JS的時候，常常會很困惑解構賦值的寫法，這篇會來整理關於解構賦值的用法來幫助釐清觀念。 解構賦值 (Destructuring assignment)解構賦值 (Destructuring assignment) 語法是一種 JavaScript ES6的 運算式，可以把陣列或物件中的資料提取出來成為獨立變數。新語法讓程式變得簡短提高閱讀性。 在英文官方文件中提到使用方式如同鏡子般，對映出陣列或物件字面的結構。但沒有像鏡子左右相反。 The destructuring assignment syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and object literals. 陣列解構賦值123456789101112131415161718let a, b, rest;[a, b, ...rest] = [10, 20, 30, 40, 50]; //a = 10 , b = 20, rest = [30, 40, 50]const [a, , b,c] = [10, 20, 30] // 略過某些值 a = 10, b = 30 // 超過值得數量 c = undefinedconst a = 1, b = 2;[b, a] = [a, b]//互換變數值 a = 2, b = 1const [a, [b, [c, d]]] = [1, [2, [[[3, 4], 5], 6]]]// 多維複雜陣列 a = 1, b = 2, c = [3, 4], d = 5const str = \"hello\";const [a, b, c, d, e] = str// 字串則會拆解為字元帶入變數中 a = 'h', b = 'e' 物件解構賦值12345const {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};//a = 10 , b = 20, rest = {c: 30, d: 40}const {a, c} = {a: 10, b: 20, c: 30, d: 40};//a = 10 , c = 30//物件快速提取特定值，在JSON data上使用方便 一般常見的物件寫法 1234567const name = {first: 'Fred', last: 'Waterford'};const first = name.first;const last = name.last;//一般寫法const {first, last} = name;// 解構寫法 first = 'Fred', last = 'Waterford' 物件的解構賦值屬性名稱必須相互對應才能夠取得到值。上述用法算是簡寫，實際上寫法為 {屬性名稱:變數} 12345678910111213const name = { first: 'Fred', last: 'Waterford'}const {first:first, last:last} = name;// first = 'Fred', last = 'Waterford'const {first:a, last:b} = name;// a,b才是變數 a = 'Fred', b = 'Waterford'const {first1:a, last:b} = name;//若沒有對應值 a = undefined 混用物件或陣列解構賦值12const {a: x, b: [, y]} = {a: 5, b: [10, 100]}console.log(x, y) // 5, 100 解構賦值時給定預設值1234let [a, b, c = 4, d = 'Hello'] = [1, 2, 3];console.log(a, b, c, d); //c,d都給預設值，但c有賦值所以c=3，d則帶入預設值 // 1, 2, 3, \"Hello\" 搭配函式的傳入參數使用函式的參數使用解構賦值的方式，則能夠自訂變數名稱、順序、預設值 123456789101112131415const user = { id: 10, displayName: 'F. Waterford', fullName: { firstName: 'Fred', lastName: 'Waterford' }};function who({displayName: shortName, fullName: {firstName: name}, id}) { return `#${id} ${shortName}'s first name is ${name}`;}console.log(who(user));//#10 F. Waterford's first name is Fred 帶入預設值 1234567891011121314151617181920212223function func({a = 'Peter', b}) { return `${a} &amp; ${b}`}func({a: 'Ana', b: 'John'}); // Ana &amp; Johnfunc({b: 'John'}); // Peter &amp; Johnfunc({a: 'Ana'}); // Ana &amp; undefinedfunc({}); // Peter &amp; undefinedfunc('Ana', 'John'); //Peter &amp; undefinedfunc(); // Cannot read property 'a' of undefined//若整個參數有預設值則func()回傳結果與func({})相同function func({a = 'Peter', b}={}) { return `${a} &amp; ${b}`}func(); //Peter &amp; undefined//若整個參數有預設值為其他值，func()則回傳其值function func({a = 'Peter', b}={a: 'Ana', b: 'John'}) { return `${a} &amp; ${b}`}func(); //Ana &amp; John 框架的解構賦值React和Vue3都有類似的用法 1const { ref, reactive } = Vue; 123456789101112var React = require('react-native')var { StyleSheet, Text, TextInput, View, TouchableHighlight, ActivityIndicatorIOS, Image, Component} = React; 參考資料 MDN-解構賦值 從ES6開始的JavaScript學習生活 鐵人賽：ES6 解構賦值 [筆記] JavaScript ES6 中的物件解構賦值（object destructuring） [筆記] JavaScript ES6 中的陣列解構賦值（object destructuring）","link":"/2020/12/10/destructuringAssignment/"},{"title":"[JS] 同步非同步霧煞煞(上)-AJAX","text":"前言接觸Js一段時間後，開始學習如何串接API，剛開始時就直接先被介紹用了Axios這個好用的套件，但原理等等還是不能理解，因此看了很多文章文件，才摸索到原來同步,非同步,Event Queue,Ajax,XMLHttpRequest,fetch,promise,Async,Await等等之間的關聯性，才把觀念串通。這篇會來把我所認知的概念整理起來。 同步Synchronous與非同步AsynchronousJavascript是單執行緒 (single threaded)、同步(Synchronous) 的程式語言，一次只能做一件事，但為何google上很多人都說Javascript是非同步呢？其實是使用setTimeout、AJAX、Promise等而有非同步的特性，但其實這些方法並不是由javascript程式語言本身提供的，不受單執行緒限制，他們會被放到Event Queue中。 我們目前常用的Javascript執行環境有瀏覽器和Node.js。在瀏覽器上透過document來操作DOM，document也不是程式語言本身提供，而是瀏覽器，因此click這個事件監聽也是非同步特性。在瀏覽器上其他方法還有做AJAX的 XMLHttpRequest, fetch, Promise，計時用的setTimeout和setInterval。執行環境用 &lt;script src=\"all.js\"&gt; 引入在html上。而在Node.js上則有http可做Ajax寫伺服器, os, fs來控制檔案介面，同時也有SetTimeout。執行方式安裝node.js用node all.js來執行。 以前大學的暑假，曾經在美國的麥當勞工作過，櫃檯工作的流程就很像是非同步的模式。覺得中文翻譯過來的非同步很容易讓人誤解成不能同步工作。同步應該要翻成只能一步一步做，上一步會阻礙下一步(blocking特性)，非同步則為可以分開做…不會阻礙下一步(non-blocking特性)，同步非同步這個字義讓一開始的我一直搞混。 同步synchronous模式 櫃檯小姐把你要的餐點輸入點餐機: 起司漢堡一個、薯條一份 櫃檯小姐把Order傳送給漢堡流水線去要漢堡 等待漢堡完成 漢堡製作好了，櫃檯小姐給你 櫃檯小姐把Order傳送給薯條台去要薯條 等待薯條完成 薯條製作好了，櫃檯小姐給你 結帳 非同步Asynchronous模式櫃檯小姐 (Call Stack) 櫃檯小姐把你要的餐點輸入點餐機: 起司漢堡一個、薯條一份 櫃檯小姐把Order傳送給漢堡流水線去要漢堡 (WebAPIs Request) 櫃檯小姐把Order傳送給薯條台去要薯條 (WebAPIs Request) 櫃檯小姐幫你結帳 收到薯條台通知，薯條炸好了 結帳完成 櫃檯小姐沒事了，出餐口機器手臂把薯條給櫃檯小姐後，放在給你的餐盤上 (callback function) 收到廚房通知說漢堡做好了 櫃檯小姐沒事了，出餐口機器手臂把漢堡給櫃檯小姐後，放在給你的餐盤上 (callback function) 出餐完成 –廚房端和出餐口(Event Queue) 廚房端 (WebAPIs) 漢堡流水線和薯條台接收到櫃檯小姐的Order 各自開始製作，漢堡流水線中有人去上廁所需要3分鐘才會開始製作(setTimeout 3分鐘) 各部門製作好後各自送到出餐口去(response)，製作失敗(error) 出餐口 (Callback Queue or Task Queue) 薯條製作好了，等待櫃檯小姐拿取，但他好像還在忙喔！ 出餐口機器手臂(Event Loop)偵測到櫃檯小姐結帳完了沒事(Call Stack空了)，把薯條給櫃檯小姐 漢堡製作好了，等待櫃檯小姐拿取 出餐口機器手臂(Event Loop)偵測到櫃檯小姐給完薯條了沒事(Call Stack空了)，把漢堡給櫃檯小姐 以下例子取自Tommy大的教學，非同步最常見的例子，setTimeOut設定為0秒但還是會被排到Event Queue中等待console.log(‘C’)執行完後才會再執行，因此會得到 A C B的結果。 12345678910console.log('A');function run() { console.log('B');}setTimeout(run, 0);console.log('C');// A C B 下面這個例子，setTimeOut設定為3秒，下方接一個5秒回圈後執行C，在5秒的過程中setTimeout在經過3秒後便開始在WebApis端執行並把結果放在Callback Queue中，等C一執行完成後Call Stack空了，EventLoop變馬上把Callback Function放入Stack中，B則馬上跳出。 123456789101112console.log('A');function run() { console.log('B');}setTimeout(run, 3000);var start = Date.now();while (Date.now() - start &lt;= 5000) {} // 讓迴圈重複一直跑，5 秒後才跳出執行下段console.log('c');// A 經過5秒後 C B AJAX (Asynchronous JavaScript and XML)直接翻譯過來就是 非同步的 JavaScript 與 XML 技術，可以即時向伺服器傳送(request)並取回必須的資料(response)，XML則是一種早期比較常在用的資料格式，現在比較多人使用的是JSON格式，不知道這樣AJAX要不要改成AJAJ…XD 伺服器request的底層方法: XMLHttpRequest HTML5 Fetch API 衍生的request的library套件: jQuery Ajax axios 以下兩個網站都可以用來製作測試用的 API，也可以客製化 AJAX 成功後的回傳訊息。 Mocky: Real HTTP mocking Mockable.io 這邊會用隨機用戶產生器來做練習 隨機用戶產生器 XMLHttpRequest (可支援 IE 7 以上)原生的JS，但缺點是寫法會比較難閱讀和複雜 XMLHttpRequest DEMO 非同步 GET 請求AJAX 行為會被丟到 Queue，等取得回應後才回到 JS 執行緒。 1234567891011121314var xhr = new XMLHttpRequest();const url = 'https://randomuser.me/api/';xhr.addEventListener('load', function(){ const data = JSON.parse(this.responseText); console.log(this.responseText); console.log(this.status); //拿到 Http status code 狀態碼}); //xhr.onload = function(){ … }xhr.addEventListener('error', function(error){ console.log('錯誤', error);});//xhr.onerror = function(){ … }xhr.open('GET', url, true); //預設非同步true 可不寫xhr.send(); DEMO 同步 GET 請求12345678910console.log('start');var xhr = new XMLHttpRequest();const url = 'https://randomuser.me/api/';xhr.open('GET', url, false); //同步：false 非同步:truexhr.send();console.log(xhr.responseText);console.log('end');// 'start'// responseText// 'end' DEMO 非同步 POST 請求123456789// 如何把參數發送到後端var data = new FormData(); // 宣告 FormData 物件data.append('id', '5'); // 在 FormData 中塞入資料var xhr = new XMLHttpRequest();xhr.addEventListener('load', function(){ console.log(this.responseText);})xhr.open('POST', url);xhr.send(data); // 把帶有資料的 FormData 傳送到後端 12345678const xhr = new XMLHttpRequest();xhr.open('POST', url);xhr.setRequestHeader('Content-type', 'application/json');xhr.send(JSON.stringify(user));xhr.onload = function () { const res = JSON.parse(xhr.response); console.log(res.message);}; HTML5 Fetch API (IE 11 以下都不支援)MDN文件 ES6的新語法，搭配 Promise 作回應，支持 async/await.then()接續.catch()接收錯誤，回傳的是 ReadableStream 物件，需要使用不同資料類型(json,blob)使用對應方法，才能正確取得資料物件。 但使用上也有一些需要注意的： IE 11以下都不支援 回傳的 promise 不會 reject HTTP 的 error status，就算是 HTTP 404 或 500 也一樣。相反地，它會正常地 resolve，並把 ok status 設為 false。會讓它發生 reject 的只有網路錯誤或其他會中斷 request 的情況，需要封裝去處理。 預設是沒有帶cookie，需要新增配置項。 不支援超時控制，使用setTimeout及Promise.reject的實現的超時控制並不能阻止請求過程繼續在後臺執行，造成了量的浪費。 不支援原生監測請求的進度，而XHR可以 Fetch 常用的 Request 屬性url: 第一個參數，一定要填的項目，代表需要 fetch 對象的網址method: GET、POST、PUT、DELETE、HEAD ( 預設 GET )headers: 要求相關的 Headers 物件 ( 預設 {} )mode: cors、no-cors、same-origin、navigate ( 預設 cors )referrer: no-referrer、client 或某個網址 ( 預設 client )credentials: omit、same-origin、include ( 預設 omit )redirect: follow、error、manual ( 預設 manual )cache: default、no-store、reload、no-cache、force-cache ( 預設 default )body: 要加到要求中的內容 ( 如果 method 為 GET 或 HEAD 則不設定 ) Fetch 常用的 Response 屬性headers: 包含與 response 相關的 Headers 物件ok: 成功回傳 true，不成功回傳 falsestatus: 狀態代碼，成功為 200statusText: 狀態文字，成功為 oktype: response 的類型，例如 basic、cors…等url: response 的 url ReadableStream 物件Fetch API 的 回傳為 ReadableStream 物件，我們無法直接讀取資料內容，而 ReadableStream 物件中可用以下對應的方法來取得資料 (https://developer.mozilla.org/zh-TW/docs/Web/API/Body)： arrayBuffer() 返回 Promise，Buffer，代表一段記憶體區塊，僅能透過 View 操作其內容。formData() 返回 Promise，取得的資料格式將會是formData格式json() 返回 Promise，取得的資料格式將會是JSON格式text() 返回 Promise，取得的資料格式將會是純字串blob() 返回 Promise，可以將資料轉為blob物件，像是圖片就可以做這樣的轉換(這裡的圖片並非指圖片路徑，而是圖片檔案本身)。 clone() 建立 Response 的複製物件error() 返回 Response 的錯誤物件 123456789101112// unsplash 上的圖片let url = 'https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&amp;fit=crop&amp;w=634&amp;q=80'fetch(url) .then((response) =&gt; { return response.blob(); }) .then((imageBlob) =&gt; { let img = document.createElement('IMG') document.querySelector('.newImg').appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); }) Fetch DEMO 發送 GET 請求12345678910const url = 'https://randomuser.me/api/';fetch(url).then(response =&gt; { //預設method:get // 這裡會得到一個 ReadableStream 的物件 return response.json(); // 可以透過 blob(), json(), text() 轉成可用的資訊}).then(data =&gt; console.log(data);) // 取得資料.catch((err) =&gt; { console.log('錯誤:', err); Fetch DEMO 發送 POST 請求1234567891011// 把資料參數傳到後端，一樣要先宣告 FormDatavar data = new FormData();data.append('id', '5');fetch('url', { method: 'POST', body: data, }) // 如果是傳遞「中文」可能會出現亂碼，這時可以使用encodeURI來做轉碼，且要透過JSON.stringify來轉換成 string 方式傳遞。 encodeURI(JSON.stringify()).then(response =&gt; response.json()) // 解讀JSON格式.then(data =&gt; console.log(data)) // 取得資料 123456789101112131415161718let url = `https://hexschool-tutorial.herokuapp.com/api/${type}`;let user = { email: document.querySelector(`#email_${type}`).value, password: document.querySelector(`#password_${type}`).value,};fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(user), }) .then(response =&gt; response.json()) .then(data =&gt; { console.log(data); }) .catch(err =&gt; console.log(err)); jQuery Ajax以XMLHttpRequest為基礎的library，使用簡單，但jQuery本身是針對MVC的程式設計，不符合現在前端MVVM的浪潮，因為現在有許多新的原生語法可取代JQuery，若單純只是使用Ajax卻引入整個jquery不太合理。 DEMO 發送 GET 請求123456789101112$.ajax({ type : \"GET\", //預設get，如果要使用 POST 方法則換成POST url: 'https://randomuser.me/api/', dataType: 'json', success: function(data) { console.log(data); }, error : function(error){ console.log(error.status); console.log(error.responseText); }}); 12345$.ajax({ url: 'https://randomuser.me/api/'}).done(function(res){ console.log(res);}); axiosaxios 本質上也是對原生的 XMLHttpRequest 封裝，從 node.js 建立 http 請求，並可以支援 Promise，可取消請求(Promise無法)，自動轉換JSON檔，客戶端支援防止CSRF，提供了一些併發請求的介面，axios 實體建立 DEMO 發送 GET 請求12345678const url = 'https://randomuser.me/api/';axios.get('url').then(function (response) { console.log(response);}).catch(function (error) {console.log(error);}); DEMO 發送 POST 請求12345678const url = 'https://randomuser.me/api/';axios.post('url').then(function (response) { console.log(response);}).catch(function (error) {console.log(error);}); 執行多個併發請求12345678910function getData1() {return axios.get('url1');}function getData2() {return axios.get('url2');}axios.all([getData1(), getData2()]).then(axios.spread(function () {// 兩個請求現在都執行完成})); 參考資料 JavaScript Fetch API 使用教學 JavaScript 中的同步與非同步 麥克的半路出家筆記 一起來把煩人 XMLHttpRequest 變成 Fetch 怎麼樣？ 邁向 JavaScript 勇者之路 重新認識 JavaScript ES6 入門手冊(較於艱深)","link":"/2020/11/06/eventQueue/"},{"title":"[Tools] 前端自動化管理 About Gulp 4.0","text":"前言接觸前端一段時間，很常聽到Gulp這個自動化管理工具，但一直沒仔細去了解它，這篇會整理Gulp的一些觀念和用法。 用Gulp要做什麼？Gulp為一個自動化管理工具，把來源(src)編譯、合併(concat)、壓縮(uglify)、輸出(dest)成瀏覽器可以讀懂的或是效能更好的檔案。類似的工具還有Grunt和很熱門的Webpack。 Gulp的來源資料可以有很多配合不同的套件去處理，像是編譯SASS/SCSS成CSS，編譯pug成html，JS es6版編譯成ES5，壓縮css、js、圖檔，編譯程式規範，跑測試，Live Server等 Gulp 和 Webpack 比較Gulp：偏向命令式，編譯Task都需手動編寫。在以模組化架構的大型SPA上，gulp搭配外掛可以勉強處理但是還是有許多不足，優化載入速度上因gulp是對靜態資源做流式處理，處理後還有很大的優化空間。 Webpack：偏向設定，設定有一定的規範，接手別人專案容易，可以將許多鬆散的模組按照依賴和規則打包成符合生產環境部署的前端資源。在模組化的處理較優，因此webpack現在為比較熱門的打包工具。 比較圖 會另外開一篇整理Webpack的用法。這篇則專心在gulp上。 Gulp 安裝安裝Gulp前，因為是基於Node.js開發，當然先需要Node.js，這邊就不詳細介紹。npm管理工具會隨著node.js一起安裝好，接著我們可以用npm安裝gulp到全域環境。 npm install gulp -g 專案初始化生成package.jsonnpm init 在專案內安裝gulp 使用–save會把模組加到dependencies執行專案時用，–save-dev則會添加到devDependencies給開發專案時使用。 npm install gulp --savenpm install gulp --save-dev 查詢gulp版本gulp --version Gulp用法這邊會需要先建立gulp的設定檔 gulpfile.js可創建為一個資料夾或是單一個檔案在根目錄。 常用的 Gulp APIgulp.task() 定義任務gulp.src() 定義來源gulp.dest() 定義輸出路徑gulp.watch() 監控gulp.pipe()水管XD 顧名思義就是一個管道可以一個接一個，裡面再帶入要做什麼，流的概念 這邊以編譯SASS成CSS為例，需要再安裝編譯sass套件 gulp-sassnpm install node-sass gulp-sass --save 主要會用gulp 4.0的版本的寫法，Common JS 12345678910111213141516const gulp = require('gulp');const sass = require('gulp-sass');// 載入 gulp 和 gulp-sass 套件function sassTask() { // 任務名稱 return gulp.src('./source/scss/**/*.scss') // 來源 .pipe(sass().on('error', sass.logError)) // 使用 gulp-sass 進行編譯 .pipe(gulp.dest('./public/css')); // 輸出路徑}function watchSass() { gulp.watch('./source/scss/**/*.scss', gulp.series(sassTask)); // 監控來源下scss的變化，有變化便執行sassTask}exports.default = gulp.series(sassTask, gulp.parallel(watchSass)); 任務執行方式若是同時有很多要執行的任務，則有兩種執行方式 gulp.series()任務依序執行，前一個結束才執行下一個 gulp.parallel()包在parallel的任務都同步執行，不管其他任務結束與否 集體任務輸出指令exports.指令名稱，在終端機執行 gulp 或 gulp default則會執行 default 1exports.sassOnly = gulp.series(sassTask); gulpgulp sassOnly 結語以上就是gulp的一些基礎用法，gulp還有其他一堆套件去對應不同功能，選擇專案需要的安裝即可，就不在這篇一一介紹了。 常用的套件有：編譯 ES6: gulp-babel編譯 SASS: gulp-sass編譯 POST CSS: gulp-postcss + autoprefixer 或是 gulp-autoprefixer編譯 pug: gulp-pug壓縮優化 CSS: gulp-cssnano壓縮檔案: gulp-uglify minimist 搭配gulp-if在不同環境壓縮壓縮圖片: gulp-image合併檔案JS, CSS: gulp-concat自動刪除檔案: gulp-clean瀏覽器同步顯示: browser-sync簡化gulp，簡單說就是原本要寫一堆require套件(gulp-開頭的)簡化成一行: gulp-load-plugins自動上到github Pages: gulp-gh-pages重新命名檔案: gulp-rename例外處理: gulp-plumber生成SourceMap: gulp-sourcemaps 還有一堆可到官方網站去找喔！ GulpJS plugins 參考資料 GulpJS 官方文件 前端構建工具——Webpack vs Gulp Gulp套件介紹 [Tool Notes] — 關於Gulp 這是在講 Gulp 不是飲料是任務自動化工具這件事","link":"/2020/12/11/gulp/"},{"title":"[JS 60 Days] Day 11 to Day 35 - JS函式陣列","text":"Introduction接續上篇，這邊開始第11天 JS函式陣列 Day 11 - 函式參數再練習 Day 12 - DOM 操作 Day 13 - 函式+if 判斷 Day 14 - 監聽與函式設計 Day 15 - 物件運用 - 資料與渲染分離 Day 16 - forEach 與 HTML 字串累加 Day 17 - innerHTML+forEach Day 18 - 字串相加 innerHTML+ 樣式搭配 Day 19 - 驗收前夕 Day 20 - BMI 計算機團戰關卡 Day 21 - BMI 追加功能 Day 22 - BMI 陣列調整 Day 23 - 資料格式處理，陣列 unshift Day 24 - 資料格式處理，forEach + 陣列處理(一) Day 25 - 資料格式處理，forEach + 陣列處理(二) Day 25-2 - OpenData資料處理 Day 26 - AJAX、axios 題目 Day 26-2 - AJAX、axios 全台展覽資訊站 Day 27 - 陣列補充觀念 Day 28 - 陣列排序進度 Day 29 - 監聽切換排序功能 Day 30 - C3.js 圖表整合 Day 31 - 部落格文章閱讀 Day 32 - 程式整合篇 Day 33 - 圓餅圖分析 Day 34 - 圓餅圖分析(中文字串判別) Day 35 - 圓餅圖與長條圖合併使用 Day11函式參數再練習題目一：老闆想要隨時扣你的薪水老闆：「今天是發薪日，先發給你薪資 23500 元(遞給小杰」老闆：「以下三步驟動作請寫成程式」老闆：「步驟一：昨天你上廁所太久了，我要扣你 1000 元」老闆：「步驟二：小黑說不喜歡你煮的狗食，我要再扣你 3500 元 (再次取走」老闆：「步驟三：我今天心情不太好，扣個 500 元意思一下」小杰：「屁啦！心情不太好關我啥事！」老闆：「這不是重點，快點算！將之前的寫法換成函式，並增加一個參數，讓我方便何時扣你多少都沒問題」老闆：「最後你寫的函式，要執行三次，每次都要回報你的總薪水剩下多少。」 12345678910var salary = 23500;function deduct(num){ salary = salary - num; console.log(\"小杰目前還剩下\"+salary+\"元\");};deduct(1000);deduct(3500);deduct(500); 題目二： if + 指派運算子老闆：「好了，現在我要告訴你贈品條件！」 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品 下圖為第八關截圖，請依照以下邏輯進行改寫： 現在來了三個客人，並依序有消費，A顧客消費 150、B 顧客消費 99、C 顧客消費 110。 請設計一個函式，裡面代入一個參數為顧客消費金額，確認該客戶是否符合贈品條件，若符合就讓 giftNum 變數減少數量。 並依序執行三次函式，每次函式皆會 return 目前贈品數量剩下多少。 123456789101112131415161718192021// 贈品數量 var giftNum = 3;var customerA = 150; // 顧客 A 消費金額var customerB = 99; // 顧客 B 消費金額var customerC = 110; // 顧客 C 消費金額function gift(num){ if(num &gt;= 100 &amp;&amp; giftNum &gt; 0){ giftNum -= 1; console.log(\"目前贈品剩下\"+giftNum+\"個\"); } else if(num &lt; 100){ console.log(\"消費不夠沒有贈品\"); } else{ console.log(\"沒有贈品了\"); };};gift(customerA);gift(customerB);gift(customerC); 題目三：if+指派運算子老闆：「我現在補齊給你總計 200 個贈品！」老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」小杰：「老闆你竟然利用我的特休，我跟你沒完啦。」老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」 下圖為第八關截圖，giftNum 已改為 200 份，請依照以下邏輯進行改寫： 請用函式改寫，同時來了三組客人，請用你寫的函式連續執行三次，來幫助顧客是否有符合贈品條件。 另外每次執行函式時，都必須告訴老闆一次目前贈品數量。 第一組客人：Mary 買了 10 份薯條，10 份漢堡第二組客人：Bob 買了 1 份薯條第三組客人：Tim 買了 20 份薯條，15 份漢堡 123456789101112131415161718192021222324252627var giftNum = 200; // 贈品數量var friesPrice = 30; // 薯條單價var hamburgerPrice = 50; // 漢堡單價let total;// 以下是題目// mary買了10份薯條,10份漢堡// 請計算完贈品規則後,善用指派運算子去計算目前剩下的贈品有幾個// 並用下面的 if 回報給老閱function gift(friesNum, hamburgerNum){ total = friesNum * friesPrice + hamburgerNum * hamburgerPrice if(giftNum &gt; 0){ if(total &gt;= 50){ giftNum = giftNum - Math.floor( total / 50 ); console.log(\"老閱!贈品還夠!剩下\"+giftNum+\"個~\"); } else{ console.log(\"客人消費不夠沒有贈品\"); }; } else{ console.log(\"老闖贈品賣光啦~\") };};gift(10, 10);gift(1);gift(20, 15); Day12DOM 操作題目 請觀看此 Codepen 的線索，試圖找到密碼，並回傳密碼 以下 Codepen 的 HTML 與 CSS 面板都壞掉了，你只能編輯 JS 面板，來去尋找線索 123456789101112131415161718&lt;div class=\"key\"&gt;&lt;!-- 區塊一 --&gt; &lt;div class=\"keyItem keyItem1\" &gt; &lt;img src=\"https://hexschool.github.io/JSTraining/stage12/4.png\" alt=\"\"&gt; &lt;/div&gt;&lt;!-- 區塊二 --&gt; &lt;div class=\"keyItem keyItem2\"&gt; &lt;img src=\"https://hexschool.github.io/JSTraining/stage12/2.png\" alt=\"\"&gt; &lt;/div&gt;&lt;!-- 區塊三 --&gt; &lt;div class=\"keyItem keyItem3\"&gt; &lt;/div&gt;&lt;!-- 區塊四 --&gt; &lt;div class=\"keyItem keyItem4\" style=\"\"&gt; &lt;/div&gt;&lt;/div&gt; See the Pen zYBRgGR by KaiYun Cheng (@kaiyuncheng) on CodePen. 密碼為3345678 Day13函式+if 判斷以下為 BMI 計算方式： BMI 計算為：體重(公斤) / 身高的平方(單位為公尺) 例如 150 公分 50 kg = 50/(1.5*1.5) = 22.2 BMI 指數 BMI 數值狀態如下 體重過輕：BMI ＜ 18.5 正常：18.5≦BMI＜24 過重：24≦BMI＜27 輕度肥胖：27≦BMI＜30 中度肥胖：30≦BMI＜35 重度肥胖：BMI≧35 目前現況小杰打開 Code 才發現，裡面的 if 判斷根本都在亂寫，請依照上面的 BMI 狀態來改寫，並還小杰一個清白。 請修改此 Codepen 解題 1234567891011121314151617function calculationBMI(height,kg){ let bmi = kg/(height/100*height/100); if(bmi &gt;= 35){ return \"重度肥胖\"; }else if(bmi &gt;= 30){ return \"中度肥胖\"; }else if(bmi &gt;= 27){ return \"輕度肥胖\"; }else if(bmi &gt;= 24){ return \"過重\"; }else if(bmi &gt;=18.5){ return \"正常\"; }else{ return \"體重過輕\"; };};console.log(calculationBMI(178,70)); Day14監聽與函式設計小杰打開網頁後，發現工讀生只把 HTML 標籤寫好，JS 完全沒寫，因為 HTML 面板已經壞掉了，請直接修改 JS Code，讓 .total 的顯示數值，可以正常運作。 BMI 2.0版 Codepen 網址 提示 利用 原生 的 function 觀念寫一個 BMI 計算機 See the Pen QWEmgaL by KaiYun Cheng (@kaiyuncheng) on CodePen. Day15物件運用 - 資料與渲染分離以下是護理師改寫小杰的邏輯，程式碼連結 護理師拿了之前工讀生的 Code 改寫，根本沒用小杰的。但可以看得出來，這個 Code 有刻意遺留了些不完整的地方，像是 bmiData 的物件沒有將條件寫完整，頗有想要再次考驗小杰的味道。 請各位將你們的 Code 跟護理師的進行比較，看看差異在哪裡，並透過 Slack 分享自己吸收的結果，並試著依照自己的邏輯寫一遍。 這次 HTML 面板壞掉了，你唯一可以改的面板只有 CSS 與 JS 面板。 主要運用 關注點分離：資料與畫面 See the Pen MWeVEgB by KaiYun Cheng (@kaiyuncheng) on CodePen. Day16物件運用 - forEach 與 HTML 字串累加問題小杰一時間還不知道怎麼寫，所以先寫了陣列 + forEach 的方式來累加 HTML 字串，再來顯示介面出來。範例程式碼 請你依照這邏輯，試著改寫物件格式，呈現的格式如下程式碼。 設計好物件後，依序 push 五筆資料到陣列裡，最後整理完字串資料，再 innerHTML 到 ul 裡。 這次 HTML 與 CSS 面板都壞了，請改寫 JS 面板。 PS:請拿上面的 Codepen 改寫即可，不需拿前幾關的 code 來整合 1234&lt;ul&gt; &lt;li&gt;小杰的身高為 178 公分，體重是 70 公斤，BMI 數據為 20，狀態為正常&lt;/li&gt; &lt;li&gt;小美的身高為 150 公分，體重是 200 公斤，BMI 數據為 38，狀態為超重&lt;/li&gt;&lt;/ul&gt; See the Pen LYZdddO by KaiYun Cheng (@kaiyuncheng) on CodePen. Day17物件運用 - innerHTML+forEach問題明明陣列裡面有五筆資料，但寫出來的程式碼，列表永遠只顯示一筆資料，究竟小杰哪裡觀念有問題呢？一起來幫助小杰吧~ 問題回覆請思考並在 Slack 回覆： str 放 forEach 外頭跟裡面的差異A: forEach會讓data裡的物件都跑一次，str=’’放在裡面會表示每跑一次item，str就又變成空字串。 innerHTML 放 forEach 外頭跟裡面的差異A: innerHTML放外頭，就只會跑一次，若在forEach後，直接呈現最後總合的str和放在裡面多次覆蓋後結果相同。 innerHTML 當要寫內容進去時，會不會將裡面內容給覆蓋掉？A: 會 Day18物件運用 - 字串相加 innerHTML+ 樣式搭配問題挑戰者們不要忘了，JS 始終要搭配妳寫好的 CSS 來進行渲染，護理師好像已經看膩了小杰爛到不行的陽春版本，寫了一個 .list2 版本，請依照他的 CSS 樣式邏輯，將 data 陣列裡面的資料，依序渲染到 .list2 裡面的 li 來顯示。 護理師的 Codepen 網址 See the Pen pobLVjN by KaiYun Cheng (@kaiyuncheng) on CodePen. Day19驗收前夕問題小杰打開師傅的程式碼，才發現這程式碼其實是來自於 Vic 這位工程師的範例程式碼。 雖然跟設計稿有非常大的差異，但從程式邏輯中，慢慢掌握到了一些概念。 請解讀 Vic 的(程式碼)，並在 Slack 上回報他以下邏輯是做了什麼事情： arrayBMIrecord 的陣列用途是什麼？A: 儲存每次計算出bmi的資料記錄 請描述 calculateBMI 函式做了什麼事情A: 取得身高體重的值轉成數字，用來計算bmi，判斷屬於過重或是正常等值，並記錄到userRecord變數上，最後把userRecord記錄到arrayBMIrecord 的陣列裡後，執行render，清空輸入值。 請描述 render 函式做了什麼事情A: 處理畫面的渲染，把arrayBMIrecord陣列裡的每筆資料取出，並記錄到str上，並渲染到畫面上。 Day20BMI 計算機團戰關卡Day21BMI 追加功能Day22BMI 陣列調整這三天都是在做BMI計算機因此寫在一起。第20天是完成BMI計算機的切版畫面與JS的程式，第21天是追加幾筆紀錄與平均功能，第22天是做陣列反轉reverse和unshift。 畫面上我自行做了桌機上兩欄手機畫面一欄的設計，右側欄為紀錄區可以向下捲動，紀錄上同時有時間標記與不同BMI呈現不同顏色。 DEMO Day23資料格式處理，陣列 unshift問題小杰一看到題目整個傻眼，裡面用了他從來沒看過的圖表資料，好在老闆在程式碼裡面寫了些註解，讓小杰知道自己不需要懂圖表框架，好好的把資料處理好後，圖表自然就會顯示正常，一起來幫幫小杰吧！ 以下是預期希望出現正常的圖表，請改寫PS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板 See the Pen GRqdGJp by KaiYun Cheng (@kaiyuncheng) on CodePen. Day24資料格式處理，forEach + 陣列處理(一)問題以下是預期希望出現正常的圖表，請改寫：PS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板 See the Pen MWeGBwR by KaiYun Cheng (@kaiyuncheng) on CodePen. Day25資料格式處理，forEach + 陣列處理(二)問題以下是預期希望出現正常的圖表，請改寫PS：HTML 與 CSS 面板壞掉了，只能變更 JS 面板 See the Pen KKMRBMJ by KaiYun Cheng (@kaiyuncheng) on CodePen. Day25-2OpenData資料處理這是練習整理OpenData資料，並篩選要的資訊呈現於畫面上，這次選擇新北市政府資料開放平臺上的動物之家資料來做整理，篩選出新店區的地址。 See the Pen 新北市公立動物之家Json by KaiYun Cheng (@kaiyuncheng) on CodePen. Day26AJAX、axios 題目問題試著撈他提供的這隻 API，撈出所有的姓名列表，至少先做個雛形讓客戶安心。範例如下圖。 See the Pen rNLvPav by KaiYun Cheng (@kaiyuncheng) on CodePen. Day26-2AJAX、axios 全台展覽資訊站同樣運用axios的方式撈資料，這次我選擇文化部的展覽資訊這個api，簡單設計和製作了卡片式畫面，並加上了過濾縣市的功能。 DEMO Day27陣列補充觀念問題請從以下連結，學習 2~3 種陣列的處理方式，聽說 sort 就蠻常見的，並回報自己的範例程式碼與學到的東西。 Cheatsheet for Array Methods - JavaScript 陣列方法大全 JavaScript Array 陣列操作方法大全 ( 含 ES6 ) JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()] 這邊練習了copyWithin() : 有點像是複製貼上取代的概念，貼上會取代掉原本位置的元素參數1(必填)：從第幾個開始貼上取代參數2(選填 預設0)：從第幾個開始複製參數3(選填 預設陣列長度)：複製到第幾個前（不包含這一個） 1234567let ary = [1, 2, 3, 4, 5];ary.copyWithin(1);console.log(ary); //[1, 1, 2, 3, 4] 5 超過陣列長度，所以不會出現ary.copyWithin(2, 1, 3);console.log(ary); //[1, 2, 2, 3, 5] 複製2,3 從索引2也就是3的位置開始取代 Day28陣列排序進度這次客戶希望他們的內容可以做完課率排名功能，試著撈客戶提供的這隻 API，撈出資料後，依照每個物件的 process 來進行進度排序，範例格式如下圖。 1234&lt;ul&gt; &lt;li&gt;第 1 名是廖洧杰，他的特訓班完成度是 33%&lt;/li&gt; &lt;li&gt;第 2 名是王小明，他的特訓班完成度是 30%&lt;/li&gt;&lt;/ul&gt; See the Pen WNxKdMV by KaiYun Cheng (@kaiyuncheng) on CodePen. Day29監聽切換排序功能問題禿頭俠又提到，客戶希望能夠針對 select 切換排序方式，還請依照以下 範例來設計。 12345678910111213141516&lt;select&gt; &lt;option value=\"id\"&gt;依照 id 編號排序(由1開始從上往下)&lt;/option&gt; &lt;option value=\"process\"&gt;依照完課率排序(由最高到最低)&lt;/option&gt;&lt;/select&gt;// 以下為編號排序範例&lt;ul class=\"list\"&gt; &lt;li&gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %&lt;/li&gt; &lt;li&gt;編號 ID 2 為王小明，他的完成進度為 33 %&lt;/li&gt;&lt;/ul&gt;// 以下為完課率排序範例&lt;ul class=\"list\"&gt; &lt;li&gt;編號 ID 2 為王小明，他的完成進度為 33 %&lt;/li&gt; &lt;li&gt;編號 ID 1 為廖洧杰，他的完成進度為 5 %&lt;/li&gt;&lt;/ul&gt; See the Pen WNxKdMV by KaiYun Cheng (@kaiyuncheng) on CodePen. 文件資源 [JS] 事件筆記（上） jQuery 筆記 - 讓網頁回到最頂點寫法 js取float型小數點後兩位數的方法 DOM Event 觸發事件 change - 表單內容更動內容時觸發 | Saffran’s Blog Day30C3.js 圖表整合這次的題目是希望用長條圖呈現完課率 長條圖C3.js 圖表整合文件 問題 這次的需求是「 用 c3.js 圖表顯示，看看誰的完課率最好，同時可以看出排名** 圖表不局限於上面的長條圖，也可尋找合適的圖 這邊我以長條圖方式呈現，把api回傳的資料， 用forEach依選擇的排列方式，把名字和完課率依序傳入到各自的新陣列，再把完課率陣列綁定到c3js圖表的data.columns裡，而名字綁定到x軸的categories上，畫面便可呈現。 See the Pen C3j 長條圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day31部落格文章閱讀這裡我推薦近期很常看的blogTimCodingBlog馬格蕾特的樹洞 Day32程式整合篇把Day29和Day30的兩個呈現方式合併 See the Pen C3j 長條圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day33圓餅圖分析問題客戶說，他在 C3.js 看到這個圓餅圖圖表，他想要我們透過 API 來觀察，尚未開賽跟已開賽的比例佔多少，一起來幫幫小杰吧！ See the Pen 圓餅圖 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day34圓餅圖分析(中文字串判別)問題客戶說，他想要觀察每個參賽者的「姓名長度的字元數」，規則如下： 如何判斷字元數量，請將你找到的部落格文章放到此處提供給其他勇者參考 判斷中英文字元長度 正規表示式除字串中所有標點符號 如果中文取代 **,注意正規表示 * 要刪掉避免錯誤 正則表達式的規則 - 這邊只要注意特殊字符有哪些即可 正則表達式介紹 使用 String.prototype.charCodeAt() 判斷字元是中文或英文 - 判斷字元是否超過 255 超過即代表為中文(缺點為需要把字元一個一個拆開) replace() 方法 - 講解 replace() 的用法 正則匹配範例 See the Pen 姓名長度的字元數 by KaiYun Cheng (@kaiyuncheng) on CodePen. Day35圓餅圖與長條圖合併使用問題客戶想優化完課率的圖表設計，他想要同時顯示長條圖與圓餅圖，並顯示各區間完課率人數，小杰花了很多時間將圖表整合起來了，範例連結，但他卻不知道怎麼把 API 資料放進去，一起幫幫小杰吧！ See the Pen MWezvqd by KaiYun Cheng (@kaiyuncheng) on CodePen.","link":"/2020/10/28/js60Day11toDay35/"},{"title":"[JS] 箭頭函式 Arrow Functions 和 this","text":"前言箭頭函式(Arrow Functions)是一個ES6的新語法，對我來說前前後後接觸js，一直有碰到this，但要詳細解釋還是很難，因此想藉由這篇讓我更加深this的觀念，會整理出this在箭頭函式的差別與其他this的觀念。另外感謝Kuro大的文章，讓我更容易了解this，分享連結在下面。 箭頭函式(Arrow Functions)箭頭函式(Arrow Functions)是一個ES6的新語法，與傳統function類似，有點像是傳統function更簡短寫法，但沒有 arguments 參數，this上也有差別。 1234567891011121314151617181920212223242526//傳統函式let helloName = function(name) { return `hello, ${name}`;}// 箭頭函式var helloName = (name) =&gt; { return `hello, ${name}`;}// 單一行陳述則可以不加 {}var helloName = (name) =&gt; `hello, ${name}`;// 只有一個參數則可以不加 ()var helloName = name =&gt; `hello, ${name}`;console.log(helloName('John'));// 沒有任何參數時則必須加 ()var helloName = () =&gt; `hello`;// 有{}時 必須加上return，否則沒有回傳功能var helloName = name =&gt; { `hello, ${name}`; // return `hello, ${name}`;} console.log(helloName('John')); //undefined 關於this傳統函式 this不等於functionthis是傳統函式function執行時，自動生成的一個內部物件。隨著執行呼叫場合的不同，所指向的值也會不同。 &gt; 預設綁定(Default Binding) this 指向全域物件當沒有特定指明 this 的情況下，預設綁定 (Default Binding) this 為 「全域物件」，也就是 window。 直接執行呼叫函式 Simple Call無論把function宣告在哪邊，只要是一般的Simple Call，this指向為 全域物件window。 立即函式(IIFE)理論上也是直接呼叫，this也是指向全域 非同步的事件 (setTimeout, Ajax等)中callback function 的this也是指向全域。 &gt; 隱含的綁定(Implicit Binding) 透過物件執行呼叫函式透過物件執行函式時，this指向為該物件。 12345678910var obj = { fn1: function(){ console.log(this); var fn2 = function(){ console.log(this); //this 為 window }; fn2(); //Simple Call }};obj.fn1(); //透過物件執行呼叫函式 this 為 obj 若宣告嚴格模式的話(use strict)，會禁止 this 自動指定為全域物件，this則會變成 undefined。 1234567891011var obj = { fn1: function(){ \"use strict\"; console.log(this); var fn2 = function(){ console.log(this); //undefined }; fn2(); }};obj.fn1(); 透過DOM物件來呼叫function時，this也是同樣指向該DOM物件(event.currentTarget) See the Pen DOM this by KaiYun Cheng (@kaiyuncheng) on CodePen. 重新指向 thisvm, that, self非同步的事件 (setTimeout, Ajax等)中 callback function 的this指向全域window，因此若我們需要把this指回DOM物件，一般常見的作法是用一個變數(vm, that, self)來代替要指回的this See the Pen PozgBWe by KaiYun Cheng (@kaiyuncheng) on CodePen. &gt; 明確綁定(Explicit Binding) bind(),call(),apply()bind()在function後面加上 .bind(this) 就可以強制將 () 內的物件帶入至 callback function 內 See the Pen bind by KaiYun Cheng (@kaiyuncheng) on CodePen. 1234567891011let familyBaker = { mom: 'Nicole Baker', dad: 'Tom Baker'};let familyName = function () { console.log(this.mom);};familyName(); // 未指定this 則會指向全域familyName.bind(familyBaker)(); //指向Baker ㄧ家 Nicole Baker call()apply() 在function後面加上 .call() 或 .apply()來呼叫function，指定第一個帶入的參數作為該function執行呼叫時的this，兩者的差別只在於參數寫法，第一個都是指定this，.call()的第2.3.4…個參數用逗號隔開。.apply()第二個參數為陣列，陣列則可以帶入好幾個參數。 123456function add(a, b) { return a + b;}console.log(add(1, 2)); // 3console.log(add.call(null, 1, 2)); // 3, this = nullconsole.log(add.apply(null, [1, 2])); // 3, this = null 12345678910111213var animals = [ {species: 'Lion', name: 'King'}, {species: 'Whale', name: 'Fail'}];for (var i = 0; i &lt; animals.length; i++) { (function (i) { this.print = function () { console.log('#' + i + ' ' + this.species + ': ' + this.name); } this.print(); }).call(animals[i], i); //參數1綁定animals[i]為this} &gt; new 綁定 - 建構式的調用 (As a constructor)當一個 function 前面帶有 new 被呼叫時，會發生： 會產生一個新的物件 (物件被建構出來) 這個新建構的物件會被設為該function this的綁定目標，也就是 this 會指向新的物件。 除非這個 function 指定回傳 (return) 了他自己的替代物件，否則這個透過 new 產生的物件會被自動回傳。 123456789101112var mom = '媽咪'function findMom (name) { this.mom = name console.log(this); console.log(this.mom);}findMom('AAA'); //this會指向到全域 全域的mom會替換成AAAvar newFindMom = new findMom('BBB'); //建構了一個新物件 並把this指向newFindMom console.log(newFindMom.mom); // BBB 箭頭函式 this回到上面說的箭頭函式，this會依據語彙環境的父層區域(parent scope)來綁定。簡單的說法是，箭頭函式沒有this，this指向往上一層找，一般若上層為預設綁定(Default Binding)，則指向全域window。 舉例 四種找媽函式 呼叫方式皆為family物件中呼叫 family.findMom1(); 12345678910111213141516171819202122232425262728293031323334353637383940414243var findMom1 = function () { console.log(this.mom); //區域媽咪 傳統函式this指向family setTimeout(function () { console.log(this.mom); //全域媽咪 非同步回呼沒特別指定指向全域 }, 1000); };var findMom2 = function () { console.log(this.mom); //區域媽咪 傳統函式this指向family setTimeout(() =&gt; { console.log(this.mom); //區域媽咪 箭頭函式的parent scope是傳統函式function this 指向family }, 1000); };var findMom3 = () =&gt; { console.log(this.mom); //全域媽咪 箭頭函式的parent scope是全域window this也就指向全域window setTimeout(function () { console.log(this.mom); //全域媽咪 非同步回呼沒特別指定指向全域 }, 1000); };var findMom4 = () =&gt; { console.log(this.mom); //全域媽咪 箭頭函式的parent scope是全域window this也就指向全域window setTimeout(() =&gt; { console.log(this.mom); //全域媽咪 箭頭函式的parent scope是全域window this也就指向全域window }, 1000); };var mom = '全域媽咪';var family = { findMom1, findMom2, findMom3, findMom4, mom: '區域媽咪'};family.findMom1();family.findMom2();family.findMom3();family.findMom4(); DOM物件的例子： 同理在Vue中，使用Ajax回呼用箭頭函式指向為上一層parent scope，便可以使用this呼叫到data See the Pen arrow functions by KaiYun Cheng (@kaiyuncheng) on CodePen. 參考資料 JavaScript ES6 Arrow Functions 箭頭函數 鐵人賽：箭頭函式 (Arrow functions) this是甚麼? 談談 JavaScript 中的 “this” 和它的問題 JavaScript ES6 中的箭頭函數（arrow function）及對 this 的影響 鐵人賽：JavaScript 的 this 到底是誰？ 重新認識 JavaScript: Day 20 What’s “THIS” in JavaScript (鐵人精華版) Function 內的 this 到底是哪個 this","link":"/2020/11/17/arrowFunctions/"},{"title":"[JS 60 Days] Day 1 to Day 10 - JS變數","text":"Introduction這個挑戰練習是由hexschool建立的，這邊會紀錄Day1-20的練習 Day 1 - JS 環境與變數環境 Day 2 - 變數命名 Day 3 - 變數型別判斷與弱型別轉型 Day 4 - 比較運算子 Day 5 - 變數實作情境題 Day 6 - 邏輯運算子情境題 Day 7 - if - 認真的小杰竟被客訴 Day 8 - if 與指派運算子 - 幫幫小杰的金魚腦 Day 9 - 觀念總整理 - 幫小杰學會 Function 之呼吸 Day 10 - 函式參數設計 Day1JS 環境與變數環境第 1 題123456// 1.產生 console.log 從上到下的值為？// 2.出現幾個變數、型別、記憶體物件?var a ;a = 1;a = \"hello\";console.log(a) hello 1 2 3 第 2 題1234567// 1.產生 console.log 從上到下的值為？// 2.出現幾個變數、型別、記憶體物件?var b = 3 ;var c = 4;console.log(d)var d = b+c;console.log(d) undefined 7 3 1 6 第 3 題12345678// 1.產生 console.log 從上到下的值為？// 2.出現幾個變數、型別、記憶體物件?console.log(e)var e;e = 5;e = \"hello\"e = true;console.log(e) undefined true 1 3 4 Day2變數命名請依照以下房型資訊，去定義各個變數名稱，變數務必要命名比較語意化且好懂。 carbon Day3變數型別判斷與弱型別轉型請依序告知以下 console.log 會顯示什麼值。 第一題12345678910111213var a = 1;console.log(typeof(a)); //Numbervar b = \"hello\";console.log(typeof(b)); //Stringvar c = 1+\"hello\";console.log(typeof(c)); //Stringvar d = 1+\"11\";console.log(d) //111console.log(typeof(d)) //String 第二題1234567var a;a = a+\"hello\"console.log(a); //undefinedhelloconsole.log(typeof(a)) //Stringvar b = 3;console.log(b*\"hello\"); //NaN 第三題1234567var a = 9;console.log(a+9); //18console.log(a+'9'); //99var b = \"9\";console.log(b*b) //81console.log(typeof(b*b)) //Number Day4比較運算子請依序告知以下 console.log 會顯示什麼值。 第一題1234567891011121314var a = 2;var b = 1;console.log(a&gt;0); //trueconsole.log((a+b)&gt;1); //truevar c = 4;var d = 3;console.log(c == d); //falsevar e = 8;var f = 5;console.log(f &gt;= e) //falseconsole.log(f != e); //true console.log(f == e); //false 第二題 搭配型別自動轉型123456789var a=3; var b=\"3\";console.log(a==1); //falseconsole.log(a==b); //truevar c = 2;var d = \"5\";// 請解釋為什麼console.log((c*d)&gt;=5) //true 字串5轉型別為數字 2*5=10 大於等於5 第三題 嚴謹模式123456var a = 1;var b = \"1\";console.log(a==1); //trueconsole.log(a==b); //trueconsole.log(a===b); //falseconsole.log(a!==b); //true Day5變數實作情境題你現在是美式餐廳的櫃檯收銀員，但老闆因為預算有限，所以沒有買收銀機，所以你只能透過 JavaScript 來幫顧客結帳。 以下變數都不可變更： 第一題：顧客 Bob 向店員詢價顧客 Bob：「請問我要買 4 個漢堡，30 份薯條，總共多少？」 123456789101112// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var bobTotal;// 請將 Code 寫在這,運算內容賦予到 bobTotal,// 並要利用到 hamburgerPrice、friesPrice// 算出 Bob 的提問。bobTotal = hamburgerPrice * 4 + friesPrice * 30;console.log( \"Bob 您好,您詢問的金額總計為\"+bobTotal+\"元\"); 第二題：錢包剩下多少錢mark 錢包裡有 200 元，買了一個漢堡，三個薯條，他還剩下多少錢？ 12345678910111213// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var markWallet = 200;var markTotal;// 請將 Code 寫在這，運算内容賦予到 markTotal,// 並要利用到 markWallet、hamburgerPrice、friesPrice// 算出 mark 購買後剩餘的金額。markTotal = markWallet - ( hamburgerPrice * 1 + friesPrice * 3 );console.log('馬克買完東西後,錢包剩下'+markTotal +'元') 第三題：顧客 Mary 提供折扣券顧客 Mary 身上有 5000 元，想要買 10 份漢堡、10 份薯條，因為他有會員卡，所以可以打九折優惠，請問他還剩下多少錢？ 1234567891011121314// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var sale = 0.9;var maryWallet = 5000var maryTotal;// 請將 Code寫在這，運算內容賦予到 maryTotal ,// 並要利用到hamburgerPrice、friesPrice、sale、maryWallet// 算出 maryTotal 剩下的錢。maryTotal = maryWallet - sale * ( hamburgerPrice * 10 + friesPrice * 10 );console.log( 'Mary 買完東西後,錢包剩下'+ maryTotal +'元') Day6邏輯運算子情境題題目一：布林與比較運算子練習成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Bob 買了 2 個漢堡，2 個 薯條，是否有滿足條件？ 123456789101112var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;var isVIP;// 請透過比較運算子，將比較結果寫在isVip 上// 請利用 VIPTotal、hamburgerPrice、friesPrice 的變數進行比較// isVIP 的型別必須為布林值(true or false)isVIP = (( 2 * hamburgerPrice ) + ( 2 * friesPrice )) &gt;= VIPTotal ? true : false;console.log(\"Bob的 VIP 條件為\"+isVIP) 題目二：三心二意的老闆希望用邏輯運算子 &amp;&amp;老闆發現大家都只買薯條衝 VIP 資格，導致大家都不買漢堡，老闆好生氣，他認為他的美味蟹堡是全美最好吃的，小杰也不知道他的自信從哪裡來的。 所以他跟小杰說，從今天起，VIP 條件必須同時符合以下兩點，才能成為 VIP 資格。 一次消費滿 200 元 一定要買 1 個漢堡 這時又來了兩位顧客，Mary 與 Mark，來看看他們有沒有符合條件吧！ 1234567891011121314151617181920212223242526272829// 此變數不可更改var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;var markHamburgerNum = 2;var markFriesNum = 4;var markIsVIP;// 如上面新增的變數，馬克買了 2 個漢堡，與 4 個薯條// 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上// markIsVIP 的型別必須為布林值 (true or false)markIsVIP = (( markHamburgerNum * hamburgerPrice ) + ( markFriesNum * friesPrice )) &gt;= VIPTotal &amp;&amp; markHamburgerNum &gt;= 1 ? true : false;console.log(\"mark 的 VIP 條件為\"+ markIsVIP)var maryHamburgerNum = 0;var maryFriesNum = 10;var maryIsVIP;// 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條// 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上// maryIsVIP 的型別必須為布林值 (true or false)maryIsVIP = (( maryHamburgerNum * hamburgerPrice ) + ( maryFriesNum * friesPrice )) &gt;= VIPTotal &amp;&amp; maryHamburgerNum &gt;= 1 ? true : false;console.log(\"mary 的 VIP 條件為\"+ maryIsVIP) 題目三：Mary 很生氣，他覺得現在的 VIP 資格吃人夠夠，希望用 || 邏輯運算子Mary 說：「老闆我好歹是忠實老客戶欸，我買了你八年的薯條，而且遠遠超過 200 元，竟然還不算我是 VIP，你有沒有搞錯！」老闆怕了，他很擔心會上台灣的老天鵝娛樂被當作笑柄，所以他立馬將 VIP 條件改成，只要符合以下任一點消費條件，就能成為 VIP 資格。 一次消費滿 200 元 一定要買 1 個漢堡 我們再看看 Mary 有沒有符合條件吧！ 123456789101112131415var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;var maryHamburgerNum = 0;var maryFriesNum = 10;var maryIsVIP;// 如上面新增的變數，Mary 買了 0 個漢堡，與 10 個薯條// 請同時運用比較運算子與邏輯運算子，將比較結果寫在 markIsVIP 上// maryIsVIP 的型別必須為布林值 (true or false)maryIsVIP = (( maryHamburgerNum * hamburgerPrice ) + ( maryFriesNum * friesPrice )) &gt;= VIPTotal || maryHamburgerNum &gt;= 1 ? true : false;console.log(\"mary 的 VIP 條件為\"+ maryIsVIP) Day7if - 認真的小杰竟被客訴題目一：if 的練習老闆說現在要來驗收 if 成果，成為 VIP 會員的條件，只要購買滿 200 元，現在 會員 A 購買了 350 元，請用 if 判斷是否要給他 VIP 卡。 123456789var VIPTotal = 200;var memberPrice = 350;// 請透過 if 來設計回覆，如果對方滿足門檻// 就回覆 console.log(\"您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上\")if( memberPrice &gt;= VIPTotal){ console.log(\"您好，您有達到 VIP 門檻。這裡給您 VIP 會員卡(遞上)\")}; 題目二：if else 的練習又有人來申請 VIP 活動了！成為 VIP 會員的條件，只要購買滿 200 元，就可無條件成為會員，Mark 買了 2 個漢堡，2 個 薯條，是否有滿足條件？這次要記得用 if，以及注意你的語氣啊~ (小杰覺得人生好難 123456789101112131415161718var VIPTotal = 200;var hamburgerPrice = 50;var friesPrice = 30;// 請透過 if else 來去設計對方是否有達到條件，有或沒有都需要回覆對方// 如果有，請顯示 console.log(\"尊敬的客戶您好，您有達到 VIP 條件\")// 如果沒有達到條件，便用 else 顯示 console.log(\"尊敬的客戶您好，您還差 xx 元，才有符合 VIP 條件哦~\")let markTotal = hamburgerPrice * 2 + friesPrice * 2;let shortageif ( markTotal &gt;= VIPTotal){ console.log(\"尊敬的客戶您好，您有達到 VIP 條件\");} else{ shortage = VIPTotal - markTotal console.log(`尊敬的客戶您好，您還差 ${shortage} 元，才有符合 VIP 條件哦~`);}; 題目三： if、else if、else 練習工作一整天，小杰累到懷疑人生，累歸累，但還是得吃東西，小杰吃東西有自己的 SOP，來幫幫小杰看看他該吃什麼食物。 小杰都用飢餓度 1~100 來計算，100 就是代表最飢餓，數值皆為整數，不會有小數點 小杰飢餓度 0~20 時，都吃飯糰 小杰飢餓度在 21~40 時，都吃肉燥飯+貢丸湯 小杰飢餓度在 41~60 時，都吃麥當勞 小杰飢餓度在 61~100 時，都吃 99 元火鍋吃到飽 今天小杰的飢餓度是 53，請引導小杰去指定地點用餐 1234567891011121314// 請用 if、else if 去判斷主人公該吃什麼// 各區塊回覆內容請顯示 console.log(\"主人公因為飢餓度在\"+hungryNum+\"，所以他決定去吃麥當勞\")var hungryNum = 53;if(hungryNum &gt;= 20){ console.log(\"主人公因為飢餓度在\"+hungryNum+\"，所以他決定去吃飯糰\");}else if(hungryNum &gt; 20 &amp;&amp; hungryNum &lt;= 40){ console.log(\"主人公因為飢餓度在\"+hungryNum+\"，所以他決定去吃肉燥飯+貢丸湯\");}else if(hungryNum &gt; 40 &amp;&amp; hungryNum &lt;= 60){ console.log(\"主人公因為飢餓度在\"+hungryNum+\"，所以他決定去吃麥當勞\");}else{ console.log(\"主人公因為飢餓度在\"+hungryNum+\"，所以他決定去吃99 元火鍋吃到飽\");} Day8if 與指派運算子 - 幫幫小杰的金魚腦題目一：老闆考考你指派運算子老闆：「我其實很懷疑你是不是真的會了，我考考你！」老闆：「剛好今天是發薪日，先發給你薪資 23500 元(遞給小杰」小杰：「謝謝腦闆，但你怎麼把我的薪資告訴大家了..」老闆：「這不是重點，以下兩步驟動作請寫成程式」老闆：「步驟一：因為你遲到一次，我要扣你 1000 元(取走小杰手上的 1000 元」老闆：「步驟二：然後你又偷吃 Pizza，我要再扣你 2500 元 (再次取走」小杰：「不是啊！那明明是小黑吃..」老闆：「這不是重點，快點算！算出你還剩下多少錢！」 1234567var salary = 23500;// 請依照上面的武功秘笈Codepen，依序實現兩步驟,算出小杰被扣了多少錢salary = salary - 1000 - 2500;console.log(\"小杰目前還剩下\"+salary+\"元\"); 題目二： if + 指派運算子老闆：「好了，現在我要告訴你贈品條件！」 目前小杰手上有 3 個贈品 消費滿 100 元就送對方贈品 而現在來了兩個客人，並依序有消費，請問現在他還剩下多少個贈品？ 12345678910111213var giftNum = 3; // 贈品數量var customerA = 150;// 顧客 A 消費金額var customerB = 99; // 顧客 B 消費金額if(customerA &gt;= 100){ giftNum -= 1;};if(customerB &gt;= 100){ giftNum -= 1;};console.log(\"目前贈品剩下\"+giftNum+\"個\"); //2 題目三：if+指派運算子老闆：「我現在補齊給你總計 50 個贈品！」老闆：「然後我覺得現在贈品門檻太高了，我決定大放送，只要滿 50 元就送一個！以此類推，他買 500 元就送 10 個贈品！」小杰：「老闆你今天這麼慷慨，那我的薪..」老闆：「別廢話，客人來了快點！他買完後告訴我贈品還夠不夠！」 123456789101112131415161718var giftNum = 50; // 贈品數量var friesPrice = 30; // 薯條單價var hamburgerPrice = 50; // 漢堡單價// 以下是題目// mary 買了 10 份薯條，10 份漢堡// 請計算完贈品規則後,善用指派運算子去計算目前剩下的贈品有幾個// 並用下面的 if 回報給老聞maryTotal = friesPrice * 10 + hamburgerPrice * 10;if(giftNum &gt;= 0){ if(maryTotal &gt;= 50) giftNum = giftNum - Math.floor(maryTotal / 50); console.log(\"老聞!贈品還夠!剩下\"+giftNum+\"個~\" ); //34} else { console.log(\"老聞贈品賣光啦~\");} Day9觀念總整理 - 幫小杰學會 Function 之呼吸第一式：變數型別之呼吸請回覆以下 console.log 內容 123456789101112131415161718192021var a = 1;a+=1;a+=5;var b = 5;console.log(a+b); //12var c = 3;var d = \"hello\";console.log(c*d); //NaNvar e = 8 + 2 * \"9\";console.log(e); //26var f = 1;var g = \"2\";var h = 3;console.log(typeof(f+g+h)); //String 第二式運算子之呼吸請回覆以下 console.log 內容 12345678910111213141516var total = 200;var isVip = true;console.log(total&gt;=200 &amp;&amp; isVip); // truevar a = true;var b = false;console.log( a &amp;&amp; b); // falseconsole.log( a || b); // truevar c = 10;var d = 20;var e = 30;console.log(c==10 &amp;&amp; d&gt;=5 &amp;&amp; e !== 20); // trueconsole.log(c==10 || d&gt;=5 || e !== 20); // trueconsole.log(c==5 || d&gt;=40 || e !== 30); // false 第三式運算子之呼吸請告知以下 console.log，哪些會印出？如果你很閒，試試看最後一題改下布林值。 1234567891011121314151617181920212223242526var maryIsVIP = true;if(maryIsVIP){ console.log(\"哇貴婦餒！\"); // 會印出}else{ console.log(\"你一定搞錯了，叫你們店長出來！\");}var momSwim = false;var girlfriendSwim = true;if(momSwim &amp;&amp; girlfriendSwim){ console.log(\"都不救，因為他們都會游泳\");}else{ console.log(\"小杰大喊：「你們誰不會游泳啊？？」\"); if(girlfriendSwim){ console.log(\"那你自己游上來！\"); // 會印出 }else{ console.log(\"我先問我阿母會不會游泳！\"); } if(momSwim){ console.log(\"媽妳先自己游上來！\"); }else{ console.log(\"媽我去救你！\"); // 會印出 }} Day10函式參數設計第一題：客戶詢價函式，來更多個客人也不怕請改設計一個詢價用的函式，並新增三個參數，依序為客戶姓名、薯條數量，漢堡數量。同時來了三個客戶，請執行三次函式回報結果。 12345678910111213//定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var bobTotal;// 請將Code寫在這,運算內容賦予到 bobTotal,// 並要利用到 hamburgerPrice、friesPrice// 算出 Bob 的提問。function total(guestName, hamburgerNum, friesNum) { return `${guestName} 您好,您詢問的金額總計為 ${hamburgerPrice * hamburgerNum + friesPrice * friesNum} 元`;}console.log(total('Bob', 1, 2)); 第二題：好多客戶都在問小杰，他們錢包剩下多少錢，小杰表示無言下面截圖，請改設計一個查詢客戶錢包餘額用的函式，並新增四個參數，依序為客戶姓名、客戶錢包總額、薯條數量，漢堡數量。 同時來了三個客戶，請執行三次函式回報結果。 123456789101112131415161718// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var markWallet = 200;var markTotal;// 請將Code寫在這,運算內容賦予到markTotal,// 並要利用到 markWallet hamburgerPrice friesPrice// 算出 mark購買後剩餘的金額。console.log('馬克買完東西後,錢包剩下'+markTotal +'元')function total(guestName, walletTotal ,friesNum, hamburgerNum) { return `${guestName} 買完東西後,錢包剩下 ${ walletTotal - (hamburgerPrice * hamburgerNum + friesPrice * friesNum) } 元`;}console.log(total('Mark', markWallet, 10, 5)) 第三題：好多人都擁有九折優惠券這一題，換您來設計函式與參數看看。 突然間同時來了三個客戶，請執行三次函式回報結果。 12345678910111213141516// 定義薯條跟漢堡的金額(金額不可更改)var hamburgerPrice = 50;var friesPrice = 40;var sale = 0.9;var maryWallet = 5000var maryTotal;// 請將Code寫在這,運算內容賦予到 maryTotal,// 並要利用到hamburgerPrice friesPrice sale maryWallet// 算出 maryTotal 剩下的錢。function total(guestName, walletTotal ,friesNum, hamburgerNum) { return `${guestName} 買完東西後,錢包剩下 ${ walletTotal - (hamburgerPrice * hamburgerNum + friesPrice * friesNum) * sale } 元`;}console.log(total('Mary', maryWallet, 10, 5));","link":"/2020/10/28/js60Day1toDay10/"},{"title":"[JS 60 Days] Day 36 to Day 46 - ES6 Git window.location","text":"Introduction Day 36 - ES6 起步走 - Template String 樣板字串 Day 37 - let 與 const Day 38 - let 與 const 觀念複習 Day 39 - 箭頭函式(arrow function) Day 40 - ES6 團戰關卡 Day 41 - new Date() 時間處理 Day 42 - new Date() 與字串處理 Day 43 - GitHub Pages Day 44 - window.location Day 45 - window.location Day 46 - window.location Day36ES6 起步走 - Template String 樣板字串第36天的作業是改寫[第 20 關]的字串相加邏輯，以符合 ES6 寫法，因為當初寫時就已經是用樣板字面字的方式寫了，所以這次會來練習fetch，這兩篇是我的整理筆記同步非同步霧煞煞(上)-AJAX同步非同步霧煞煞(下)-Promise,Async,Await 如果你已經早就會 ES6 字串處理，請觀看以下文章，挑選一個你不會的技術觀念，並分享你學到了什麼 邁向 JavaScript 勇者之路 重新認識 JavaScript ES6 入門手冊(較於艱深) Day37let 與 const比較了這三個用法 var let constvar, let, const 差異比較 Day38let 與 const 觀念複習問題一請問下面會出現的 console 是？ 12console.log(a); // ReferenceError: a is not definedlet a = 10; 問題二以下是否會正常執行？若不會，會顯示什麼紅字錯誤？ 123let a = 1;a=3;//會正常執行，let可以重新賦值 123let b = 1;let b = 2;//會錯誤 不能重複宣告 123const c = 3;c=4//會錯誤 const不能重新賦值 問題三：此為熱門面試題目(選答)請問 var、let、const 的區別是？ 我整理了一篇比較文章var, let, const 差異比較 Day39箭頭函式(arrow function)arrow function 會如何影響到 this？我整理了一篇文章箭頭函式 Arrow Functions 和 this Day40ES6 團戰關卡請挑選20天或35天改為ES6寫法，若已經改寫，以下面試題目請挑選一題來解釋，並下方附上你的 HackMD 文章a. 請解釋什麼是 this？請寫範例解釋？箭頭函式 Arrow Functions 和 this b. 你對 promise、promise all 有多熟悉？請寫範例解釋？c. Fetch 與 XMLHttpRequest同步非同步霧煞煞(上)-AJAX同步非同步霧煞煞(下)-Promise,Async,Await d. 什麼是原型繼承(prototype)？物件導向: 原型Prototype與物件Object Day41new Date() 時間處理我的時間處理整理文章關於時間 new Date() Day42new Date() 與字串處理問題請用你學會的語法，取出今日時間，並依序組出以下字串假設今天時間為 8/5，則需透過 new Date() 處理後，印出以下資料 12345// 目前時間是 2020/8/5 14:20 // 2020/08/05// 2020-08-05// 今天是禮拜三 // 今天是八月五日，時間為 14:20 See the Pen Date by KaiYun Cheng (@kaiyuncheng) on CodePen. Day43GitHub Pages問題請依照技術主管的指示，將網頁放在 GitHub Pages 上的服務 在本地端新增一個 index.html，裡面多加上一個 h1 的標籤，裡面寫自己 Slack 的暱稱 觀看此文件，讓自己的網頁上傳到 GitHub Pages 上 在下方列表，張貼自己的 GitHub Pages 網址 接下來我們將會持續用 GitHub Pages 更新網頁 我的github Day44window.location來了解 window.location 類別的功能，例如轉址、取得網址參數等等 我的整理文章關於window.location類別功能：轉址、取得網址參數 Day45window.locationDay46window.location問題一以下有兩顆按鈕，請使用 JavaScript 語法，操控點擊後，能夠轉址到對應網站去 12&lt;button class=\"google\"&gt;連到 Google&lt;/button&gt;&lt;button class=\"yahoo\"&gt;連到 Yahoo&lt;/button&gt; 問題二以下有兩顆按鈕，是部落格推薦連結，請抓取 data-id 的值後進行轉址： 點擊 Tom 時，網址為 https://www.hexschool.com/?recommend=tom 點擊 John 時，網址為 https://www.hexschool.com/?recommend=John 12&lt;button class=\"google\" data-id=\"tom\"&gt;Tom 推薦六角學院&lt;/button&gt;&lt;button class=\"yahoo\" data-id=\"John\"&gt;John 推薦六角學院&lt;/button&gt; See the Pen location by KaiYun Cheng (@kaiyuncheng) on CodePen. 問題三如果網址規則是https://www.hexschool.com/?recommend=\"值\"，該如何取出 recommend 的值？例如 https://www.hexschool.com/?recommend=tom，可以透過 JS，精準取出 tom 的值？請提供 JS 寫法。 12let url = new URL('https://www.hexschool.com/?recommend=tom');url.searchParams.get('recommend'); // tom","link":"/2020/11/11/js60Day36toDay46/"},{"title":"[JS 60 Days] Day 47 to Day 60 - AJAX Post和Get","text":"Introduction Day 47 - AJAX POST Day 48 - AJAX POST 小練習 Day 49 - 旅館訂房網 Day 50 - 旅館訂房網 Day 51 - 頁面傳遞 Day 52 - 頁面傳遞 Day 53 - 頁面傳遞 Day 54 - POST API Day 55 - 簡單預約列表 Day 56 - 訂房網該做的功能 Day 57 - 訂房網該做的功能 Day 58 - 訂房網該做的功能 Day 59 - 提交作品 Day 60 - 提交作品 Day47AJAX POSTDay48AJAX POST 小練習 請用此 API，寫三個 AJAX POST API 範例，個別是 xmlhttprequest Fetch axios 畫面上有： 註冊面板登入面板 同時寫一些驗證與使用者體驗功能，例如： 帳號密碼不可為空送出後，欄位進行清空查詢是否為 Email 格式(非必做)密碼是否有英數夾雜(非必做) 我的DEMO 驗證的部分，製作了不可留空驗證、email格式驗證、密碼格式驗證（長度在 6-12 之間，必須包含至少一個大和小寫英文字、一個數字）、再次輸入密碼驗證。DEMO 三種post寫法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859let url = `https://hexschool-tutorial.herokuapp.com/api/${type}`;let user = { email: document.querySelector(`#email_${type}`).value, password: document.querySelector(`#password_${type}`).value,};const axiosPost = function () { axios .post(url, user) .then(res =&gt; { console.log(res); swal({ title: res.data.message, }); reset(type); }) .catch(err =&gt; { console.log(err); swal({ title: err, }); }); }; // xhr 寫法 const xhrPost = function () { const xhr = new XMLHttpRequest(); xhr.open('POST', url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(user)); xhr.onload = function () { const res = JSON.parse(xhr.response); swal({ title: res.message, }); reset(type); }; }; // fetch 寫法 const fetchPost = function () { fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(user), }) .then(response =&gt; response.json()) .then(data =&gt; { swal({ title: data.message, }); reset(type); }) .catch(err =&gt; console.log(err)); }; Day49旅館訂房網Day50旅館訂房網問題小杰依照文件裡的 API，想要去取得此 API [GET] 取得所有房型，但發現不管怎麼戳也無法取得所有房型資料，技術主管只淡淡說了一句：「你送請求時少加 TOKEN 啦！」，就跑去泡咖啡了，這句話究竟是什麼意思呢？ 主要就是需要帶入Token來驗證 請用 codepen 寫自己的範例，能正確取得 [GET] 取得所有房型，並用 ul、li 來呈現各個「房型名稱」 See the Pen QWKbjOy by KaiYun Cheng (@kaiyuncheng) on CodePen. Day51頁面傳遞Day52頁面傳遞Day53頁面傳遞問題 任務一：這頁面需要使用到 GitHub Pages，並設計兩頁，一頁是 index.html 顯示所有房型，每個房型都會帶 a 連結，連結會帶參數，參數請帶每個房型的 id 任務二：當點擊連結進入到 room.html 後，依照取得的 id 資料，去接 [GET] 單一房型細節，並在該頁顯示該房型細節。例如有無提供各種 room service、訂房紀錄等等。 Day54POST API第 54 關小杰感到非常困擾，因為接下來他要開始練習 POST API，也就是 [POST] 預約房型，但他不管怎麼傳送都是失敗，一起來幫幫小杰 POST 資料成功吧！ 問題請回傳自己 post api 成功的功能 Day55簡單預約列表小杰發現當他練習 POST API，也就是 [POST] 預約房型，當他預約某個房型成功時，會 response 目前訂房狀態，也同時在 [GET] 單一房型細節的 booking 屬性看到這房間預約狀態。 請設計在房型頁面可以進行表單預約，POST 預約成功後，再用 ul li 呈現已被預約的訂房資訊。 如下列表呈現 預約人：小杰、預約時段：2020/8/242020/8/25預約人：小花、預約時段：2020/8/262020/8/27 Day56Day57Day58訂房網該做的功能首頁：能看到所有房型，並能點擊任一房型，進入到單一房型頁面觀看更多 單一房型頁面： 客戶可以觀看該房型詳細資訊，例如旅館描述、平日價格(一-四)、假日價格(五-日)、checkIn 時間、其他服務，詳細資訊欄位請參考此連結。 客戶可以用預約列表或日曆方式，瀏覽未來 90 天已預約與尚未預約的時段。 客戶在選擇預約日期時，會即時顯示訂房價格總價 客戶可以線上訂房，需填寫的欄位：姓名、電話、預約起迄，只能預約未來 90 天內的時段 若預約失敗，會回傳訊息讓客戶知曉，失敗原因項目如下 a. 預訂 90 天後 b.預約時間已被人預訂 c.您預約的是過去時間，例如昨天 Day60提交作品","link":"/2020/11/26/js60Day47toDay60/"},{"title":"[JS] 陣列方法筆記起來","text":"前言學習Javascript到應用時，最常使用的就是陣列方法來處理資料，因此多知道一個方法但不需要死背用法來的更重要。這篇也會持續更新學到的方法。 另外整理這篇的契機是在學習過程中，看了偷米騎巴哥的影片和整理圖，十分喜歡，也讓觀念更加清晰。 出處連結在此 偷米騎巴哥-操作JS陣列的20種方式 另外也很喜歡OxxoStudio這個整理過後的大全分類，借鑒了OxxoStudio的分類整理以自己理解的觀念。 JavaScript Array 陣列操作方法大全 ( 含 ES6 ) 還有其他實用的方法 Cheatsheet for Array Methods - JavaScript 陣列方法大全 JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()] 陣列方法小筆記1. 會改變原本陣列的內容&gt; 陣列增減,複製取代push() ：加入到最後 — unshift() ：加入到最前pop() ：把最後一個去除 — shift() ：把最前一個去除splice()splice()中包含三個參數：參數1(必填)：從第幾個開始刪除或新增參數2(選填)：要刪掉幾個，0或負值則不刪除，不填時 參數1 後所有項目都刪除。參數3(選填)：新增的項目，可以是好幾個值 123let ary = [1, 2, 3, 4, 5];ary.splice(1, 0, 1000, 2000, 3000);console.log(ary); //[1, 1000, 2000, 3000, 2, 3, 4, 5] copyWithin()有點像是複製貼上取代的概念，貼上會取代掉原本位置的元素參數1(必填)：從第幾個開始貼上取代參數2(選填 預設0)：從第幾個開始複製參數3(選填 預設陣列長度)：複製到第幾個前（不包含這一個） 1234567let ary = [1, 2, 3, 4, 5];ary.copyWithin(1);console.log(ary); //[1, 1, 2, 3, 4] 5 超過陣列長度，所以不會出現ary.copyWithin(2, 1, 3);console.log(ary); //[1, 2, 2, 3, 5] 複製2,3 從索引2也就是3的位置開始取代 fill()把陣列中所有元素，換成指定的值參數1(必填)：指定的值參數2(選填 預設0 全部置換)：從第幾個開始換參數3(選填 預設陣列長度)：換到第幾個前（不包含這一個） 1234567let ary = [1, 2, 3, 4, 5];ary.fill('cool', 1);console.log(ary); // [1, 'cool', 'cool', 'cool', 'cool']ary.fill('cool', 1, 3);console.log(ary); // [1, 'cool', 'cool', 4, 5] &gt; 陣列排序reverse() ：反轉陣列排序sort() ：會將元素轉換成 字串 來排序，預設排序為unicode 從 a 排到 z , 從 小 排到 大，若有十位數以上數字則會產生排序問題，因此需要用以下方法來解決。 12345678910111213let ary = [100, 1, 4, 50];ary.sort((a,b) =&gt; b - a);console.log(ary); // [100, 50, 4, 1] 倒序ary.sort((a,b) =&gt; a - b);console.log(ary); // [1, 4, 50, 100] 正序ary.sort((a,b) =&gt; a &gt; b ? -1 : 1); console.log(ary); // [100, 50, 4, 1] 倒序ary.sort((a,b) =&gt; a &gt; b ? 1 : -1); console.log(ary); // [1, 4, 50, 100] 正序 2. 回傳陣列元素資訊或索引值(取得陣列而不會改變原始陣列) &gt; 回傳陣列元素資訊.length ： 回傳陣列的長度(元素的數量)&gt; 回傳陣列索引值indexOf()由左到右判斷是否有 參數1 的值，如果有回傳這個值的索引值，如果沒有回傳 -1參數1(必填)：要判斷的值參數2(選填 預設0)：從第幾個開始判斷 lastIndexOf()由右到左判斷是否有 參數1 的值，如果有回傳這個值的索引值，如果沒有回傳 -1參數1(必填)：要判斷的值參數2(選填 預設為最後一個)：從第幾個開始判斷 12345678let ary = [1, 2, 3, 4, 5];console.log(ary.indexOf(3)); // 2console.log(ary.indexOf(6)); // -1console.log(ary.indexOf(2, 3)); // -1console.log(ary.lastIndexOf(5)); // 4console.log(ary.lastIndexOf(2, 3)); // 1console.log(ary.lastIndexOf(5, 3)); // -1 findIndex()會將陣列中的 每一個 元素帶入函式判斷，並會回傳 第一個 符合判斷條件元素的索引值，如果沒有元素符合則會回傳 -1 &gt; 回傳陣列元素值find()會將陣列中的 每一個 元素帶入函式判斷，並會回傳 第一個 符合判斷條件的元素，如果沒有元素符合則會回傳 undefined 1234567let ary = [1, 2, 3, 4, 5];console.log(ary.findIndex(num =&gt; num &gt; 2)); // 2(索引值)console.log(ary.findIndex(num =&gt; num &lt; 0)); // -1console.log(ary.find(num =&gt; num &gt; 2)); // 3console.log(ary.find(num =&gt; num &lt; 0)); // undefined &gt; 回傳一個新字串join()可帶入值取代原有陣列的逗號區隔，回傳成字串，未帶入則用逗號隔開 123456let aryA = [1, 2, 3, 4, 5];let b = aryA.join('@');console.log(b); // '1@2@3@4@5' 字串let b = aryA.join('');console.log(b); // '12345' toString()可以把整個陣列轉換成字串 123let ary = [1, 2, 3, 4, 5];let b = ary.toString();console.log(b); // 1,2,3,4,5 字串 &gt; 回傳一個新數值reduce()將陣列中每一個元素進行計算，結果再與下個元素計算，回傳計算結果。較常見於計算加總。裡頭有一個函式 (必填) 和 一個初始計算數值 (選填)函式中可帶入4個參數參數1(必填)：計算的值參數2(必填)：該元素的值參數3(選填)：元素的索引值參數4(選填)：原本的陣列 123456let aryA = [1, 2, 3, 4, 5];let b = aryA.reduce((total, num) =&gt; total + num); console.log(b); // &nbsp;15 = 1+2+3+4+5let b = aryA.reduce(((total, num) =&gt; total + num), 10); console.log(b); // &nbsp;25 = 1+2+3+4+5+10 reduceRight()和reduce類似，差別在計算方式是由右到左，加法不影響，減法則會有差別 123456let aryA = [1, 2, 3, 4, 5];let b = aryA.reduce((total, num) =&gt; total - num); console.log(b); // &nbsp;-13 = 1-2-3-4-5let b = aryA.reduceRight(((total, num) =&gt; total - num)); console.log(b); // &nbsp;-5 = 5-4-3-2-1 &gt; 回傳一個新陣列filter()會將陣列中的 每一個 元素帶入指定的函式內做判斷，並會回傳符合判斷條件的元素組成一個新陣列 123let aryA = [1, 2, 3, 4, 5];let aryB = aryA.filter(num =&gt; num % 2 == 1);console.log(aryB); // [1, 3, 5] 餘1為奇數 slice()與字串.slice()用法差不多，擷取某段回傳出新陣列參數1(必填)：從第幾個開始擷取參數2(選填 預設為最後一個)：擷取到第幾個前（不包含這一個） 123456let aryA = [1, 2, 3, 4, 5];let aryB = aryA.slice(1);console.log(aryB); // [2, 3, 4, 5] let aryB = aryA.slice(1, 3);console.log(aryB); // [2, 3] concat() ：將兩個陣列串接為一個陣列…ES6語法 擴展運算符… 有相同功能 1234567let aryA = [1, 2, 3, 4, 5];let aryB = ['a', 'b', 'c'];let aryC = aryA.concat(aryB); //陣列A後串接Bconsole.log(aryC); // &nbsp;[1, 2, 3, 4, 5, \"a\", \"b\", \"c\"]let aryC = [...aryA, ...aryB] //使用...console.log(aryC); // &nbsp;[1, 2, 3, 4, 5, \"a\", \"b\", \"c\"] 展開運算符(spread operator)…運用在陣列與物件 123456let aryA = [1,2,3];let aryB = [0, ...aryA, 4]; // [0,1,2,3,4] let objA = { a: 1, b: 2 };let objB = { ...objA, c: 3 }; // { a:1, b:2, c:3 }let objC= { ...objA, a: 3 }; // { a:3, b:2 } 剩餘操作符(rest operator)是解構的一種，意思就是把剩餘的東西放到一個array裏面賦值給它。 12345678910111213141516171819202122let aryA = [1,2,3];let [aryB, ...aryC] = aryA;console.log(aryB); // 1console.log(aryC); // [2,3] 如果陣列長度不夠解構 aryC為空陣列[]let ary = [1,2];let [a, ...[b,c]] = ary;console.log(a, b, c); //1 2 undefined//函式帶入的情況function test(a, ...rest){ console.log(a); // 1 console.log(rest); // [2,3]}test(1,2,3);//物件用法let obj = { name: 'Peter', age: 30, city: 'Taipei'};const {name, ...rest} = obj;console.log(name); // 'Peter'console.log(rest); // {age: 30, city: 'Taipei'} Array.of()可以把數字、字串轉換成陣列 12let ary = Array.of(1, 2, 3, 'a', ['b']);console.log(ary); // [1, 2, 3, \"a\", [\"b\"]] Array.from()可將(「類陣列物件」：具有length屬性和索引值) 或是(「可迭代的物件」：可利用迭代的方式取得本身的元素eg: Map和Set等) 轉換成陣列，有兩個參數參數1(必填)：「類陣列物件」或是「可迭代的物件」參數2(選填)：改變轉換陣列的函式 1234567let a = '12345';let b = Array.from(a);console.log(b); // [\"1\", \"2\", \"3\", \"4\", \"5\"]let b = Array.from(a, item =&gt; 0 + item );console.log(b); // [\"01\", \"02\", \"03\", \"04\", \"05\"] 「類陣列物件」：需具有length屬性和索引值 12345678910let obj = { '0': 1, '2': 3, '1': 2, '4': 5, '3': 4, length: 5};let ary = Array.from(obj);console.log(ary); // [1, 2, 3, 4, 5] flat()可以把多層陣列平面化，一個參數(選填 預設1)為平面化幾層，設定Infinity可以直接全面平面化，回傳成新陣列 1234567let aryA = [1, 2, [[3]], [[[4], 5]]];let aryB = aryA.flat(); let aryC = aryA.flat(2); let aryD = aryA.flat(Infinity); console.log(aryB); // [1, 2, [3], [[4], 5]] console.log(aryC); // [1, 2, 3, [4], 5] console.log(aryD); // [1, 2, 3, 4, 5] flatMap()map() + flat() 帶入函式後傳出的值再平面化 123let aryA = [1, 2, [[3]], [[[4], 5]]];let aryB = aryA.flatMap(item =&gt; item + 10); console.log(aryB); // [11, 12, \"310\", \"4,510\"] map()與 forEach 非常類似，但是 map 會 return 一個值，並會產生一個新陣列裡頭有一個函式 (必填) 和 一個callback函式裡的 this 參數 (選填)函式中可帶入3個參數參數1(必填)：每個元素帶入的變數參數2(選填)：該元素的索引值參數3(選填)：原本的陣列 123456789101112131415161718let aryA = [1, 2, 3, 4, 5];let aryB = aryA.map((item, index) =&gt; { return `${index + 1}:${item &gt; 2}`}); console.log(aryB); //&nbsp;[\"1:false\", \"2:false\", \"3:true\", \"4:true\", \"5:true\"]aryA.map((item, index, ary) =&gt; { return ary[index] = item * 10;}); console.log(aryA); // [10, 20, 30, 40, 50] 更改原陣列// 如果要使用callback函式裡 this 的參數，則「不能使用」箭頭函式，因為箭頭函式的 this 指向和函式的 this 指向不同，所以要用一般的函式處理。let aryA = [1,2,3,4,5];let aryB = aryA.map(function(item){ return item + this; // 此處的 this 為 10}, 10);console.log(aryB); // [11, 12, 13, 14, 15] 3. 針對每個元素處理，不用returnforEach()會將陣列中的 每一個 元素帶入指定的函式內做運算，裡頭有一個函式 (必填) 和 一個callback函式裡的 this 參數 (選填)函式中可帶入3個參數參數1(必填)：每個元素帶入的變數參數2(選填)：該元素的索引值參數3(選填)：原本的陣列 forEach() 無法用 break 中斷，如果想要中斷執行的話要使用傳統的 for 迴圈。 1234let ary = [1, 2, 3, 4, 5];let total = 0;ary.forEach(item =&gt; total += item);console.log(total); // 15 可更改原始陣列 12345let ary = [1, 2, 3, 4, 5];ary.forEach((item, index, ary) =&gt; { ary[index] = item * 10;});console.log(ary); // [10,20,30,40,50] MDN forEach()文件 4. 判斷並回傳布林值Array.isArray()判斷一個物件是否為陣列，如果是就回傳 true，不然就回傳 false。 12345let ary = [1, 2, 3, 4, 5];let obj = {a:1, b:2, c:3};console.log(Array.isArray(ary)); // trueconsole.log(Array.isArray(obj)); // false every()會將陣列中的 每一個 元素帶入指定的函式內做判斷，全部符合條件回傳 true，其中一個元素條件不符合，便回傳false。 123let ary = [1, 2, 3, 4, 5];console.log(ary.every(item =&gt; item &gt; 4)); // falseconsole.log(ary.every(item =&gt; item &gt; 0)); // true some()會將陣列中的 每一個 元素帶入指定的函式內做判斷，其中一個元素符合條件回傳 true，全部不符合，便回傳false。 123let ary = [1, 2, 3, 4, 5];console.log(ary.some(item =&gt; item &gt; 4)); // trueconsole.log(ary.some(item =&gt; item &lt; 0)); // false includes()判斷陣列中是否包含某個值，如果有包含就回傳 true，不然就回傳 false參數1(必填)：要判斷的值參數2(選填)：從第幾個開始判斷 123let ary = [1, 2, 3, 4, 5];console.log(ary.includes(2)); // trueconsole.log(ary.includes(2,3)); // false 5. 其他&gt; 回傳陣列值valueOf()回傳原本陣列的值，但如果原本陣列有修改，那麼回傳後的陣列值也會跟著改變，類似傳參考的概念。 12345let aryA = [1, 2, 3, 4, 5];let aryB = aryA.valueOf();aryB[0] = 'a';console.log(aryA); // [\"a\", 2, 3, 4, 5]console.log(aryB); // [\"a\", 2, 3, 4, 5] &gt; 回傳一個的Array Iterator物件keys()回傳陣列中的每一個索引值 key 成為一個新的 Array Iterator 陣列迭代器物件因為是 Array Iterator 物件，可以透過 Array.from, for…of來取得。 12345678910111213let a = ['a','b','c','d','e'];let b = a.keys(); // Array Iteratorlet c = Array.from(b);console.log(c); // [0, 1, 2, 3, 4]let a = ['a','b','c','d','e'];let b = a.keys();let d = [];for (let key of b) { d.push(key); }console.log(d); // [0, 1, 2, 3, 4] 延伸閱讀 for…of [筆記] JavaScript ES6 中的 for … of 迭代器 values()回傳陣列中的每一個元素值 成為一個新的 Array Iterator 陣列迭代器物件 12345let a = ['a','b','c','d','e'];let b = a.values(); // Array Iteratorfor (let value of b) { console.log(value); } //依序出現 a b c d e entries()回傳陣列中的每一個索引值 key 與對應元素 成為一個新的 Array Iterator 陣列迭代器物件 fromEntries()可把Array Iterator 陣列迭代器物件轉成物件Object 12345678910111213let a = ['a','b','c','d','e'];let b = a.entries(); // Array Iteratorlet c = [];for (let [key, value] of b) { c.push(`${key}${value}`); }console.log(c); // [\"0a\", \"1b\", \"2c\", \"3d\", \"4e\"]let a = ['a','b','c','d','e'];let b = a.entries();const e = Object.fromEntries(b);console.log(e); // {0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\", 4: \"e\"}","link":"/2020/11/03/jsArrayMethod/"},{"title":"[用JS來寫演算法和了解資料結構] Day1 演算法的好壞評量標準","text":"前言這個系列主要是想自我挑戰30天用學資料結構和演算法。因為不是資訊本科生，對資料結構的理論一知半解，藉由筆記更加深印象。會搭配一個我很喜歡的前端工程師Hannah分享的鐵人賽文章，來做練習。這邊因為是我個人練習學習，順序或時間可能會跟Hannah的文章不一樣。 前端工程師用 javaScript 學演算法 Data Structures and Algorithms (DSA) 會使用或參考到的資源： LeetCode Codility CSPIRATION leetcode 解題之路 程式麻瓜的程式知識課 演算法的好壞評量標準兩個評量演算法好壞的指標： 時間複雜度 (Time complexity) 佔用記憶體空間 (Space complexity) 時間複雜度用來評斷演算法執行的快慢，一般用大 O 符號(Big O notation、BigO)來表示，用來描述一個演算法在輸入 n 個東西時，總執行時間與 n 的關係。 舉個例子，來到書店想買一本書XXX，但架子上有大概100本書，兩種找法： 一本一本找，若1本花費1分鐘，10本花費10分鐘，100本花費100分鐘，n本花費n分鐘，時間複雜度是Big O(n) 直接用電腦根據索引找到書的位置，不管幾本都只花費了1分鐘，時間複雜度是Big O(1) Big O圖片來源 程式麻瓜的程式知識課 時間複雜度 從好到不好 Constant time — O(1) - 陣列讀取 Logarithmic time — O(log n) - 二分搜索 Linear time — O(n) - 簡易搜索 Linearithmic time — O(n log n) - 合併排序、快速排序 Quadratic time — O(n^2) - 選擇排序、氣泡排序 Exponential time — O(2^n) - 費波那契數列 [時間複雜度 wiki]](https://zh.wikipedia.org/zh-tw/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6) 越不好代表程式的步驟次數越高，而非執行時間 1個步驟 big O(1)x = 10 11個步驟(宣吿1次+回圈10次) big O(n) 123x = 10for i from 1 to x: print(\"你好！\") 21個步驟(宣吿1次+回圈10次*2次) big O(n^2) 123456x = 10for i from 1 to x: print(\"你好！\")for i from 1 to x: print(\"Hi\") Big O(log n)假設 n 為 81 個，那麼只要 9 個步驟完成，則是Big O(log n)，例子是二分搜索binary search。 時間限制 Time limit n &lt;= 1 000 000, the expected time complexity is O(n) or O(n log n) n &lt;= 10 000, the expected time complexity is O(n^2) n &lt;= 500, the expected time complexity is O(n^3) 重點 大 O 符號：用來描述演算法在輸入 n 個東西時，所需時間與 n 的關係 演算法的速度不是以時間計算，而是以步驟次數 接下來的學習順序大致會分Data Structure和Algorithms兩個大項另外搭配leetcode的題目 Data Structure：原始型別 Primitive Data Types陣列 Array集合 SetMap / HashMap堆疊 Stack佇列 Queue鏈結串列 Linked List樹 Tree 不同資料結構的時間複雜度 Algorithms： 搜尋 Search:簡易搜尋 Sequential Search二分搜尋 Binary Search 排序 Sorting:氣泡排序 Bubble Sort選擇排序 Selection Sort插入排序 Insertion Sort合併排序 Merge Sort快速排序 Quick Sort 費波那契數列 Fibonacci numbers遞迴 Recursion動態規劃 Dynamic programming","link":"/2023/09/25/leetcodeDay1/"},{"title":"[用JS來寫演算法和了解資料結構] Day2 學習目錄和原始型別","text":"學習目錄我的學習順序大致會分Data Structure和Algorithms兩個大項另外搭配leetcode的題目。 Data Structure：原始型別 Primitive Data Types陣列 Array集合 SetMap / HashMap堆疊 Stack佇列 Queue鏈結串列 Linked List樹 Tree 圖 Graph堆積 Heap雜湊表 Hash Table 不同資料結構的時間複雜度 Algorithms： 搜尋 Search:簡易搜尋/線性搜索 Sequential Search/Linear Search二分搜尋 Binary Search 排序 Sorting:氣泡排序 Bubble Sort -選擇排序 Selection Sort - O(n^2)插入排序 Insertion Sort - O(n)合併排序 Merge Sort -快速排序 Quick Sort - 遞迴 RecursionBacktracking分而治之 Divide-and-Conquer動態規劃 Dynamic programming / 費波那契數列 Fibonacci numbersGreedyDivide and Conquer 原始型別 Primitive Data Types原始型別就是資料結構中最基本的元素， 因為是先學js才來了解資料結構，但js是弱型別語言，所以可能不太能理解某些結構與型別，可能會以js原始型別來想像會比較好理解吧(？) 分為以下： 整數 Integers - E.g., 1, 2, 3, 字元 Characters - E.g., a, b, “1”, “*”//在js中應該可以想像是字串.. 布林 Booleans - E.g., true or false 浮點數或雙精度 Float (floating points) or doubles E.g., 3.14159, 1483e-2// js中數字型別都是以double的形式存在，可以是整數也可以代表浮點數另外還有+Infinity、-Infinity、NaN這三種。 Null values. E.g. null 另外JavaScript還有其他兩個型別 undefined和Symbol。 Object不是原始型別。 參考資料 前端工程師用 javaScript 學演算法 Data Structures and Algorithms (DSA)","link":"/2023/09/27/leetcodeDay2/"},{"title":"[用JS來寫演算法和了解資料結構] Day3 陣列、簡易搜索、二分搜索、leetcode #1064","text":"陣列陣列應該是資料結構中對於寫javascript的人來說最友好的，js的陣列可以放入不同型別的資料(像是C/Java這樣的語言，陣列的大小和資料型別要先定義)，加上js有許多陣列方法，雖然蠻多是O(n^2)以上，但相對的寫法算很簡潔… 陣列像是編列好的一個置物櫃，有連續性(順序性)，要找某個櫃子只需要他的索引值index，array[index]陣列讀取時間複雜度O(1)。假設不知道索引值則是簡易搜尋O(n)像是使用for-loop。 操作陣列的方法，之前有整理了一篇，忘記可以回去再看一下，這篇就不再次介紹 陣列方法筆記起來 陣列方法的時間複雜度，可以得知操作陣列最後一個元素都是O(1)，而操作第一個或中間某個因為會導致陣列的其他元素的位置都會改變，則變成O(n)。 簡易搜尋 / 線性搜索 Sequential Search / Linear Search - O(n)1個耗費的步驟1次O(1) ，n個耗費的步驟就是n次O(n)， 把array中所有的數值都列出來 從一個沒有順序的array中找出某個元素，不知道index的情況下 12345678910function findNum(ary, target){ for(let i = 0; i &lt; ary.length; i++){ if(ary[i] === target){ return true } } return false}findNum([1,5,6,7,2], 2); 在一個沒有順序的array中找出最大或最小值 1234567891011function findMax(ary) { let max; for (let i = 0; i &lt; ary.length; i++) { if(max === undefined || max &lt; ary[i]) { max = ary[i]; } } return max;}findMax([1,5,6,7,2]); 找第二大 1234567891011121314function findSecondMax(ary) { let max, second; for (let i = 0; i &lt; ary.length; i++) { if(max === undefined || max &lt; ary[i]) { second = max; max = ary[i]; }else if(second === undefined || second &lt; ary[i]){ second = ary[i]; } } return second;}findSecondMax([1,5,6,7,2]); // 6 二分搜尋 Binary Search - O(log n)1個耗費的步驟1次O(1)，4個耗費的步驟為2次，n個耗費的步驟是log n次。 使用二分搜尋時，必須是一個排序好陣列(例如:A-Z，1-100，小到大，大到小)。在生活中最熟悉的例子就是終極密碼這個遊戲，小時候可能都有玩過。1-100猜一個數字，一開始大家都會先對半切 猜50，比50大還是比50小，知道比50小後再對半猜25，接下來以此類推。恩沒錯…這個就是二分搜尋的概念。 12345678910111213141516171819202122// ary = [5,17,33,41,55,61,80]// target = 55function binarySearch(ary, target){ let low = 0; let high = ary.length - 1; let mid; let result = -1 while(low &lt;= high){ mid = Math.floor((low + high) / 2); if(ary[mid] &gt;= target){ high = mid - 1; result = mid; }else{ low = mid + 1; } } return result;}binarySearch([5,17,33,41,55,61,80], 55); 若是陣列資料為字串可以先用 charCodeAt 轉成 UTF-16代碼值 123456let ary = ['Allen','Bill', 'Helen', 'Zoe'];let aryCode = [];ary.forEach((item, i) =&gt; { aryCode.push(item.charCodeAt(0));})console.log(aryCode); // [65, 66, 72, 90] leetcode #1064 Fixed Point leetcode #1064 Fixed Point 題目:Given an array A of distinct integers sorted in ascending order, return the smallest index i that satisfies A[i] == i. Return -1 if no such i exists. 給一個包含不同整數的陣列，排序由小到大，找出最小並符合A[i] == i的值。沒有符合的話回傳-1 12345678910111213141516171819202122232425262728Example 1:Input: [-10,-5,0,3,7]Output: 3Explanation: For the given array, A[0] = -10, A[1] = -5, A[2] = 0, A[3] = 3, thus the output is 3.Example 2:Input: [0,2,5,8,17]Output: 0Explanation: A[0] = 0, thus the output is 0.Example 3:Input: [-10,-5,3,4,7,9]Output: -1Explanation: There is no such i that A[i] = i, thus the output is -1. Note:1 &lt;= A.length &lt; 10^4-10^9 &lt;= A[i] &lt;= 10^9 * @param {number[]} A * @return {number} */var fixedPoint = function (A) {} 123456789101112131415161718192021function fixedPoint(A){ let low = 0; let high = A.length - 1; let mid; let result; while(low &lt;= high){ mid = Math.floor((low + high) / 2); if(A[mid] &gt;= mid){ high = mid - 1; result = mid; }else{ low = mid + 1; } } return A[result] == result ? result : -1;}fixedPoint([-10,-5,0,3,7]); // 3fixedPoint([0,3,7,8,10]); // 0fixedPoint([-10,-5,3,4,7,9]); // -1 Codility - MinMaxDivision題目：You are given integers K, M and a non-empty array A consisting of N integers. Every element of the array is not greater than M. You should divide this array into K blocks of consecutive elements. The size of the block is any integer between 0 and N. Every element of the array should belong to some block. The sum of the block from X to Y equals A[X] + A[X + 1] + … + A[Y]. The sum of empty block equals 0. The large sum is the maximal sum of any block. 123456789101112131415161718192021222324252627282930313233343536373839For example, you are given integers K = 3, M = 5 and array A such that: A[0] = 2 A[1] = 1 A[2] = 5 A[3] = 1 A[4] = 2 A[5] = 2 A[6] = 2The array can be divided, for example, into the following blocks:[2, 1, 5, 1, 2, 2, 2], [], [] with a large sum of 15;[2], [1, 5, 1, 2], [2, 2] with a large sum of 9;[2, 1, 5], [], [1, 2, 2, 2] with a large sum of 8;[2, 1], [5, 1], [2, 2, 2] with a large sum of 6.The goal is to minimize the large sum. In the above example, 6 is the minimal large sum.Write a function:function solution(K, M, A);that, given integers K, M and a non-empty array A consisting of N integers, returns the minimal large sum.For example, given K = 3, M = 5 and array A such that: A[0] = 2 A[1] = 1 A[2] = 5 A[3] = 1 A[4] = 2 A[5] = 2 A[6] = 2the function should return 6, as explained above.Write an efficient algorithm for the following assumptions:N and K are integers within the range [1..100,000];M is an integer within the range [0..10,000];each element of array A is an integer within the range [0..M]. 1 參考資料 前端工程師用 javaScript 學演算法 Data Structures and Algorithms (DSA)","link":"/2023/09/27/leetcodeDay3/"},{"title":"[用JS來寫演算法和了解資料結構] Day4 陣列 leetcode #905, #561","text":"Leetcode 陣列題型這篇會跟著 Hannah 的鐵人賽刷的題目，會慢慢再更新其他題目。 leetcode #905. Sort Array By Parity12345678910111213141516171819202122232425/*Given an array A of non-negative integers, //正整數的陣列return an array consisting of all the even elements of A, followed by all the odd elements of A.// 回傳陣列，前面是偶數後面是奇數。You may return any answer array that satisfies this condition.Example 1:Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.Note:1 &lt;= A.length &lt;= 50000 &lt;= A[i] &lt;= 5000*//** * @param {number[]} A * @return {number[]} */var sortArrayByParity = function (A) {}; 這題我的想法是把偶、奇數分別丟到兩個陣列，最後再合併。 1234567891011121314var sortArrayByParity = function (A) { let evenAry = []; let oddAry = []; A.forEach(n =&gt; { if (n % 2 === 0) { evenAry.push(n); } else { oddAry.push(n); } }); return [...evenAry, ...oddAry];};sortArrayByParity([3, 1, 2, 4]); 一行 code.. 但跑兩次 filter 應該是 n^2 12345var sortArrayByParity = function (A) { return A.filter(n =&gt; n % 2 == 0).concat(A.filter(n =&gt; n % 2 == 1));};sortArrayByParity([3, 1, 2, 4]); 偶數從前面插入 unshift ，奇數才後面 push 123456789var sortArrayByParity = function (A) { let ary = []; A.forEach(item =&gt; { item % 2 == 0 ? ary.unshift(item) : ary.push(item); }); return ary;};sortArrayByParity([3, 1, 2, 4]); leetcode #561. Array Partition I1234567891011121314151617181920212223242526272829303132333435/*Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.// 給一個 有2倍數量 值的陣列nums// 比較兩兩成對後的最小值的加總，再比較各種可能中的找出最大值// 回傳找出的最大值Example 1: Input: nums = [1,4,3,2]Output: 4Explanation: All possible pairings (ignoring the ordering of elements) are:1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 32. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 33. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4So the maximum possible sum is 4.Example 2:Input: nums = [6,2,6,5,1,2]Output: 9Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.Constraints:1 &lt;= n &lt;= 104nums.length == 2 * n-104 &lt;= nums[i] &lt;= 104 // 有可能有負值/** * @param {number[]} nums * @return {number} */var arrayPairSum = function (nums) {}; 小排到大後，一對中的較小值 (因為已經排序好了所以就是一對中的第一個) 的 加總 1234567891011var arrayPairSum = function (nums) { let len = nums.length; let sum = 0; nums = nums.sort((a, b) =&gt; a - b); for (let i = 0; i &lt; len; i += 2) { sum += nums[i]; } return sum;};arrayPairSum([6, 2, 6, 5, 1, 2, 7, 9]); // 1+2+6+7 = 16","link":"/2023/09/29/leetcodeDay4/"},{"title":"[JS] localStorage 怎麼用？和Cookie、Session Storage差在哪？","text":"前言localStorage在許多網站上很常會應用到，這篇會來整理localStorage的用法，另外會比較Cookie和Session Storage。 localStorage 是什麼呢？localStorage 是什麼呢？ 一個可以儲存資料的儲藏室，當重新整理瀏覽器資料不會消失。購物網站上常常會有你最近看過的商品，再次出現在網站上，最近收尋過的關鍵字等等，便是使用localStorage的方式。 localStorage會在同一個網址文件(Document)底下存資料。儲存資料並無到期的限制。 從開發者工具的Application中可以查看Local Storage儲存的資料。 儲存到 Local Storage12345// 可以設定儲存的資料名稱Key和值ValuelocalStorage.setItem('Key', Value);// 儲存值為字串形式，若值為物件則可用JSON.stringify(data)轉為字串localStorage.setItem('Key', JSON.stringify(data)); 取得 Local Storage 資料123localStorage.getItem('Key');// 取得物件資料時 則可用JSON.parse(localStorage.getItem('Key'))轉為物件 刪除 Local Storage 資料1localStorage.removeItem('Key'); 清空 Local Storage 資料1localStorage.clear(); Local Storage、Session Storage和Cookie的差異這三者都會在同一個網址文件(Document)底下存資料。 Local Storage 是否隨著 http req/res：No被限制在該網站的規範內，其他網站無法存取。 生命期限: 無限制儲存資料並無到期的限制，目前瀏覽器頁面被關閉時不會被清除。 儲存位置：Browser Only 可取範圍(accessible from)：Any window of browser 資料儲存量：10mb 左右 Session Storage http req/res：No被限制在該網站的規範內，其他網站無法存取。 生命期限: On Tab closeSessionStorage 的儲存資料於目前瀏覽頁狀態結束的同時將一併被清除 — 也就是目前瀏覽器頁面被關閉時或是還原頁面時。 儲存位置：Browser Only 可取範圍(accessible from)：Same Tab 資料儲存量：5mb 左右 與LocalStorage語法一樣 1234567891011// 將資料存到sessionStoragesessionStorage.setItem('key', 'value');// 從sessionStorage取得之前存的資料var data = sessionStorage.getItem('key');// 從sessionStorage移除之前存的資料sessionStorage.removeItem('key');// 從sessionStorage移除之前存的所有資料sessionStorage.clear(); Cookiecookie 是在瀏覽器端一個儲存少量資料的空間。當瀏覽器與server 互動時 cookie 就會隨著 http request / response 來回傳送。通常由伺服器透過 Set-Cookie header 傳遞給瀏覽器。瀏覽器收到後會將 cookie 儲存起來，並在之後的請求回傳 cookie 至同樣的伺服器。可以應用於網站後台驗證、追蹤使用者行為及廣告上。 http req/res：Yes 生命期限: 用戶/server 手動設定 儲存位置：Browser and Server 可取範圍(accessible from)：Any window of browser 資料儲存量：4kb 左右 1234document.cookie = \"yummy_cookie=choco\"; document.cookie = \"tasty_cookie=strawberry\"; console.log(document.cookie); // logs \"yummy_cookie=choco; tasty_cookie=strawberry\" 更詳盡的使用方法，這篇主要是整理LocalStorage，cookie的部分就先不整理。更多關於cookie可參考什麼是 Cookie？如何用 JS 讀取/修改 document.cookie? LocalStorage 實例之前在Udemy上課時，製作的一個電影院座位選位的小程式，使用localStorage 存儲已選的座位與電影。 DEMO 參考資料 MDN - Window.localStorage MDN - Using HTTP cookies 重要的基礎：Cookie v.s Session Storage v.s Local Storage And Cookie-based v.s Token-based Authentication 什麼是 Cookie？如何用 JS 讀取/修改 document.cookie?","link":"/2020/12/02/localStorage/"},{"title":"物件與繼承 -2","text":"物件導向程式設計(OOP)分為層次有：Layer 1： 單一物件的物件導向(OOP)Layer 2： 物件的原型鍊(Prototype chains)Layer 3: 建構器(Constructor)作為實體的工廠Layer 4: 衍生子類別(subclassing)藉由繼承現有建構器來建立新的建構器 Layer 1： 單一物件的物件導向(OOP)JS中所有物件都是mappings特性or屬性(property)： key : value 字串 : 任何js的值、函式(methods方法) 特性又分成三種 具名的資料特性 properties(named data properties) 最常見 key: value的mappings關係 具名的存取器特性 accessors (named accessor properties) 調用時像是在讀取或寫入特性 eg. setter, getter 內部特性 (internal properties) js無法直接取用，可用間接方式存取 12const obj = {name: '123'};console.log(Object.getPrototypeOf(obj)); 物件字面值, 點號運算子1234567891011121314151617181920212223242526const student = { name: 'Allen', describe: function(){ return `his name is ${this.name}` },};//讀取student.name; //Allen//呼叫方法student.describe(); //'his name is Allen'//設定student.name = 'John';//刪除 //key, value皆會被刪除 不能刪除繼承而來的特性delete student.name; //truestudent.name // undefined //帶入特性描述器Object.defineProperty(student, 'name', { value: 'Tom', configurable: false});delete student.name; //false 特殊key值 變數不能用的保留字 var, function…etc 數字為key字時為字串，點號運算子只能存取key值為識別字 ‘任意字串’123456789const obj = { function: 1, 0.2 : 'hello', 'how are you': 'fine',};obj['0.2'];obj['how are you']; 方框運算子 [experssion]12345678910111213141516const obj = { 0.2 : 'hello', describe: function(){ return true; },};'//讀取obj[0.1+0.1]; //數字強制轉字串 //'hello'//呼叫方法obj['describe'](); //'his name is Allen'//設定obj['color'] = 'red';//刪除 delete obj['color']; // true 轉為物件 Object() 參數值 結果 不帶參數 {} undefined {} null {} Boolean值bool new Boolean(bool) 數值 num new Number(num) 字串值str new String(str) 物件 obj(不變) this 函式中隱藏的參數 寬鬆模式sloppy mode： this指向為全域物件window 嚴格模式strict mode： undefined 函式中 this 是函式被調用時的那個物件(receiver) call(), apply(), bind() 常見陷阱 nested function12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const obj = { firstName: 'Jane', friends : ['Allen', 'John'], loop: function(){ 'use strict'; this.friends.forEach( function(friend){ console.log(`${this.firstName}的朋友是${friend}`); }); },};obj.loop();//use strict this會是 undefined// 寬鬆模式 this 指向全域window.firstName undefined解法1. that = thisconst obj = { firstName: 'Jane', friends : ['Allen', 'John'], loop: function(){ 'use strict'; let that = this; this.friends.forEach( function(friend){ console.log(`${that.firstName}的朋友是${friend}`); }); },};解法2. bind()const obj = { firstName: 'Jane', friends : ['Allen', 'John'], loop: function(){ 'use strict'; this.friends.forEach( function(friend){ console.log(`${this.firstName}的朋友是${friend}`); }.bind(this)); },};解法3. 指定callback的this值const obj = { firstName: 'Jane', friends : ['Allen', 'John'], loop: function(){ 'use strict'; this.friends.forEach( function(friend){ console.log(`${this.firstName}的朋友是${friend}`); },this); },};解法4. 箭頭函式const obj = { firstName: 'Jane', friends : ['Allen', 'John'], loop: function(){ 'use strict'; this.friends.forEach((friend)=&gt;{ console.log(`${this.firstName}的朋友是${friend}`); }); },};' Layer 2： 物件的原型鍊(Prototype chains)JavaScript 是一個以原型為基礎 (Prototype-based)、多範型的、動態語言。支援物件導向(Object-oriented programming, OOP)、指令式以及宣告式 (如函數式程式設計)。 物件導向程式設計 OOP是將 軟體 想像成由一群物件交互合作所組成，而非以往以函數 (Function) 或簡單的指令集交互合作所組成。在物件導向的架構中，每個物件都具有接收訊息，處理資料以及發送訊息給其他物件的能力。每個物件都可視為獨一無二的個體，他們扮演不同的角色並有不同的能力及責任。物件導向程式設計強調模組化，使得程式碼變的較容易開發和理解。 類別 (Class) 和 物件 (Object)類別 (Class)類別是用來定義物件的屬性 (properties) 和方法 (methods)的藍圖。 物件 (Object)物件為一個類別的實體 (Instance)，包含屬性 (properties)與方法 (methods)的資料結構。 上述有提到Javascript是以原型為基礎 (Prototype-based)的語言，不用先設計藍圖(類別)就可以建立物件，是無類別的 (Classless)。 那JS沒有類別要如何用原型基礎來實現物件導向的概念呢？JS的物件透過原型(Prototype)相互繼承各自功能，形成原型鍊(Prototype Chain)。建立物件時，會用一個函式function也就是建構器 (Constructor)來定義物件的藍圖，類似類別的概念。 ES6有個class的新語法，只是個語法糖，讓建構器 (Constructor)的寫法更簡潔易懂，更近似於其他物件導向語言C++、JAVA定義類別的方式，但JavaScript仍然是基於原型的語言。 Object.create() 建立繼承給定原形的新物件用(物件a)作為原型來建立新的物件b新物件b繼承了物件a的屬性與方法 12345678910111213const a = {name: 'A'}; // a ---&gt; Object.prototype ---&gt; nullconst b = Object.create(a);// b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.name) // A//第二個引數可帶入描述器const b = Object.create(a, { realName: {value: 'B', writable: true} }); console.log(b.name, b.realName); //A, B Object.setPrototypeOf()可帶入兩個參數 第一個為接受繼承的物件 第二個為原型以下例子結果與create一樣 1234const a = {name: 'A'}; const b = {};Object.setPrototypeOf(b, a);console.log(b.name) // A getPrototypeOf() 讀取一個原型1Object.getPrototypeOf(b)=== a //true isPrototypeOf() 是否為另一個物件原型1a.isPrototypeOf(b) //true __proto__ 特殊特性 dunder proto (doubble underscore proto) 非標準ECMAScript5規費 存取器 Accessors取值器(getter) &amp; 設值器(setter)用 物件字面值 定義存取器12345678910111213let a = { ary: [10, 20, 30], get addData(){ return this.ary; }, set addData(a){ this.ary.push(a); },};a.addData = 40;console.log(a); // [10, 20, 30, 40]a.addData = 50;console.log(a); // [10, 20, 30, 40, 50] 用 特性描述器 定義存取器1234567891011121314151617181920let a = Object.create( Object.prototype, { ary: { value: [10, 20, 30] }, addData:{ get: function(){ return this.ary; }, set: function(a){ this.ary.push(a); }, } });a.addData = 40;console.log(a); // [10, 20, 30, 40]a.addData = 50;console.log(a); // [10, 20, 30, 40, 50] 特性屬性(property attributes) key值 預設值 一般特性有以下屬性 value undefined 特性的值 writable false 是否可以被更改 存取器有以下屬性 get undefined 取值器 set undefined 存值器 所有特性都有以下屬性 enumerable false 設定特性是否不可列舉 configurable false 定義特性是否可以被刪除、或修改特性內的 writable、enumerable 及 configurable 設定。例外: length 特性描述器 or 屬性描述器(property descriptor)定義屬性Object.defineProperty(obj, propKey, propDesc)Object.defineProperties(obj, propDesc)取得屬性Object.getOwnPropertyDescriptor(obj, propKey)Object.getOwnPropertyDescriptors(obj)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const obj = {};Object.defineProperty(obj, 'foo', { value: 42, writable: false, configurable: true});Object.getOwnPropertyDescriptor(obj, 'foo');//{// value: 42, // writable: false, // enumerable: false, // configurable: true // }//指定obj.foo = 'b';console.log(obj.foo); //42Object.getOwnPropertyDescriptor(obj, 'bar');//undefinedObject.defineProperties(obj, { foo: { value: 10, enumerable : true, }, bar: { value: 20, writable: true, configurable: true, }});Object.getOwnPropertyDescriptors(obj);// {// \"foo\": {// \"value\": 10,// \"writable\": true,// \"enumerable\": true,// \"configurable\": true// },// \"bar\": {// \"value\": 20,// \"writable\": true,// \"enumerable\": false,// \"configurable\": true// }// } 特性的迭代與偵測列出自有特性的key值 Object.getOwnPropertyNames(obj) Object.keys(obj) 列出所有特性的key值 for-in 迴圈 hasOwnProperty() 此物件本身是否有這個屬性 (原型的屬性不算)12345678var a = {name: 'Zoe'}; var b = {sex: 'female'}; Object.setPrototypeOf(b, a); console.log(b.hasOwnProperty('sex')); //trueconsole.log(b.hasOwnProperty('name')); //falseconsole.log(b.hasOwnProperty.call(a, 'name')); //true key值 in obj 此物件是否有這個屬性 (包含原型的屬性)123456var a = {name: 'Zoe'}; var b = {sex: 'female'}; Object.setPrototypeOf(b, a); console.log('name' in b); //trueconsole.log('sex' in b); //true 計算物件自有特性的數量Object.keys(obj).length1Object.keys(b).length //1 可列舉不可列舉||自有可列舉特性|原型可列舉特性|不可列舉特性 || ——– | ——– | ——– |——– |——– |for…in| O| O| X|Object.keys| O| X| X|Object.getOwnPropertyNames|O|X|O| 保護物件: （弱 -&gt; 強）1. 防止擴充 Object.preventExtensions(obj)檢查是否可擴充 Object.isExtensible(obj) true/false123456789101112const obj = {};Object.preventExtensions(obj);obj.bar='b';obj.bar //undefinedObject.defineProperty(obj, 'foo', { value: 10});// Uncaught TypeError: Cannot define property foo,// object is not extensible 2. 密封 Object.seal(obj)防止擴充，把 configurable 設成-&gt; false （唯讀狀態）只可變更已有的key值的value值 檢查是否密封 Object.isSeal(obj) true/false1234567891011const obj = {foo: 'a'};Object.seal(obj);obj.bar='b';obj.bar //undefinedObject.defineProperty(obj, 'foo', { value: 10});// 只可變更已有的key值的value值 3. 凍結 Object.freeze(obj)以上效果皆有並且無法寫入已有的key值的value值 檢查是否凍結 Object.isFrozen(obj) true/false陷阱保護只是淺層(shallow) Object.prototype 原型也是可變的 – Layer 3: 建構器(Constructor)作為實體的工廠Layer 4: 衍生子類別(subclassing)藉由繼承現有建構器來建立新的建構器","link":"/2021/06/29/object/"},{"title":"[JS] 關於時間 new Date()","text":"關於時間在JavaScript中取得時間，可用new Date()，它是一個JS內建的一個Constructor，內容可以帶入參數來取得特定時間，不帶入參數則取得現在時間。 1234567891011121314151617181920let d = new Date(); //取得現在時間 Tue Nov 24 2020 21:35:56 GMT+0800 (台北標準時間)let d = new Date(milliseconds); // 可帶入timeStamp毫秒 (182401980000)let d = new Date(dateString);//可帶入時間字串 (\"October 13, 1975 11:13:00\")let d = new Date(year, month, day, hours, minutes, seconds, milliseconds); // (79,5,24,11,33,0)console.dir(d); //可用dir來查看date的方法 //時間物件轉換成 Timestampd.getTime() d.valueOf() // 時間物件轉換成 TimestampNumber(d) // 轉換成數值 TimeStamp+d // 轉換成數值 TimeStampDate.now() //可取得當下的timestamp（毫秒） 取得日期時間中某個值 get 較需注意day和month回傳的是索引值，起始值0為週日和一月 12345678910const d = new Date(); //Tue Nov 24 2020 22:45:39 GMT+0800 (台北標準時間)const date = d.getDate(); //24const day = d.getDay(); //2 = Tue (Sunday is 0, Monday is 1, and so on.)const month = d.getMonth(); //10 = Nov (0 = Jan ~ 11 = Dec)const year = d.getFullYear(); //2020const hour = d.getHours() //0-24const minute = d.getMinutes() //0-59const second = d.getSeconds() //0-59const ms = d.getMilliseconds() //0-999 時間物件轉換字串123456789d.toString() // Tue Nov 24 2020 22:45:39 GMT+0800 (台北標準時間)d.toTimeString() // 22:45:39 GMT+0800 (台北標準時間)d.toDateString() // Tue Nov 24 2020d.toISOString() // 轉換成 ISO 8601 格式的字串 2020-11-24T14:45:39.070Z//依照JavaScript程式所執行的環境(瀏覽器)進行本地化d.toLocaleString() // 2020/11/24 下午22:45:39d.toLocaleDateString() // 2020/11/24d.toLocaleTimeString() // 下午22:45:39 好用的 toLocaleString() 轉字串toLocaleString()的參數中可以帶入語言和自定義模式 語言參數：英文 ‘en-US’ // 12/1/2020, 11:57:04 PM繁中 ‘zh-Hant’ // 2020/12/1 下午11:57:04簡中 ‘zh-Hans’日文 ‘ja-JP’ // 2020/12/1 23:57:04 自定義參數：year: ‘numeric’, ‘2-digit’ 數字或是兩位數month: ‘numeric’, ‘2-digit’, ‘narrow’, ‘short’, ‘long’. 數字,文字 是否縮寫day: ‘numeric’, ‘2-digit’ 數字或是兩位數weekday: ‘narrow’, ‘short’, ‘long’ 星期 文字是否縮寫等hour: ‘numeric’, ‘2-digit’ 數字或是兩位數minute: ‘numeric’, ‘2-digit’ 數字或是兩位數second: ‘numeric’, ‘2-digit’ 數字或是兩位數 1234let myDate = new Date();let options = { year: '2-digit', day: 'numeric', weekday: 'long', month: 'short' };// Wednesday, Dec 2, 20 沒有定義的時間部分則不會出現myDate.toLocaleString('en-US', options); 另外 .toLocaleString() 也可以用在轉換數字格式，數字千位數加上逗號或是貨幣，百分比等。可參考下面這篇 使用 .toLocaleString() 輕鬆實現多國語言價格數字格式化 設定時間 setJavaScript中的日期格式字串在不同瀏覽器的設定可能不同，可以查看下面這個格式相容表 時間日期字串格式相容表 通用的格式年/月/日2020/02/122020/2/122020/02/12 12:102020/02/12 12:10:56 月/日/年01/02/20201/2/20201/2/2020 12:10 ISO 8601 格式YYYY-MM-DDTHH:mm:ss.sssZ2020-11-24T14:45:39.070Z T 用來分隔 年月日 和 時分秒毫秒 Z 為UTC標準時間，其他時區的時間可以用+或-，再加上HH:mm作為時區的表達式 設定時間的方法123456789let myDate = new Date();myDate.setFullYear(2010); //4位數字myDate.setMonth(1); //索引值 0-11myDate.setDate(7); //1-31 myDate.setHours(11); myDate.setMinutes(20);myDate.setSeconds(60);myDate.setMilliseconds(150); 可設定時間增減，比較前後12345678910const today = new Date(); //Wed Nov 25 2020 00:01:45 GMT+0800 (台北標準時間)let myDate = new Date();myDate.setDate( today.getDate() - 20); // 可設定 20天前 Thu Nov 05 2020 00:01:45 GMT+0800if ( myDate &gt; today ){ console.log('今天在2020.11.05之前');} else { console.log('今天在2020.11.05之後');} TimeZone 不同時區 UTC 世界協調時間（Coordinated Universal Time） GTM 格林威治標準時間（Greenwich Mean Time） GMT 和 UTC 在一般使用的情況下沒有差別，台灣的時區是 UTC+8 或是 GMT+8 都可以。 偏移(offset)某地區與 UTC 偏移的時間，例如 +08:00，表示該地區的時間比 UTC 快了 8 小時。.getTimezoneOffset() 以台灣為例，取得的值為-480，除以 60 正負相反後則為 +8。 12const today = new Date(); today.getTimezoneOffset() // -480 GMT+0800 (台北標準時間) 處理時區的函式庫 Moment Timezone moment.js - 關於時間的一切 月曆時鐘之前在做JS30時鐘時，順便加上了月曆和數字鐘的功能 See the Pen [JS30][Day2] Clock &amp; Calender by KaiYun Cheng (@kaiyuncheng) on CodePen. 參考資料 JavaScript Date（日期） 对象 JavaScript Date 時間和日期 日期與時間 從零開始的學習 JS 生活-第二十一日 [JS] JavaScript Date Time Method 日期時間 前端工程研究：關於 JavaScript 中 Date 型別的常見地雷與建議作法","link":"/2020/11/24/newDate/"},{"title":"[JS] 關於 Operators 運算子","text":"運算子 (Operators)大部分的運算子只能搭配基本型別值使用，代表物件會先被強制轉型成基本型別，再進行運算。 12[1, 2] + [3] // \"1,23\"// String([1, 2]) + String([3]) 分類： 賦值運算子(assignment Operators) or 指定運算子 相等性運算子(Equality operators) 關係運算子(Relational operators) or 順序運算子(ordering operators) 加法運算子(plus operator) 特殊運算子 運算元的型別一樣 A. 數字運算子A-1. 算數運算子(arithmetic operators)eg. (+, -, *, /, %, **(指數: 計算x的y次方 2 ** 3 = 8), ++, - -, -x, +y ) A-2. 位元運算子 (bitwise operators)eg. (~x, x&amp;y , x|y, x^y, x&lt;&lt;y, x&gt;&gt;y, x&gt;&gt;&gt;y) B. 布林運算子B-1. 二元邏輯運算子eg. (x&amp;&amp;y, x||y) B-2. 邏輯Noteg. (!x) 1. 賦值運算子 (assignment operators) or 指定運算子賦值運算子會根據其右側運算元的數值處理後賦值給其左側的運算元。 = : 賦值運算子 (assignment operator)1x=y=z=12 //x=12 y=12 z=12 += -= :複合賦值運算子 (compound assignment operator) 算術運算(Arithmetic operators): *=, /=, %=, +=, -= 12let x = 2;x+=3 //x=x+3 x=5 位元運算(bitwise operators): &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=, &amp;=, ^=, |= 字串串接(string concatenation): += 2. 相等性運算子 (Equality operators)=== !== : 嚴格相等,不等只比較同樣型別的值是否相等 12345678910111213undefined === undefined // truenull === null // true//數字+0 === -0 // trueNaN === NaN //** false//字串 布林 結果很明顯//物件 記憶體位置不同let b = {}, c = {};b === c // false == != : 寬鬆相等,不等若是兩個運算元型別相同則以嚴格相等比較，若不同則會先試著轉換不同型別的再比較是否相等 123456789101112131415161718192021222324252627//視為寬鬆相等undefined == null // true //數字 與 字串(-&gt;數字) 1 == '1' // true0 == '' // 0 === 0 // true123 == '\\n\\t123\\r' // true//非布林 與 布林(-&gt;數字)1 == true // true'' == false // '' == 0 -&gt; 0 === 0 // true//數字或字串 與 物件(-&gt;ToPrimitive() 轉為基型值)let obj = {x:2}; //obj.valueOf() -&gt; obj.toString()obj == '[object Object]'; // true123 == ['123'] //true ['123'].toString() 0 == [] // [].toString() -&gt; 0 == '' // true//上述情形不適用則為false0 == undefined // false0 == null // false 檢查x是一個非值嗎？ (p89)123456789if(x === undefined || x === null){ ...}if(x == undefined || x == null){ ...} 3. 關係運算子(Relational operators) or 順序運算子(ordering operators)&lt; &lt;= &gt; &gt;=123456789// 物件 (-&gt;ToPrimitive() 轉為基型值)//字串 比較16位元編碼順序'apple' &lt; 'orange' // true'apple' &lt; 'Orange' // false// 兩個運算元轉為數字比較 4. + 加法運算子(plus operator)12345678// 物件 (-&gt;ToPrimitive() 轉為基型值)//其中一個為字串 則會串接'colors: ' + ['red', 'blue', 'green'] // 'colors: red,blue,green'//兩個運算元轉為數字加起來3 + true // 4 5. 特殊運算子? : 條件運算子 or 三元運算子(condition ? ifTrue : ifFalse) 1let x = isMember ? '$2.00' : '$10.00'; , 逗號運算子逗號運算子允許在一個敘述句中執行多個運算式並回傳最後一個運算式的結果。 1123, 'abc' // 'abc' 運算子優先序 void 運算子123void 0 //undefinedvoid 4+7 //NaN (void 4)+7void (4+7) //undefined void的用途: void 0 為 undefined 的同義詞。 丟棄一個運算式的回傳值。1javascript: void window.open('http://example.com') 置於一個IIFE前 typeof 和 instanceof typeof: 運算子區別基本型別與物件，並判斷基本型別 運算元 結果 undefined, 未宣告的變數 ‘undefined’ null ‘object’ (是一個BUG) Boolean值 ‘boolean’ 數值 ‘number’ 字串值 ‘string’ 函式 ‘function’ 其他所有一般值 ‘object’ instanceof: 判斷一個物件是否為給定建構器(constructor)的實體 123456{} instanceof Object //true 好像會報錯[] instanceof Array //true[] instanceof Object //trueundefined instanceof Object //falsenull instanceof Object //false 物件運算子 new delete in 參考資料與延伸閱讀：Speaking JavascriptMDN 運算式與運算子運算子優先序","link":"/2022/04/10/operator/"},{"title":"","text":"KaiYun Cheng Greater Boston, MA Projects The Better Aging WebsiteArticles Website Live Demo Github OverviewThe Better Aging Website is a news platform dedicated to middle-aged and elderly readers. I played a key role in redesigning the layout and implementing front-end programming using the Next.js framework. The website boasts an array of features, including a homepage carousel, a popular articles section, author-specific pages, and dedicated sections for video content and podcasts. These enhancements contribute to a more dynamic and engaging user experience, offering a diverse range of content formats to cater to the preferences of our audience. Technologies Used Next.js RESTful API Tailwind CSS Responsive Web Design Integration of Google Tag Google SEO Git Version Control Server-Side Rendering Capture StudioPhotography Service E-commerce Website Live Demo Github OverviewCapture Studio is an e-commerce website using Vue.js. I started this side project from scratch, which involved designing the layout, creating wireframes, and programming. The website features include showcasing photography services/products, client albums, a shopping cart, and a checkout system. On the backend platform, functionalities include login authentication, management of services/products for listing and publishing, coupon management, order management, and image management. Technologies Used Vue.js / Vue Router / Vue Cli ESLint with the Airbnb syntax standards RESTful API Bootstrap Responsive Web Design SCSS Git Version Control Big Five Personality Traits TestVue.js Questionnaire Assessment Tool Live Demo Github OverviewThe Big Five Personality Traits Test is a Vue.js Single Page Application (SPA) integrated with an Open-Source Psychological Assessment API. Features include a 10-question questionnaire, questionnaire verification, test score statistics, and result analysis. Technologies Used Vue.js Axios RESTful API Responsive Web Design SCSS Git Version Control","link":"/portfolio/index.html"},{"title":"[JS] 物件導向: 原型Prototype與物件Object","text":"前言這篇會來整理關於JS原型、類別、物件導向、原型鍊、繼承、建構子等。這幾個關聯又有點難懂的關鍵字，在學JS時時常聽到，一開始只是去使用JS、Vue到現在去了解他背後運作的原理，才恍然大悟原是這樣啊！ JavascriptJavaScript 是一個以原型為基礎 (Prototype-based)、多範型的、動態語言。支援物件導向(Object-oriented programming, OOP)、指令式以及宣告式 (如函數式程式設計)。 物件導向程式設計 OOP是將 軟體 想像成由一群物件交互合作所組成，而非以往以函數 (Function) 或簡單的指令集交互合作所組成。在物件導向的架構中，每個物件都具有接收訊息，處理資料以及發送訊息給其他物件的能力。每個物件都可視為獨一無二的個體，他們扮演不同的角色並有不同的能力及責任。物件導向程式設計強調模組化，使得程式碼變的較容易開發和理解。 類別 (Class) 和 物件 (Object) 類別 (Class)類別是用來定義物件的屬性 (properties) 和方法 (methods)的藍圖。 物件 (Object)物件為一個類別的實體 (Instance)，包含屬性 (properties)與方法 (methods)的資料結構。 上述有提到Javascript是以原型為基礎 (Prototype-based)的語言，不用先設計藍圖(類別)就可以建立物件，是無類別的 (Classless)。 那JS沒有類別要如何用原型基礎來實現物件導向的概念呢？JS的物件透過原型(Prototype)相互繼承各自功能，形成原型鍊(Prototype Chain)。建立物件時，會用一個函式function也就是建構式 (Constructor)來定義物件的藍圖，類似類別的概念。 ES6有個class的新語法，只是個語法糖，讓建構式 (Constructor)的寫法更簡潔易懂，更近似於其他物件導向語言C++、JAVA定義類別的方式，但JavaScript仍然是基於原型的語言。 建構式 (Constructor) aka 建構子 建構器Constructor為用來定義物件的藍圖，可以定義物件的屬性、物件本身的方法。也可以藉由.prototype來定義該Constructor原型的方法。 在Javascript中有以下內建的ConstructorString(),Number(),Boolean(),Array(),Object(),Function(),RegExp(),Date(),Error(),Symbol() 當然也可以自定義Constructor，而要建立新物件時，可以在Constructor前面用 new 這個關鍵字 123456789101112131415161718192021222324// 自定義Constructor 名稱第一個字為大寫function CarFactory (brand, model, price){ // 定義物件的屬性 this.brand = brand; this.model = model; this.price = price; // 定義物件本身的方法 this.description = function(){ console.log(`Brand ${brand}, this year new model ${model} is $${price}`); }; } // 定義原型上的方法CarFactory.prototype.discount = function() { this.discountPrice = this.price * 0.9; console.log(`New Car gets 10% off, the discounted price is $${this.discountPrice}`);}; var berlingo = new CarFactory( 'Citroen', 'Berlingo', '40000');berlingo.description(); //物件本身的方法berlingo.discount(); //CarFactory物件原型上的方法，並不在物件本身上var vios = new CarFactory( 'Toyota', 'Vios', '20000');vios.description();vios.discount(); 以ES6 Class 的寫法則為 1234567891011121314151617181920212223242526class CarFactory { constructor(brand, model, price) { this.brand = brand; this.model = model; this.price = price; // 定義物件上的方法 this.description = function(){ console.log(`Brand ${brand}, this year new model ${model} is $${price}`); }; } // 定義原型上的方法 discount(){ this.discountPrice = this.price * 0.9; console.log(`New Car gets 10% off, the discounted price is $${this.discountPrice}`); }}var berlingo = new CarFactory( 'Citroen', 'Berlingo', '40000');berlingo.description(); //物件本身的方法berlingo.discount(); //CarFactory物件原型上的方法，並不在物件本身上var vios = new CarFactory( 'Toyota', 'Vios', '20000');vios.description();vios.discount(); .prototype 定義原型方法藉由.prototype來定義新增該Constructor原型的方法。很多Polyfill就用這種做法在某些版本瀏覽器不支援時，在原型上增加語法。 原型(prototype) 和 原型鏈 (Prototype Chain)若我們用上述的例子來舉例 Console.log(berlingo)後會發現物件上除了本身的屬性和方法外，會有一個__proto__可以展開，這就是CarFactory這個原型，用.prototype定義的屬性和方法則會在原型上，然後我們會發現CarFactory這個原型上還有個__proto__:Object，這個是物件最上層的原型Object Prototype，所有物件最上層的原型都是Object Prototype，再往上則會是空值Null。 在CarFactory這個原型我們定義了discount()這個方法，這個方法是一個函式，展開後我們會發現__proto__:f()，就是函式的原型，可以看到函式的內建方法bind、call、apply等等，函式原型裡頭又會有個最上層的物件原型Object Prototype。 這種一層一層原型接來接去，就是原型鏈 (Prototype Chain)的概念。 繼承(Inheritance)原型這樣接來接去，會繼承上面那個原型的屬性和方法。用同樣上述例子，berlingo這個物件本身是沒有discount()這個方法，而是berlingo繼承了CarFactory這個原型上的方法，所以berlingo也可以使用。 instanceof 查看原型語法以 上述建構式 為例： 12console.log(vios instanceof CarFactory); // true CarFactory 是vios的原型console.log(vios instanceof Object); // true Array陣列、Array-like類陣列DOM方法取得的並不是一般的陣列是類陣列，可以看到他的原型是NodeList，跟Array的原型_proto_: Array 不同。因此Array可以使用的方法，NodeList不一定有，像是.map()等。Arguments也是一種類陣列，可用…展開或array.from轉成陣列。 1234567891011121314var divList = document.querySelectorAll('div');// __proto__: NodeList//可用...展開或array.from轉成陣列var divArr = [...divList];var divArr = Array.from(divList);function fn(a){ return arguments; //__proto__: Object} var args = fn('1','2','3','4');var fnArr = [...args];var fnArr = Array.from(args); Object.create() 繼承ES6的新語法 用(物件a)作為原型來建立新的物件b新物件b繼承了物件a的屬性與方法 123var a = {name: 'Zoe'}; // a ---&gt; Object.prototype ---&gt; nullvar b = Object.create(a); // b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.name); //Zoe Object.setPrototypeOf()可帶入兩個參數 第一個為接受繼承的物件 第二個為原型以下例子結果與create一樣 12345678910var a = {name: 'Zoe'}; // a ---&gt; Object.prototype ---&gt; nullvar b = {}; Object.setPrototypeOf(b, a); // b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.name); //Zoe var c = {age: 18};Object.setPrototypeOf(b, c); // b ---&gt; c ---&gt; Object.prototype ---&gt; null//同一個物件無法指定兩種原型物件Object.setPrototypeOf(c, a); // c先繼承aObject.setPrototypeOf(b, c); // b再繼承c 則也會有a的屬性 ES6 Class, Extend, Super ES6 Class語法 1234567891011121314151617181920212223242526272829class CarFactory { constructor(model, price) { this.model = model; this.price = price; // 定義物件上的方法 this.description = function(){ console.log(`this year new model ${model} is $${price}`); }; } // 定義原型上的方法 discount(){ this.discountPrice = this.price * 0.9; console.log(`New Car gets 10% off, the discounted price is $${this.discountPrice}`); }};class Toyota extends CarFactory{ //Toyota 繼承 CarFactory原型 constructor(model, price, brand) { super(model, price) //CarFactory原型 原有變數 this.brand = brand; //Toyota原型 新增的變數 }; introduce(){ console.log(`${this.model} is a ${this.brand} car.`); };};var wish = new Toyota('Wish', '20000', 'Toyota');wish.introduce(); .hasOwnProperty()此物件本身是否有這個屬性 (原型的屬性不算); 12345var a = {name: 'Zoe'}; var b = {sex: 'female'}; Object.setPrototypeOf(b, a); console.log(b.hasOwnProperty('name')); //falseconsole.log(b.hasOwnProperty('sex')); //true in 判斷物件是否有繼承到這個屬性b裡是否有繼承到name這個屬性 1console.log('name' in b); //true 最頂層 物件原型 Object Prototype的方法 更改屬性值 Object.definePropertyObject.defineProperty(obj, Property, descriptor)第一個變數是要定義的物件第二個變數是要定義物件的屬性第三個則是屬性描述器 valueOf() 取得屬性值 屬性描述器（Property descriptor）可用 Object.getOwnPropertyDescriptor(obj, property) 取得屬性描述在 屬性描述可分成有六種數值 value(選填 預設undefined): 屬性的值 writable(選填 預設false): 定義屬性是否可以改變，如果是 false 那就是唯讀屬性。 enumerable(選填 預設false): 定義物件內的屬性是否可以透過 for-in 語法來迭代。 configurable(選填 預設false): 定義屬性是否可以被刪除、或修改屬性內的 writable、enumerable 及 configurable 設定。 get(選填 預設undefined): 物件屬性的 getter function。 set(選填 預設undefined): 物件屬性的 setter function。 1234567891011121314berlingo.price = 10000;//可透過Object.defineProperty來設定物件屬性Object.defineProperty(berlingo, 'price', { value: 10000});Object.getOwnPropertyDescriptor(berlingo, 'price');// configurable: true// enumerable: true// value: \"10000\"// writable: trueberlingo.price.valueOf(); //10000 get 和 set 存取器描述器 (Accessor Descriptor)取值器 getter: 取得指定屬性的值的方法設值器 setter: 設定指定屬性的值的方法 123456789101112let a = { ary: [10, 20, 30], get getData(){ return this.ary; }, set addData(a){ this.ary.push(a); },};a.addData = 40;a.addData = 50;console.log(a); // [10, 20, 30, 40, 50] 12345678910111213var berlingo = { price: 40000, _discount: 0.8, get discount(){ return this.price * this._discount; }, set discount(num){ this._discount = num; }};berlingo.discount = 0.7console.log(berlingo.discount); //28000 ES6 語法 1234567891011121314151617var berlingo = { price: 40000};Object.defineProperty(berlingo, 'discount', { get: function(){ return this.price * this._discount_; //40000*0.5 }, set: function(num){ this._discount_ = num; //0.5 }, configurable: true, enumerable: true});berlingo.discount = 0.5;console.log(berlingo.discount); // 20000 參考資料 MDN文件 MDN 物件導向 了解JavaScript中原型(prototype)、原型鍊（prototype chain）和繼承(inheritance)的概念 重新認識 JavaScript: Day 25 原型與繼承 重新認識 JavaScript: Day 22 深入理解 JavaScript 物件屬性 JavaScript 的原型繼承","link":"/2020/11/19/prototype/"},{"title":"[React] 一些比較容易忘記的筆記","text":"class + typescript 用法現在大多的React新專案都改成用hooks了，但還是有一些老舊專案會遇到，這邊會來記錄一下用法。 生命週期 當這個組件安裝到畫面上的時候123componentDidMount() { console.log('mount')} 當這個組件要被更新的時候123componentDidUpdate() { console.log('update', this.state)} 當這個組件要解除安裝的時候123componentWillUnmount() { console.log('btn unmount')} App.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React from 'react'// Btn組件type BtnProps = { clickHandler: () =&gt; void}type BtnState = {}class Btn extends React.Component&lt;BtnProps, BtnState&gt; { constructor(props: BtnProps) { super(props) } // 組件「將要」被解除安裝時 componentWillUnmount() { // TODO del console.log('btn unmount') } render(): React.ReactNode { return &lt;button onClick={this.props.clickHandler}&gt;+1&lt;/button&gt; }}// App 組件type AppProps = {}type AppState = { count: number}class App extends React.Component&lt;AppProps, AppState&gt; { constructor(props: AppProps) { super(props) this.state = { count: 0 } // 這一段程式碼，是保證this永遠指向APP，不管是window還是其他物件執行它 this.countClickHandler = this.countClickHandler.bind(this) } countClickHandler() { // window // TODO del console.log('this', this) this.setState((prevState) =&gt; { return { count: prevState.count + 1 } }) } // 組件被安裝時 componentDidMount() { // TODO del console.log('mount') } // 組件被更新的時候 componentDidUpdate() { // TODO del console.log('update', this.state) } render(): React.ReactNode { return &lt;&gt; &lt;h1&gt;Count: {this.state.count}&lt;/h1&gt; {this.state.count === 5 ? null : &lt;Btn clickHandler={this.countClickHandler} /&gt;} &lt;/&gt; }}export default App React HookuseState冒泡事件範例 12345678910111213141516171819const Parent: React.FC = () =&gt; { let [count, setCount] = useState(0); return ( &lt;div onClick={() =&gt; setCount(prev =&gt; prev + 1)}&gt; Parent clicked {count} times &lt;Child /&gt; &lt;/div&gt; );}const Child: React.FC = () =&gt; { let [count, setCount] = useState(0); return ( &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Child clicked {count} times &lt;/button&gt; );} 123456789101112131415161718192021222324const Counter: React.FC = () =&gt; { const [counter, setCounter] = useState(0); const handleClick = () =&gt; { function cb (prev: number) { return prev + 1 } setCounter(cb); setCounter(cb); } return ( &lt;div className='App'&gt; &lt;h1&gt;Counter 組件&lt;/h1&gt; &lt;div&gt; counter: {counter} &lt;/div&gt; &lt;br/&gt; &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt; );}export default Counter useEffect","link":"/2023/12/20/react_01/"},{"title":"[JS] 簡單認識正規表達式 Regular Expression","text":"前言這篇會來介紹正規表達式，第一次看到正規表達式時，只會想說這是什麼鬼…為何一小串就可以做完一般判斷式可能要寫好幾行的事。如果可以更深入了解活用的確可以在coding中幫助極大。因此這次我會藉由這篇讓我自己更釐清觀念。 介紹正規表達式(Regular Expression, RegEx)是被用來匹配字串中字元組合的模式。常搭配與這些字串方法(match、replace、search、split)來使用。 為什麼使用正則表達式？&gt; 用來測試字符串是否符合模式可以用於驗證，像是電話,Email,信用卡號碼是否輸入正確 &gt; 收尋匹配的字串&gt; 取代匹配到的字串&gt; 擷取出匹配到的字串正則表達式使用規則 簡易字元例如： /abc/ .replace(/abc/,’a’); 用’a’來取代匹配到的’abc’ strB 因為是abC的C為大寫，在/abc/後多加i則可以不管大小寫辨識到 strC 為ab c中有空白字元所以匹配不到 strD 在/abc/後多加g則可收尋到所有abc並且替換成a 123456789let strA = 'Hi, do you know abc?';let strB = 'The latest airplane designs evolved from slabCraft.';let strC = 'Grab crab';let strD = 'Hi abc, do you know abc?';let resultA = strA.replace(/abc/,'a'); // Hi, do you know a?let resultB = strB.replace(/abc/i,'a'); // The latest airplane designs evolved from slaraft.let resultC = strC.replace(/abc/,'a'); // ab c中有空白字元所以匹配不到let resultD = strD.replace(/abc/g,'a'); // Hi a, do you know a? 特殊字元例如： /ab*c/ *代表b可以是零或多個，所以abbbbbbc或是ac都可以匹配到 12let strA = 'Hi, do you know abbbbbbc ac abc bc?';let resultA = strA.replace(/ab*c/g,'a'); // Hi, do you know a a a bc? 圖片出處: 網頁研習室 圖片解說 字元 解說 &gt; 所有正規表示法規則都必須放到這兩者之間。 /^ 正規表示法的開始 /^A/則匹配A開頭的字元，例如Ant $/ 正規表示法的結束 /A$/則匹配A結束的字元，例如nbA [A-Z] [xyz] 字元的集合，等同於比對A到Z之間的任一大寫字母，例如[a-c]比對[abcd]這四個字母，[hcn]則比對h.c.n這三個字母 \\d [0-9] 代表比對數字格式，兩者一樣。例如/\\d/ 或 /[0-9]/ 在 “B2 is the number.” 中找到 ‘2’ {9} 樣式必須出現次數。例如/a{3}/ 無法在 “candy” 找到、但 “caaandy” 可以。[A-C]{2} 在A-C之間要符合兩次，”BA” “AC” “CA”…｜ 常用字元整理中介字元 (Meta Character) 字元 解說 /^ 正規表示法的開始 /^A/則匹配A開頭的字元，例如Ant $/ 正規表示法的結束 /A$/則匹配A結束的字元，例如nbA . 小數點 匹配任何單一字元，換行除外，例如/.n/ 匹配「nay, an apple is on the tree」中的 an 和 on，但在「nay」中沒有匹配。 字元 解說 (x) 比對x並將符合的部分存入一個變數中，例如’aaa bbb’.replace(/(…) (…)/, ‘$2 $1’)則會得到’bbb aaa’對調結果 (?:x) 比對x並將符合的部分 不存入變數中 x(?=y) 正向肯定預查，符合後面接 y 的 x x(?!y) 正向否定預查，符合後面不接 y 的 x (?&lt;=x)y 反向肯定預查，符合前面接 x 的 y (?&lt;!x)y 反向否定預查，符合後面不接 x 的 y 字元 解說 x|y x或者y [A-Z] [xyz] 字元的集合，等同於比對A到Z之間的任一大寫字母，例如[a-c]比對[abcd]這四個字母，[hcn]則比對h.c.n這三個字母 [^xyz] 則與上方相反，比對不在[]內的任一字元。例如[^ecm]比對welcome則會找到w.l.o 字元 等價 解說 \\d [0-9] 比對數字字元。例如/\\d/ 或 /[0-9]/ 在 “B2 is the number.” 中找到 ‘2’ \\D [^0-9] 比對非數字字元 \\w [A-Za-z0-9_] 比對數字字母與底線的所有字元 \\W [^A-Za-z0-9_] 比對不包含數字字母與底線的字元 \\b 比對字元的邊界，例如空格 /\\wB\\b/比對’aaaB mbbA’找到aB，/\\bmb/則找到第二行的’mb’ \\B 比對非字元邊界 \\s [ \\f\\n\\r\\t\\v] 比對任何空白字元 \\S [^ \\f\\n\\r\\t\\v] 比對任何非空白字元 \\f [\\x0c\\cL] 符合一個換頁符 \\n [\\x0a\\cJ] 符合一個換行符 \\r [\\x0d\\cM] 符合一個 Enter 符 \\t [\\x09\\cI] 符合一個制表符 \\v [\\x0b\\cK] 符合一個垂直制表符 \\ 反斜線為避開特殊字元，若要表現\\則須用兩個反斜線\\\\ \\cX 控制字元，X 為 A-Z。也就是 Ctrl + [A-Z] 的意思 量詞 (Quantifier)：限制符 指定匹配次數 字元 解說 * 樣式必須出現0次或多次(&gt;0)。例如：/a*/ + 樣式必須出現1次以上(&gt;1)。例如：/a+/ ? 樣式必須出現0或1次(0 or 1)，等同於 {0,1}，例如/a?b/可比對’Aab’的ab或是’Aa’的a * 如果同時使用 + ? 或 {}，將會變成儘可能匹配最少的字元。例如：在「123abc」中應用 /\\d+/ 可匹配「123」，但使用 /\\d+?/ 在相同字串上只能匹配「1」 {n} 樣式必須出現n次。例如/a{3}/ 無法在 “candy” 找到、但 “caaandy” 可以。[A-C]{2} 在A-C之間要符合兩次，”BA” “AC” “CA”…｜ {n,} 樣式至少符合出現n次。｜ {n,m} 樣式出現次數必須介於n到m之間(n~m) 常見用法 功能 正規式 只能輸入數字 /^[0-9]*$/ 只能輸入 n 位的數字 /^\\d{n}$/ 只能輸入至少 n 位的數字 /^\\d{n,}$/ 只能輸入 m~n 位的數字 /^\\d{m,n}$/ 只能輸入零和非零開頭的數字 /^(0|[1-9][0-9]*)$/ 只能輸入有兩位小數的正實數 /^[0-9]+(.[0-9]{2})?$/ 只能輸入有 1~3 位小數的正實數 /^[0-9]+(.[0-9]{1,3})?$/ 只能輸入非零的正整數 /^+?[1-9][0-9]*$/ 只能輸入非零的負整數 /^-[1-9][0-9]*$/ 只能輸入長度為 3 的字符 /^.{3}$/ 只能輸入由 26 個英文字母組成的字符串 /^[A-Za-z]+$/ 只能輸入由 26 個大寫英文字母組成的字符串 /^[A-Z]+$/ 只能輸入由 26 個小寫英文字母組成的字符串 /^[a-z]+$/ 只能輸入由數字和 26 個英文字母組成的字符串 /^[A-Za-z0-9]+$/ 只能輸入由數字、26 個英文字母或者下劃線組成的字符串 /^\\w+$/ 只能輸入漢字 /^[\\u4e00-\\u9fa5]{0,}$/ 驗證用戶密碼(以字母開頭，長度在 6~18 之間，只能包含字符、數字和下劃線) /^[a-zA-Z]\\w{5,17}$/ 驗證 Email 地址 /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$/ 驗證 InternetURL /^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$/ 驗證一年的 12 個月 /^(0?[1-9] 驗證一個月的 31 天 /^((0?[1-9]) 驗證電話號碼 /^((\\d{3,4}-) 驗證台灣身份證字號(1位大寫英文字母和首位數字1或2，共9位數字) /^[A-Z]{1}[1-2]{1}[0-9]{8}$/ 驗證台灣手機電話號碼(09開頭的10個數字) /^09[0-9]{8}$/ 驗證台灣電話號碼/^([-_－—\\s(]?)([(]?)((((0?)|((00)?))(((\\s){0,2})|([-_－—\\s]?)))|(([)]?)[+]?))(886)?([)]?)([-_－—\\s]?)([(]?)[0]?[1-9]{1}([-_－—\\s)]?)[1-9]{2}[-_－—]?[0-9]{3}[-_－—]?[0-9]{3}$/ 可以用來驗證以下號碼(02)3195693093695770209877997560989861389+886912345678+886 2 12345678 驗證用戶密碼長度在 6-18 之間，必須以英文字母開頭，其餘可使用英文字母、數字和下底線/^[a-zA-Z]\\w{5,17}$/ 長度在 6-15 之間，必須包含至少一個大和小寫英文字、一個數字/^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{6,15}$/ 移除字串中所有標點符號12let str=”jfkldsjalk,.23@#!$$k~! @#$%^&amp;*()(_ -=|\\{}[]’;:,./&lt;&gt;??gg g~“`gf”; str = str.replace(/[\\ |\\~|\\`|\\!|\\@|\\#|\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\ |\\=|\\||\\\\|\\[|\\]|\\{|\\}|\\;|\\:|\\”|\\’|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?]/g,''); 判斷中英文字串的長度因為中文佔兩個字元，英文佔1個字元，單純用.length判斷度不對，可使用下方正規式先做字元轉換 123function getLength(str){ return str.replace(/[^\\x00-\\xff]/g,\"**\").length;} 正規式測試用 Regex101 Javascript 常搭配正規式的字串方法.match()會回傳一個符合比對的陣列 123var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';var ary = str.match(/[A-E]/gi); //g比對回傳全部符合的 i不分大小寫console.log(ary); // ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e'] .replace()比對後取代 .replace(/abc/,’a’); 用’a’來取代匹配到的’abc’ strB 因為是abC的C為大寫，在/abc/後多加i則可以不管大小寫辨識到 strC 為ab c中有空白字元所以匹配不到 strD 在/abc/後多加g則可收尋到所有abc並且替換成a 123456789let strA = 'Hi, do you know abc?';let strB = 'The latest airplane designs evolved from slabCraft.';let strC = 'Grab crab';let strD = 'Hi abc, do you know abc?';let resultA = strA.replace(/abc/,'a'); // Hi, do you know a?let resultB = strB.replace(/abc/i,'a'); // The latest airplane designs evolved from slaraft.let resultC = strC.replace(/abc/,'a'); // ab c中有空白字元所以匹配不到let resultD = strD.replace(/abc/g,'a'); // Hi a, do you know a? .search()收尋與比對相符的字串後，回傳第一個字元的索引值，若沒有比對相符則回傳-1 123const str=\"Visit the World!\";console.log(str.search(/world/i)); //10console.log(str.search(/a/i)); //-1 .split()比對符合的字元做為斷點來切割 123var myString = \"Hello 1 word. Sentence number 2.\";var splits = myString.split(/(\\d)/); // 以數字為斷點切分成5段console.log(splits); // [ \"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\" ] 參考資料 MDN文件 網頁研習室 判斷中英文字元長度 正規表示式除字串中所有標點符號 如果中文取代 **,注意正規表示 * 要刪掉避免錯誤 正則表達式的規則 - 這邊只要注意特殊字符有哪些即可 正則表達式介紹 使用 String.prototype.charCodeAt() 判斷字元是中文或英文 - 判斷字元是否超過 255 超過即代表為中文(缺點為需要把字元一個一個拆開) replace() 方法 - 講解 replace() 的用法 正則匹配範例","link":"/2020/11/10/regularExpression/"},{"title":"衍生內建建構器的子類別 subclass","text":"Subclassing a built-in 的兩個障礙:Obstacle 1 帶有內部特性的實體12345678910function Super(x, y){ this.x = x; this.y = y;}function Sub(x, y ,z){ Super.call(this, x, y); this.z = z;} 內建建構器會忽略傳入傳入作為this的子實體 [[Primitive Value]]valueOf() -&gt; toString() 內部實體特性 包裹器建構器 Boolean [[PrimitiveValue]] Number [[PrimitiveValue]] String [[PrimitiveValue]], [[GetOwnProperty]], length 其他建構器 Array [[DefineOwnProperty]] Date [[PrimitiveValue]] Function [[Call]] RegExp [[Match]] Error, Object 沒有內部特性 解決方式12345678910111213141516171819202122232425262728293031function copyOwnPropertiesFrom(targetObj, source){ Object.getOwnPropertyNames(source).forEach(function(propKey){ var propDesc = Object.getOwnPropertyDescriptor(source, propKey); Object.defineProperty(targetObj, propKey, propDesc); }); return targetObj;}function MyAry(/*arguments*/){ var ary = []; Array.prototype.push.apply(ary, arguments); copyOwnPropertiesFrom(ary, MyAry.methods); return ary;}MyAry.methods = { get size(){ var size = 0; for (var i = 0; i &lt; this.length; i++){ if(i in this) size++; } return size; }}var a = new MyAry('aaa','bbb');a.length = 5 a.length// 5a.size // 2 Obstacle 2 無法被當作函式呼叫的建構器Ex. Error 無法用上述方式subclass他們 解決方式 子建構器Sub 內創建新的超實體Super 並複製自有特性到子實體Sub 1234567function NewError(){ var superInstance = Error.appy(null, [arguments]); copyOwnPropertiesFrom(this, superInstance);}NewError.prototype = Object.create(Error.prototype);NewError.prototype.constructor = NewError; 代理 delegation123456789101112131415161718192021222324252627282930313233function MyAry(/*arguments*/){ this.ary = []; Array.prototype.push.apply(this.ary, arguments);}Object.defineProperties(MyAry.prototype, { size: { get: function(){ var size = 0; for (var i = 0; i &lt; this.length; i++){ if(i in this) size++; } return size; } },});//限制: 不能使用[]取值 需用此方式設定get set達成這個功能MyAry.prototype.get = function(index){ return this.ary[index];}MyAry.prototype.set = function(index, value){ return this.ary[index] = value;}//轉移所有Array.prototype的方法Object.getOwnPropertyNames(Array.prototype).forEach(function(propKey){ MyAry.prototype[propKey] = function(){ return Array.prototype[propKey].apply(this.ary, arguments); }});","link":"/2022/09/10/subclass/"},{"title":"Unicode 通用字元集","text":"歷史https://zh.wikipedia.org/wiki/Unicode 8bits ASCII =&gt; 0-127 共128字元https://unicode-table.com/cn/blocks/basic-latin/ ISO 8859-1 國際標準化組織（ISO）及國際電工委員會（IEC）聯合制定 的字元 256字元 Unicode16bits 32bits =&gt; 2^31 =&gt;2,147,483,647字元 Unicode 表示方式U+16進位數值(碼位code point)ex. U+0061 =&gt; aex. U+1F606 =&gt; 😆 「基本平面」 （BMP, Basic Multilingual Plane）Plane 0 U+0000 到 U+FFFF 「輔助平面」 SMP, Supplementary planes or Astral planes）(五或六個數字)Plane 1-16 U+010000 到 U+10FFFF (1,112,064) 編碼方式 &amp; 編碼單位(code units)UTF-32 1個code unitUTF-16 2個code unitsUTF-8 ex. U+1F606 😆 UTF-8 Encoding: 0xF0 0x9F 0x98 0x86UTF-16 Encoding: 0xD83D 0xDE06UTF-32 Encoding: 0x0001F606 1234const smile = '😆'; console.log(smile.length); // '2' code unitssmile === '\\uD83D\\uDE06'; //true JS 內部處理方式為UTF16 code unitsJS 外部處理方式載入時可用charset指定編碼方式建議釋出適用ASCII(7位元格式) charset1&lt;meta charset=\"UTF-8\"&gt; Unicode字元特性https://en.wikipedia.org/wiki/Unicode_character_property Name 英文名稱General Category 類目Age 哪個版本Deprecated 棄用…其他特性 JS &amp; Unicode123456789const \\u0061 = 'hi'; console.log(a); // 'hi''\\xF6' === '\\u00F6' //true//0x00-0xFF之間的可以用此表示方式console.log('o\\u0308'); //ö","link":"/2021/09/21/unicode/"},{"title":"[JS] 同步非同步霧煞煞(下)-Promise,Async,Await","text":"前言接續上一篇同步非同步霧煞煞(上)-AJAX，這篇會介紹Callback hell, promise, Async, Await Callback hell 回呼地獄上一篇提到有非同步特性方法像是Ajax, setTimeout等，當我們使用這些有非同步特性方法，但又希望可以按照我們想要的順序來執行時，一種解決方式是用callback function DEMOsetTimeout的延遲時間為隨機秒數，非同步的特性無法控制哪個setTimeout先執行，把setTimeout個別用 function包起來，且各個 function 都帶入一個 callback 參數。B為A的callback，C為B的，但是如果有太多函式要依序就會變成callback hell，導致程式碼過巢會很難閱讀。 123456789101112131415161718192021222324252627function funcA(check){ setTimeout(function(){ console.log('A'); check('A'); }, Math.random() * 1000);}function funcB(check){ setTimeout(function(){ console.log('B'); check('B'); }, Math.random() * 1000);}function funcC(check){ setTimeout(function(){ console.log('C'); check('C'); }, Math.random() * 1000);}funcA(function(){ funcB(function(){ funcC(function(){ }); });}); Promise早期也有另一個方式是generator，但很少人這樣做。而現在最多人使用的則是Promise來解決常見的非同步問題： Callback hell 寫法不一致(promise用.then來回呼) 無法同時執行無法同時執行(jQuery有並行寫法但不直覺) MDN文件 Promise 可能處於三種階段中任意階段：Pending：正在進行中，還不知道是完成或失敗Resolved（Fulfilled）：表示成功，回傳結果Rejected：表示失敗，回傳失敗原因 1234const newPromise = new Promise((resolve, reject) =&gt; { resolve(someValue); // 成功 reject('失敗原因'); // 失敗}); then()、catch()、finally()在function使用promise功能，return一個 promise 物件即可，then()接收成功，catch()接收失敗，finally()非同步執行完畢（無論是否正確完成）： 123456789101112131415161718192021function promiseFunction(timeout) { // console.log(1) 執行程序1 return new Promise((resolve, reject) =&gt; { // console.log(2) 執行程序2 setTimeout(() =&gt; { resolve('成功'); // console.log(4) 執行程序4 },timeout); if (timeout === 0){ reject('失敗'); // reject(new Error('失敗')) } });};promiseFunction(1000).then((response) =&gt;{ console.log('執行成功', response);}).catch((error)=&gt;{ console.log('執行失敗', error);});// console.log(3) 執行程序3 Promise Chain要串連執行多個 promise 功能的話，則用then()來連結，若其中一個沒成功則會跳到失敗。 12345678910111213promiseFunction(1000).then((response) =&gt;{ console.log('執行成功', response); return promiseFunction(2000);}).then((response) =&gt;{ console.log('執行成功2', response); return promiseFunction(3000);}).then((response) =&gt;{ console.log('執行成功3', response);}).catch((error)=&gt;{ console.log('執行失敗', error);}); 用promise解決上面callback hell的demo 123456789101112131415function promiseFunction(func) { return new Promise((resolve, reject) =&gt; { func(function(){ resolve(); }) });};promiseFunction(funcA).then(()=&gt;{ return promiseFunction(funcB);}).then(()=&gt;{ return promiseFunction(funcC);}).catch((error)=&gt;{ console.log('執行失敗', error);}); //若其中一個沒成功則會跳到失敗 Promise.all()如果funcA, funcB, funcC 的先後順序不重要，直到這三個函式都回覆成功或是其中一個跳失敗 才可以繼續後面行為，可以透過 Promise.all() 來做到： 1234Promise.all([promiseFunction(funcA), promiseFunction(funcB), promiseFunction(funcC)]) .then((response) =&gt;{ console.log(response); }); 適合需要多支 API 要一起執行，並確保全部完成後才進行其他工作時。 Promise.race()同時執行多支API，但僅會回傳最快回應的結果 1234Promise.race([promiseFunction(funcA), promiseFunction(funcB), promiseFunction(funcC)]) .then((response) =&gt;{ console.log(response); }); Async、Awaitasync await 是ES7的語法，搭配Promise來使用，寫法更精簡閱讀起來更簡單，像是在讀同步程式碼，兩者必須一起使用 使用 async function定義一個非同步函式，讓這個函式本體是屬於非同步，但其內部以“同步的方式運行非同步”程式碼。 123456789async function asyncFn() { return data}console.log(asyncFn());//可以得到與 Promise 結構相似的函式，該函式是以非同步的方式運行，無法直接使用 console.log 取得其值。asyncFn().then(r =&gt; { console.log(r)}); await可以暫停非同步函式的運行（中止 Promise 的運行），直到非同步進入 resolve 或 reject，當接收完回傳值後繼續非同步函式的運行。 12345678910111213function promiseFunction(func) { return new Promise((resolve, reject) =&gt; { func(function(){ resolve(); }) });};(async function () { await promiseFunction(funcA); await promiseFunction(funcB); await promiseFunction(funcC);})(); try…catch用try和catch來處理成功和失敗 123456789101112131415161718function promiseFunction(func) { return new Promise((resolve, reject) =&gt; { func(function(){ reject('失敗'); }) });};(async function () { try{ await promiseFunction(funcA); await promiseFunction(funcB); await promiseFunction(funcC); } catch(error){ console.log(error); }})(); 回傳不同錯誤訊息 1234567891011121314151617(async function () { try{ await promiseFunction(funcA); } catch(error){ console.log('A', error); } try{ await promiseFunction(funcB); } catch(error){ console.log('B', error); } try{ await promiseFunction(funcC); } catch(error){ console.log('C', error); }})(); 搭配 Promise.all()123456789(async function () { try{ const data = await Promise.all([promiseFunction(funcA), promiseFunction(funcB), promiseFunction(funcC)]); console.log(data); } catch(error){ console.log(error); }})(); Fetch搭配Async、Awaitfetch 也是基於 Promise 的 Web API，因此它也同樣能夠使用 async/await 來進行改寫，fetch 與一般 AJAX 套件比較不同之處是在 JSON 回傳後，必須在使用 json() 的方法將資料輸出成 JSON 格式（相關介紹可以參考：MDN Fetch）。 當使用 Promise then 時，則會使用 return 來呼叫 json() 方法（箭頭函式縮寫，所以省略了 return）， 1234567891011121314151617181920const url = 'https://randomuser.me/api/';fetch(url).then(response =&gt; response.json()).then(data =&gt; console.log(data)) .catch((err) =&gt; { console.log('錯誤:', err); //async 改寫const url = 'https://randomuser.me/api/';(async function(){ try{ const response = await fetch(url); const data = await response.json(); console.log(data); } catch(error){ console.log(error); }})();","link":"/2020/11/11/promise/"},{"title":"[JS] var, let, const 差異比較","text":"前言這篇會來整理宣告變數傳統的var和ES6新語法let, const的差異比較。 var傳統變數宣告，作用域(scope)為function，在function內宣告只有在function才有作用。如果在function外則為全域(global)。 1234function fn(){ var a = 'ABC';};console.log(a); // a is not defined 在一些區塊(block)，像是if..else、for、while的{大括號}使用var則容易會污染全域變數。 1234567function fn() { var a = 'AAA'; if (true) { var a = 'BBB'; } console.log(a); // 'BBB'} letlet的作用域(scope)為區塊(block)，區塊是指在{大括號}裡面，像是if..else、for、while的{}。另一個特性是禁止在同一層重複宣告(var 可以)，算是跟var類似但較嚴謹的用法。 下面這個例子，若使用var來宣告i，setTimeout 最後結果只會印出 ‘這執行第10次’。是因為用var將i宣告成全域變數，i透過回圈累加，當setTimeout執行時只會拿到最終i=10這個值，解決辦法則是用let宣告。 123456789101112131415161718192021222324for (var i = 0; i &lt; 10; i++) { console.log(i); setTimeout(function () { console.log('這執行第' + i + '次'); }, 10);} for (let i = 0; i &lt; 10; i++) { console.log(i); setTimeout(function () { console.log('這執行第' + i + '次'); }, 10);} //用let宣告i 則會只作用於{}內 並可列印出所有ｉ//若不用let 可用立即函式帶入i這個值到j變數上for (var i = 0; i &lt; 10; i++) { (function (j) { setTimeout(function () { console.log('這執行第' + j + '次'); }, 10); })(i);} var 在全域下的變數會在 window 上，可以在這裡使用 console.log() 看看兩者之間的差異： 123456// 這段宣告擇一執行var mom = \"老媽\";let mom = \"老媽\";console.log(window.mom);// var 會出現 \"老媽\"// let 會出現 undefined const與 let ㄧ樣，作用域(scope)為區塊(block)，區塊是指在{大括號}裡面，像是if..else、for、while的{}。不同的地方是const在宣告時必須賦予一個值，並且之後不能再更改。也無法再用 let或 var 重新宣告變數。 123const a ='AAA';const a ='BBB';// 會跳錯 Identifier 'a' has already been declared 參考資料 ES6 開始的新生活 let, const ECMAScript6 入門：var、let、const 差異 JavaScript: var, let, const 差異 JavaScript ES6 Block Scope - let, const Day26 var 與 ES6 let const 差異","link":"/2020/11/17/varLetConst/"},{"title":"[Vue] Vue的生命週期 Lifecycle hooks","text":"前言第一篇Vue的筆記記錄，就來釐清Vue頁面的…生老病死。讓我們想在它出生時就賦予它怎樣的能力還是死掉前叫它做什麼＠＠…就是任人擺布的人生啦！（誤）…因為目前為Vue2到Vue3的過渡期，Vue3還沒有很普及主要的資訊是從官方文件，整理的資訊還是會以Vue2為主。 Vue的生命週期hooksVue的生命週期包含了幾個時間點事件(hooks)，beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy(Vue3-beforeUnmount)、destroyed(Vue3-unmounted)，我們可以在這些不同的時間點底下註冊不同的函式方法，來控制Vue(注意：註冊的函式不要使用箭頭函式，因為沒有this的指向)。另外還有搭配keep-alive元件使用的activated、deactivated。Vue3新增的errorCapture來補獲子元件的錯誤、renderTracked、renderTriggered測試用。 生命週期圖Vue2的生命週期圖 圖片出處 Adagio’s Blog Vue3的生命週期圖 圖片出處 Vue官方文件 1. Create階段beforeCreate實例初始化之後，this指向創建的實例。此時無法讀取data、watch、computed、methods，頁面DOM結構也還沒初始化。 created實例創建完成，導入數據data、props、computed。data、watch、computed、methods可用，頁面DOM結構還沒被render出來，且$el和$ref屬性還不存在。常用來發送AJAX請求。若在此階段進行的DOM操作一定要放在Vue.nextTick()的回調函數中。 2. 掛載 Mount判斷是否有$el屬性，若沒有則使用$mount掛載el，接著判斷是否有$template屬性，若有則直接render template，沒有就使用el外層的HTML作為template。 beforeMount$el初始化，對應的template已在內存編譯完成，但還沒render到頁面上。 mountedvm.$el創建完成，DOM掛載Vue、雙向綁定和畫面Render完成，可對DOM、$ref操作。如果有用到一些第三方插件，必须在mounted中来初始化插件。 3. update 更新階段當data發生變化，畫面需要重新Render時 beforeUpdate當data發生變化被呼叫使用，data是新的，但新畫面還未被Render，可操作舊畫面的DOM，例如手動移除添加事件監聽。 updateddata是新的，新畫面被render出來了。請勿在此去更改data，不然就會無限迴圈了。 4. Destroy / Unmount 卸載當呼叫 destroy / unmount 函式時，則會執行卸載的動作 beforeDestroy (Vue3 改為 beforeUnmount)執行卸載前，此時data和方法等都是完整功能可使用的。可用來關閉計時器、移除在全域綁定的時間，移除自訂事件監聽、刪除提示等等。 destroyed(Vue3 改為 unmounted)卸載完成。Vue實例銷毀，所有的DOM元素綁定被解除、移除監聽事件、Vue child 實例也被一併銷毀。無法再對實例進行任何操作。 父元件和子元件的生命週期掛載與Render父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子元件update父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 新增子元件2父 beforeUpdate -&gt; 子2 beforeCreate -&gt;子2 created -&gt; 子2 beforeMount -&gt; 子2 mounted -&gt; 父 updated 父元件update父 beforeUpdate -&gt; 父 updated 卸載 unmount父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 父元件監聽子元件的生命週期當父元件Parent監聽到子元件 Child的mounted、created、updated就做某件事 123456789101112131415161718// 需要手動通過 $emit 觸發父元件的事件// Parent.vue&lt;Child @mounted=\"doSomething\"/&gt;// Child.vuemounted() {this.$emit(\"mounted\");}// 在父元件引用子元件時透過 @hook 來監聽// Parent.vue&lt;Child @hook:mounted=\"doSomething\" &gt;&lt;/Child&gt;doSomething() {console.log('父組件監聽到 mounted hook');},// Child.vuemounted(){console.log('子組件觸發 mounted hook');}, activated 和 deactivatedactivated 和 deactivated hook只有在有&lt;keep-alive&gt;元件時才會出現的，我們先來了解&lt;keep-alive&gt;是什麼 keep-alive 元件當使用&lt;keep-alive&gt;包住頁面中元件時，此元件就不會執行卸載(destroy or unmount)，可以維持元件資料狀態，重新點選到時不會再次載入。處理緩存(cache)的方案。 三種props: include: 包含這些名稱的元件都要緩存，其他都不要緩存。 exclude: 除了這些名稱的元件不要緩存，其他都要緩存。 可帶入字串，陣列或正規表達式來判斷 判斷名稱一般是元件的name，若無設定name，則會查找它的局部註冊名稱(the key in the parent’s components option) 。anonymous component 不能被查找。 1234567891011121314&lt;!--字串 以逗號作為分隔 --&gt;&lt;keep-alive include=\"a,b\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 陣列 array --&gt;&lt;keep-alive :include=\"['a', 'b']\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 以正規表達式作為查找規則 --&gt;&lt;keep-alive :include=\"/a|b/\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; max： 緩存元件數量上限。當達到設定的數值，新實體還未創建前(beforeCreated)，最舊的實體會被銷毀。 123&lt;keep-alive :max=\"10\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt; &lt;/keep-alive&gt; 要注意的是， 不會在 functional component 中正常運作，因為他們沒有實體。 下面這個DEMO因為有在元件pages用keep-alive，點擊其他元件時，元件pages緩存不會被卸載，所以點回元件pages畫面會在剛剛閱讀的文章上，若沒設置keep-alive則會重新載入到預設的畫面。 See the Pen Vue keep-alive by KaiYun Cheng (@kaiyuncheng) on CodePen. 延伸閱讀 使用 keep-alive 動態 router activated 和 deactivated當使用&lt;keep-alive&gt;包住頁面中元件時，此元件就不會執行卸載(destroy or unmount)，而會有兩個對應的hooks，當元件觸發時activated 和 停用時deactivated。 對應兩個鉤子函數 activated 和 deactivated ，當組件被激活時，觸發鉤子函數 activated，當組件被移除時，觸發鉤子函數 deactivated。 Vue3另外Vue3新增的errorCapture來補獲子元件的錯誤、renderTracked、renderTriggered測試用，因為還沒實際用過，往後會再補上。 參考資料 Vue官方文件 Adagio’s Blog 「Vue.js 學習筆記 Day14」- Vue生命週期 Vue.js教程","link":"/2020/12/20/vueLifecycle/"},{"title":"[Tools] 模組化打包 About Webpack","text":"前言先前有介紹一篇關於gulp的用法，當中有比較gulp和webpack兩者之間的優缺點，若還沒看過可先看這一篇 前端自動化管理 About Gulp 4.0，本篇的話會來整理webpack的觀念和基礎用法。 用Webpack要做什麼？也是用來把來源 編譯、壓縮打包 輸出成瀏覽器可以讀懂的或是效能更好的檔案。 Webpack 基礎安裝安裝前，因為是基於Node.js開發，當然先需要Node.js，這邊就不詳細介紹。npm管理工具會隨著node.js一起安裝好，接著我們可以用npm安裝webpack 專案初始化生成package.jsonnpm init 安裝 webpack webpack-clinpm install webpack webpack-cli --save-dev 使用–save會把模組加到dependencies執行專案時用，–save-dev則會添加到devDependencies給開發專案時使用。 安裝webpack的過程中，有遇到zsh: command not found: webpack的問題，因為我的終端機是使用zsh，這邊需要下面這些步驟來解決路徑問題 echo 'export PATH=\"./node_modules/.bin:$PATH\"' &gt;&gt; ~/.zshrcsource ~/.zshrc 設定 Entry &amp; Output這邊會需要先建立webpack的設定檔 webpack.config.js entry 輸入端： 資料來源，一般就是從src資料夾output 輸出端： 資料輸出的放置位置， 123456789const path = require('path');module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js', },}; 要打包輸出就直接輸入webpack即可開始運行。也可在package.json中的script添加run的名稱，例如build去執行webpack這個指令 “build”: “webpack”。 npm run build 也可依照專案需求去設定指令。這邊參照mike大的教學watch : 修改程式碼就同步編譯執行，設定成 development 版本。start : 執行一次性編譯，設定成 development 版本。deploy : 執行一次性編譯，設定成 production 版本。 12345\"scripts\": { \"watch\": \"webpack --mode development --watch\", \"start\": \"webpack --mode development\", \"deploy\": \"webpack --mode production\" }, 常用的loaders要用webpack來編譯什麼，就會使用不同的loaders來實現，像是編譯ES6的babel-loader，編譯Sass的sass-loader，有非常多種，從下面連結可以查詢。 各種loaders 接下來會介紹比較常用的，基本用法都蠻類似的掛載在module內的loaders是從下往上讀取 Webpack + BABEL 轉譯ES6語法這邊會先安裝 babel-loader 這個套件 Babel Loader npm install -D babel-loader @babel/core @babel/preset-env 在webpack.config.js中添加babel loader的設定，一般loaders都是掛載在module下 123456789101112131415161718192021222324const path = require('path');module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js', }, module: { //loaders放置在module rules: [ { test: /\\.m?js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: [['@babel/preset-env', { targets: 'defaults' }]], }, }, }, ], },}; Webpack 模組化要把各個模組的js統合成一個最終js檔案，可以解決js loading的先後順序問題。主要就是利用export和import，經過webpack就會統整成最終js。 在組件的js(ex Menu.js)做export 123export default function Menu() { console.log('menu');} 在要統整的主檔案js(ex index.js)做import 1234import Menu from './menu.js'window.onload = function() { Menu();} 若需求只有要做模組化可使用Snowpack 簡單又快速參考Huli大的文章 webpack 新手教學之淺談模組化與 snowpack Webpack + SASS 編譯編譯sass同時也編譯css，這邊會先安裝 css-loader、sass-loader和style-loader，載入到header中的style，css webpack預設編譯成js sass-loader css-loader style-loader npm install css-loader style-loader --save-devnpm install sass-loader node-sass --save-dev 一樣是在webpack.config.js中加入module 12345678910111213141516171819module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, { test: /\\.s[ac]ss$/i, use: [ // Creates `style` nodes from JS strings 'style-loader', // Translates CSS into CommonJS 'css-loader', // Compiles Sass to CSS 'sass-loader', ], }, ], }, 在統合的js中import要編譯的scss檔 1import './all.scss'; Plugins與loaders的差異：loaders用在處理單一js檔案，在bundle之前或是正在bundle的階段。而Plugins是在bundle或是chunk的階段，通常是在bundle產生的最後階段。 Plugins有兩種，built-in plugins，在webpack就可以使用和第三方開發的plugins，用npm install安裝上去，可以補強一些Webpack的功能，像是uglify、minify、移除未使用的CSS（PurgeCSS）等。 Plugins List mini-css extract plugins若是想把css額外輸出成一個.css的檔案，則需用mini-css extract plugins，上面所提到的css-loader 和 style-loader是 將 CSS 樣式注入到 HTML 的 style 標籤裡面。 mini-css extract plugins npm install mini-css-extract-plugin --save-devnpm install css-loader --save-dev webpack.config.js中設定 1234567891011121314const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = { plugins: [new MiniCssExtractPlugin()], module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], }, ], },}; 在統合的js中import要編譯的css檔 1import './style.css'; 還可以修改生成路徑，例如css資料夾底下 123456plugins: [ new MiniCssExtractPlugin({ filename: 'css/[name].css', }), ], Chunk更深入去了解Webpack，可能會接觸到這個名字Chunk，這邊我先把目前能夠理解的列出來，更深入可以到這邊慢慢研究 Webpack理解Chunk Chunk是Webpack打包過程中，一堆module的集合。Webpack的打包是從一個入口文件開始，也可以說是入口模塊，入口模塊引用這其他模塊，模塊再引用模塊。Webpack通過引用關係逐個打包模塊，這些module就形成了一個Chunk。如果我們有多個入口文件，可能會產出多條打包路徑，一條路徑就會形成一個Chunk。Chunk是過程中的代碼塊，Bundle是結果的代碼塊。 …待續 參考資料 Webpack 官方文件 前端構建工具——Webpack vs Gulp 關於Webpack #1 - 第一次就上手 Babel Loader Webpack教學 (四)：JavaScript 與 Babel Webpack理解Chunk webpack 新手教學之淺談模組化與 snowpack","link":"/2020/12/12/webpack/"},{"title":"Websocket &#x2F; Socket.IO","text":"WebsocketWebsocket是Html5的一種網路協定，用於前端瀏覽器(Client)與後端(Server)的溝通，協定只需要連線一次，除非有一方斷開連接，否則就會一直存在，不需重複請求，常用實作於聊天室、訊息推播、共同編輯上。 Socket.IO 一套 JavaScript 函式庫工具包當時一些瀏覽器還不支持websocket協議的時候。socket.io會改選擇使用傳統的long polling方式運作。如果支援的話則會用websocket的協議。 安裝 socket IO 和 socket IO Client版socket.io：node.js http server 使用socket.io-client： client 瀏覽器端 使用安裝指令：npm i -D socket.io socket.io-client 使用方法 Server 端 建立連線/事件傳送方向 Client 端 io.on(‘connection’, (socket) =&gt; {…}) 建立連線 socket = io(“socket ip:port”) io.emit(“要對 所有 Client 廣播的事件名稱”, data) ———&gt; socket.on(“來自client 的事件名稱”, callback) socket.emit(“要對 當前連線 的 Client 發送的事件名稱”, data) ———&gt; socket.on(“來自client 的事件名稱”, callback) socket.on(“來自client 的事件名稱”, callback) &lt;——— socket.emit(“要對 server 發送的事件名稱”,data) Cheatsheet1234567891011121314151617181920212223242526272829303132333435363738394041socket.emit('message', \"this is a test\"); //sending to sender-client onlysocket.broadcast.emit('message', \"this is a test\"); //sending to all clients except sendersocket.broadcast.to('game').emit('message', 'nice game'); //sending to all clients in 'game' room(channel) except sendersocket.to('game').emit('message', 'enjoy the game'); //sending to sender client, only if they are in 'game' room(channel)socket.broadcast.to(socketID).emit('message', 'for your eyes only'); //sending to individual socketIDio.emit('message', \"this is a test\"); //sending to all clients, include senderio.in('game').emit('message', 'cool game'); //sending to all clients in 'game' room(channel), include senderio.of('myNamespace').emit('message', 'gg'); //sending to all clients in namespace 'myNamespace', include sendersocket.emit(); //send to all connected clientssocket.broadcast.emit(); //send to all connected clients except the one that sent the messagesocket.on(); //event listener, can be called on client to execute on serverio.sockets.socket(); //for emiting to specific clientsio.sockets.emit(); //send to all connected clients (same as socket.emit)io.sockets.on() ; //initial connection from a client. 整理來源：用 Socket.io 做一個即時聊天室吧！（直播筆記） Server端如何建立連接 https://socket.io/docs/v4/tutorial/step-3引入 Server 到 index.ts 1234567891011121314151617181920212223import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';import { Server } from 'socket.io';const app = express();const server = createServer(app);const io = new Server(server);const __dirname = dirname(fileURLToPath(import.meta.url));app.get('/', (req, res) =&gt; { res.sendFile(join(__dirname, 'index.html'));});io.on('connection', (socket) =&gt; { console.log('a user connected');});server.listen(3000, () =&gt; { console.log('server running at http://localhost:3000');}); 1234567891011121314151617181920212223242526272829303132333435363738//建立連線io.on(\"connection\", (socket) =&gt; { // emit發送訊息給所有人 socket.emit('userID', socket.id); // socket.on 接收join這個頻道的資訊 socket.on(\"join\", ({ userName, roomName }) =&gt; { const userData = userService.userDataInfoHandler( socket.id, userName, roomName ); userService.addUser(userData); socket.join(userData.roomName); // socket.broadcast 發送給所有人 .to指定在哪個頻道 .emit發送 socket.broadcast.to(userData.roomName).emit(\"join\", `${userData.userName} joined ${userData.roomName}`); }); // socket.on 接收chat這個頻道的資訊 msg socket.on(\"chat\", (msg) =&gt; { const time = moment.utc(); const userData = userService.getUser(socket.id); if(userData){ // .to指定在哪個頻道 .emit發送 io.to(userData.roomName).emit(\"chat\", {userData, msg, time}); } }); // disconnect 離線 socket.on(\"disconnect\", () =&gt; { const userData = userService.getUser(socket.id); if (userData?.userName) { socket.broadcast.to(userData.roomName).emit(\"leave\", `${userData.userName} left ${userData.roomName}`); } userService.removeUser(socket.id); });}); Client端1234567891011121314151617181920212223242526272829303132import { io } from \"socket.io-client\";//1. 建立連接const clientIo = io();// 開啟join這個頻道 傳送userName, roomName給serverclientIo.emit(\"join\", { userName, roomName });// 開啟join這個頻道 接收server傳過來的msg並進行處理clientIo.on(\"join\", (msg: string) =&gt; { roomMsgHandler(msg);});submitBtn.addEventListener(\"click\", () =&gt; { const textValue = textInput.value; // 傳送msg到chat這個頻道給server clientIo.emit(\"chat\", textValue);});// 開啟chat這個頻道 接收server傳過來的data 並進行處理clientIo.on(\"chat\", (data) =&gt; { msgHandler(data);});clientIo.on(\"leave\", (msg: string) =&gt; { roomMsgHandler(msg);});clientIo.on(\"userID\", (id) =&gt; { userID = id;}); 參考資料 淺談 WebSocket 協定：實作一個簡單的即時聊天室吧！ 【筆記】Socket，Websocket，Socket.io的差異 WebSocket 基本介紹及使用筆記 用 Socket.io 做一個即時聊天室吧！（直播筆記）","link":"/2024/01/07/websocket/"},{"title":"[JS] 關於window.location類別功能：轉址、取得網址參數","text":"關於這篇主要會整理 視窗轉址、取得網址屬性參數等等用法。 取得目前網頁資訊 location屬性location.href 可以是用來取得目前網頁網址以下以在MDN收尋location為例： 1234567891011121314151617// location.href: 用來取得目前網頁網址// https://developer.mozilla.org/en-US/search?q=locationconsole.log('location.href: '+location.href); // 通訊協定 location.protocol: https:console.log('location.protocol: '+location.protocol); // 網域名稱 location.hostname: developer.mozilla.orgconsole.log('location.hostname: '+location.hostname);// location.host: developer.mozilla.orgconsole.log('location.host: '+location.host);// 可以 get 或 set port 值 location.port: console.log('location.port: '+location.port); // 網址路徑 location.pathname: /en-US/searchconsole.log('location.pathname: '+location.pathname);// 網址參數 location.search: ?q=locationconsole.log('location.search: '+location.search);// hash 值 如果網址中沒有 hash 則會返回空字串。注意返回的 hash 包含井字號 #。console.log('location.hash: '+location.hash); URL() 建構式裡面也有上述的屬性 1var url = new URL(location.href); 另外可以用.searchParams()來取得網址參數用 .entries() 方法搭配 for … of 則可把key跟value取出 1234567891011var url = new URL('https://github.com/search?q=javascript&amp;type=code');let params = url.searchParams;console.log(params.toString()); //字串 q=javascript&amp;type=codeurl.searchParams.get('q'); // javascripturl.searchParams.get('type'); // codefor (let pair of params.entries()) { console.log(`key: ${pair[0]}, value: ${pair[1]}`);}// key: q, value: javascript// key: type, value: code 設定網頁locationlocation.href除了可以查詢現在網頁地址，也可以用來設定目前的視窗要切換去的網址 1234// 切到同一個網站，不同的路徑location.href = '/search?q=javascript/';// 切換到另一個網站location.href = 'https://www.google.com/'; location.assign(url)也可設定目前的視窗要切換去的網址 1location.assign('https://www.google.com/'); location.replace(url)也可設定目前的視窗要切換去的網址，與assign的差別是，replace會在history中被新的網頁取代，無法使用回到上一頁。 1location.replace('https://www.google.com/'); location.reload()可設定是否要重新整理網頁參數為布林值：true 用來強制瀏覽器從 server 取得最新的資料；false(預設)，會優先從瀏覽器暫存檔 (cache) 中取得網頁資料。 1location.reload(true); 1234function refresh(){ window.location.reload();}setTimeout('refresh()',1000); //每一秒就重新整理網頁 其他重新整理頁面的用法 history.go(0) history.go(0):重新整理本頁history.go(-1):回到上一頁 = history.back();history.go(-2):回到上一頁的上一頁history.go(1):到下一頁 = history.forward(); window.location = location.href location.assign(location.href) location.replace(location.href) window.navigate(location.href) document.execCommand(‘Refresh’) document.URL=location.href 1234&lt;!-- 20秒後重新整理 --&gt;&lt;meta http-equiv=\"refresh\" content=\"20\"&gt; &lt;!-- 20秒後跳轉到https://www.google.com/ --&gt;&lt;meta http-equiv=\"refresh\" content=\"20;url=https://www.google.com/\"&gt; 開關視窗時刷新123456&lt;body onload=\"opener.location.reload()\"&gt; &lt;!--開視窗時刷新--&gt;&lt;body onUnload=\"opener.location.reload()\"&gt; &lt;!--關視窗時刷新--&gt;&lt;script language=\"javascript\"&gt; window.opener.document.location.reload()&lt;/script&gt; 參考資料 Javascript 頁面跳轉、刷新、重定向的幾種方式 用 JavaScript 取得目前網址與其它網址參數簡單語法 JavaScript location Object window 物件的屬性 location JavaScript：回上一頁、各種跳轉頁面方法與 window.location 物件 javascript筆記 - window.location類別 Javascript 刷新頁面的幾種方法","link":"/2020/11/25/windowLocation/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"jsdoc","slug":"jsdoc","link":"/tags/jsdoc/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"},{"name":"c3.js","slug":"c3-js","link":"/tags/c3-js/"},{"name":"coding girl","slug":"coding-girl","link":"/tags/coding-girl/"},{"name":"Functional Programming","slug":"Functional-Programming","link":"/tags/Functional-Programming/"},{"name":"currying","slug":"currying","link":"/tags/currying/"},{"name":"Higher-order functions","slug":"Higher-order-functions","link":"/tags/Higher-order-functions/"},{"name":"Partial application","slug":"Partial-application","link":"/tags/Partial-application/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Destructuring Assignment","slug":"Destructuring-Assignment","link":"/tags/Destructuring-Assignment/"},{"name":"event queue","slug":"event-queue","link":"/tags/event-queue/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"Synchronous","slug":"Synchronous","link":"/tags/Synchronous/"},{"name":"Fetch","slug":"Fetch","link":"/tags/Fetch/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","link":"/tags/XMLHttpRequest/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"Arrow Functions","slug":"Arrow-Functions","link":"/tags/Arrow-Functions/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"window.location","slug":"window-location","link":"/tags/window-location/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Time Complexity","slug":"Time-Complexity","link":"/tags/Time-Complexity/"},{"name":"catalogue","slug":"catalogue","link":"/tags/catalogue/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Sequential Search","slug":"Sequential-Search","link":"/tags/Sequential-Search/"},{"name":"Local Storage","slug":"Local-Storage","link":"/tags/Local-Storage/"},{"name":"Session Storage","slug":"Session-Storage","link":"/tags/Session-Storage/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"date","slug":"date","link":"/tags/date/"},{"name":"time","slug":"time","link":"/tags/time/"},{"name":"operators","slug":"operators","link":"/tags/operators/"},{"name":"Inheritance","slug":"Inheritance","link":"/tags/Inheritance/"},{"name":"Prototype Chain","slug":"Prototype-Chain","link":"/tags/Prototype-Chain/"},{"name":"Prototype","slug":"Prototype","link":"/tags/Prototype/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"Regular Expression","slug":"Regular-Expression","link":"/tags/Regular-Expression/"},{"name":"RegEx","slug":"RegEx","link":"/tags/RegEx/"},{"name":"subclass","slug":"subclass","link":"/tags/subclass/"},{"name":"constructor","slug":"constructor","link":"/tags/constructor/"},{"name":"unicode","slug":"unicode","link":"/tags/unicode/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Async","slug":"Async","link":"/tags/Async/"},{"name":"Await","slug":"Await","link":"/tags/Await/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue2","slug":"vue2","link":"/tags/vue2/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"Lifecycle","slug":"Lifecycle","link":"/tags/Lifecycle/"},{"name":"hooks","slug":"hooks","link":"/tags/hooks/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"socket.IO","slug":"socket-IO","link":"/tags/socket-IO/"},{"name":"url","slug":"url","link":"/tags/url/"}],"categories":[{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"},{"name":"murmur","slug":"murmur","link":"/categories/murmur/"},{"name":"Functional JS","slug":"Javascript/Functional-JS","link":"/categories/Javascript/Functional-JS/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Websocket","slug":"Websocket","link":"/categories/Websocket/"}],"pages":[]}